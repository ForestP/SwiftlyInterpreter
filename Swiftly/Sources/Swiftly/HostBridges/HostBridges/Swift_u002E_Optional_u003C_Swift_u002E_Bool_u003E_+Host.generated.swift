// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Optional<Swift.Bool>

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Swift_u002E_Bool_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Bool_u003E___Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Optional.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> metatype") }
    var lhs: Swift.Bool? = nil
    if case .nilValue = args[1] {
        lhs = nil
    } else {
        lhs = try args[1].expectBool("lhs")
    }
    var rhs: Swift.Bool? = nil
    if case .nilValue = args[2] {
        rhs = nil
    } else {
        rhs = try args[2].expectBool("rhs")
    }
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Swift_u002E_Double_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Double_u003E___Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Optional.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> metatype") }
    var lhs: Swift.Double? = nil
    if case .nilValue = args[1] {
        lhs = nil
    } else {
        lhs = try args[1].expectDouble("lhs")
    }
    var rhs: Swift.Double? = nil
    if case .nilValue = args[2] {
        rhs = nil
    } else {
        rhs = try args[2].expectDouble("rhs")
    }
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Optional.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> metatype") }
    var lhs: Swift.Int? = nil
    if case .nilValue = args[1] {
        lhs = nil
    } else {
        lhs = try args[1].expectInt("lhs")
    }
    var rhs: Swift.Int? = nil
    if case .nilValue = args[2] {
        rhs = nil
    } else {
        rhs = try args[2].expectInt("rhs")
    }
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Swift_u002E_String_u003E___Swift_u002E_Optional_u003C_Swift_u002E_String_u003E___Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Optional.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> metatype") }
    var lhs: Swift.String? = nil
    if case .nilValue = args[1] {
        lhs = nil
    } else {
        lhs = try args[1].expectString("lhs")
    }
    var rhs: Swift.String? = nil
    if case .nilValue = args[2] {
        rhs = nil
    } else {
        rhs = try args[2].expectString("rhs")
    }
    let result = lhs == rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Wrapped_u003E___Swift_u002E_Optional_u003C_Wrapped_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
        return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Swift_u002E_Bool_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Bool_u003E___Wrapped_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
        return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Swift_u002E_Double_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Double_u003E___Wrapped_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
        return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Wrapped_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
        return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Optional_u003C_Swift_u002E_String_u003E___Swift_u002E_Optional_u003C_Swift_u002E_String_u003E___Wrapped_Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Optional<Swift.Bool> (lhs: Swift.Optional<Swift.Bool>, rhs: Swift.Optional<Swift.Bool>)",
        "  - Swift.Optional<Swift.Double> (lhs: Swift.Optional<Swift.Double>, rhs: Swift.Optional<Swift.Double>)",
        "  - Swift.Optional<Swift.Int> (lhs: Swift.Optional<Swift.Int>, rhs: Swift.Optional<Swift.Int>)",
        "  - Swift.Optional<Swift.String> (lhs: Swift.Optional<Swift.String>, rhs: Swift.Optional<Swift.String>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Optional.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

