// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Array<Swift.String>

public func Host_Swift_u002E_Array_u003C_Element_u003E__joined_u0028_separator_u003A__u0029___Swift_u002E_String__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.joined(separator:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let separator = try args[1].expectString("separator")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.joined(separator: separator)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__joined_u0028_separator_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__joined_u0028_separator_u003A__u0029___Swift_u002E_String__Element_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Swift.String> (separator: Swift.String)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.joined(separator:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__joined_u0028_separator_u003A__u0029___Swift_u002E_String__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.joined(separator:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

