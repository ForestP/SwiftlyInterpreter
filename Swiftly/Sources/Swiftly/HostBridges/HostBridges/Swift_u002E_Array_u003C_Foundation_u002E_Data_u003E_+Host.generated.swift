// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Array<Foundation.Data>

public func Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Foundation.Data>") }
    var lhs_arrayValue: Swift.Array<Foundation.Data> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element: Foundation.Data = try vm.withHost(elementValue, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
            host
        }
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Foundation.Data>") }
    var rhs_arrayValue: Swift.Array<Foundation.Data> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element: Foundation.Data = try vm.withHost(elementValue, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
            host
        }
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Bool>") }
    var lhs_arrayValue: Swift.Array<Swift.Bool> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectBool("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Bool>") }
    var rhs_arrayValue: Swift.Array<Swift.Bool> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectBool("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Double>") }
    var lhs_arrayValue: Swift.Array<Swift.Double> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectDouble("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Double>") }
    var rhs_arrayValue: Swift.Array<Swift.Double> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectDouble("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Int>") }
    var lhs_arrayValue: Swift.Array<Swift.Int> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectInt("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Int>") }
    var rhs_arrayValue: Swift.Array<Swift.Int> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectInt("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.String>") }
    var lhs_arrayValue: Swift.Array<Swift.String> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectString("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.String>") }
    var rhs_arrayValue: Swift.Array<Swift.String> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectString("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.UInt8>") }
    var lhs_arrayValue: Swift.Array<Swift.UInt8> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element: Swift.UInt8 = try vm.withHost(elementValue, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
            host
        }
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.UInt8>") }
    var rhs_arrayValue: Swift.Array<Swift.UInt8> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element: Swift.UInt8 = try vm.withHost(elementValue, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
            host
        }
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs != rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Element_u003E___Swift_u002E_Array_u003C_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___Element_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___Element_Swift_u002E_UInt8(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Array<Foundation.Data> (lhs: Swift.Array<Foundation.Data>, rhs: Swift.Array<Foundation.Data>)",
        "  - Swift.Array<Swift.Bool> (lhs: Swift.Array<Swift.Bool>, rhs: Swift.Array<Swift.Bool>)",
        "  - Swift.Array<Swift.Double> (lhs: Swift.Array<Swift.Double>, rhs: Swift.Array<Swift.Double>)",
        "  - Swift.Array<Swift.Int> (lhs: Swift.Array<Swift.Int>, rhs: Swift.Array<Swift.Int>)",
        "  - Swift.Array<Swift.String> (lhs: Swift.Array<Swift.String>, rhs: Swift.Array<Swift.String>)",
        "  - Swift.Array<Swift.UInt8> (lhs: Swift.Array<Swift.UInt8>, rhs: Swift.Array<Swift.UInt8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Array.!=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Foundation.Data>") }
    var lhs_arrayValue: Swift.Array<Foundation.Data> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element: Foundation.Data = try vm.withHost(elementValue, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
            host
        }
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Foundation.Data>") }
    var rhs_arrayValue: Swift.Array<Foundation.Data> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element: Foundation.Data = try vm.withHost(elementValue, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
            host
        }
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs + rhs
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Bool>") }
    var lhs_arrayValue: Swift.Array<Swift.Bool> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectBool("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Bool>") }
    var rhs_arrayValue: Swift.Array<Swift.Bool> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectBool("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs + rhs
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Double>") }
    var lhs_arrayValue: Swift.Array<Swift.Double> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectDouble("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Double>") }
    var rhs_arrayValue: Swift.Array<Swift.Double> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectDouble("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs + rhs
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Int>") }
    var lhs_arrayValue: Swift.Array<Swift.Int> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectInt("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Int>") }
    var rhs_arrayValue: Swift.Array<Swift.Int> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectInt("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs + rhs
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.String>") }
    var lhs_arrayValue: Swift.Array<Swift.String> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectString("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.String>") }
    var rhs_arrayValue: Swift.Array<Swift.String> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectString("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs + rhs
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.UInt8>") }
    var lhs_arrayValue: Swift.Array<Swift.UInt8> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element: Swift.UInt8 = try vm.withHost(elementValue, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
            host
        }
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.UInt8>") }
    var rhs_arrayValue: Swift.Array<Swift.UInt8> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element: Swift.UInt8 = try vm.withHost(elementValue, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
            host
        }
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs + rhs
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Element_u003E___Swift_u002E_Array_u003C_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___Element_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___Element_Swift_u002E_UInt8(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Array<Foundation.Data> (lhs: Swift.Array<Foundation.Data>, rhs: Swift.Array<Foundation.Data>)",
        "  - Swift.Array<Swift.Bool> (lhs: Swift.Array<Swift.Bool>, rhs: Swift.Array<Swift.Bool>)",
        "  - Swift.Array<Swift.Double> (lhs: Swift.Array<Swift.Double>, rhs: Swift.Array<Swift.Double>)",
        "  - Swift.Array<Swift.Int> (lhs: Swift.Array<Swift.Int>, rhs: Swift.Array<Swift.Int>)",
        "  - Swift.Array<Swift.String> (lhs: Swift.Array<Swift.String>, rhs: Swift.Array<Swift.String>)",
        "  - Swift.Array<Swift.UInt8> (lhs: Swift.Array<Swift.UInt8>, rhs: Swift.Array<Swift.UInt8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Array.+(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._checkSubscript(_:wasNativeTypeChecked:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._checkSubscript(index, wasNativeTypeChecked: wasNativeTypeChecked)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._checkSubscript(_:wasNativeTypeChecked:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._checkSubscript(index, wasNativeTypeChecked: wasNativeTypeChecked)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._checkSubscript(_:wasNativeTypeChecked:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._checkSubscript(index, wasNativeTypeChecked: wasNativeTypeChecked)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._checkSubscript(_:wasNativeTypeChecked:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._checkSubscript(index, wasNativeTypeChecked: wasNativeTypeChecked)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._checkSubscript(_:wasNativeTypeChecked:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._checkSubscript(index, wasNativeTypeChecked: wasNativeTypeChecked)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._checkSubscript(_:wasNativeTypeChecked:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._checkSubscript(index, wasNativeTypeChecked: wasNativeTypeChecked)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int, wasNativeTypeChecked: Swift.Bool)",
            "  - Swift.Array<Swift.Bool> (Swift.Int, wasNativeTypeChecked: Swift.Bool)",
            "  - Swift.Array<Swift.Double> (Swift.Int, wasNativeTypeChecked: Swift.Bool)",
            "  - Swift.Array<Swift.Int> (Swift.Int, wasNativeTypeChecked: Swift.Bool)",
            "  - Swift.Array<Swift.String> (Swift.Int, wasNativeTypeChecked: Swift.Bool)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int, wasNativeTypeChecked: Swift.Bool)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._checkSubscript(_:wasNativeTypeChecked:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___checkSubscript_u0028___u003A_wasNativeTypeChecked_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._checkSubscript(_:wasNativeTypeChecked:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Foundation_u002E_Data_u003E___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let buffer: Swift.UnsafeMutableBufferPointer<Foundation.Data> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Foundation.Data>", as: Swift.UnsafeMutableBufferPointer<Foundation.Data>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let buffer: Swift.UnsafeMutableBufferPointer<Swift.Bool> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.Bool>", as: Swift.UnsafeMutableBufferPointer<Swift.Bool>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let buffer: Swift.UnsafeMutableBufferPointer<Swift.Double> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.Double>", as: Swift.UnsafeMutableBufferPointer<Swift.Double>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let buffer: Swift.UnsafeMutableBufferPointer<Swift.Int> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.Int>", as: Swift.UnsafeMutableBufferPointer<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let buffer: Swift.UnsafeMutableBufferPointer<Swift.String> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.String>", as: Swift.UnsafeMutableBufferPointer<Swift.String>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt8_u003E___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.UInt8>", as: Swift.UnsafeMutableBufferPointer<Swift.UInt8>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Foundation_u002E_Data_u003E___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt8_u003E___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (initializing: Swift.UnsafeMutableBufferPointer<Foundation.Data>)",
            "  - Swift.Array<Swift.Bool> (initializing: Swift.UnsafeMutableBufferPointer<Swift.Bool>)",
            "  - Swift.Array<Swift.Double> (initializing: Swift.UnsafeMutableBufferPointer<Swift.Double>)",
            "  - Swift.Array<Swift.Int> (initializing: Swift.UnsafeMutableBufferPointer<Swift.Int>)",
            "  - Swift.Array<Swift.String> (initializing: Swift.UnsafeMutableBufferPointer<Swift.String>)",
            "  - Swift.Array<Swift.UInt8> (initializing: Swift.UnsafeMutableBufferPointer<Swift.UInt8>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._copyContents(initializing:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Foundation_u002E_Data_u003E___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt8_u003E___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._copyContents(initializing:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._copyToContiguousArray() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___copyToContiguousArray_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._copyToContiguousArray()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let element: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let element = try args[1].expectBool("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let element = try args[1].expectDouble("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let element = try args[1].expectInt("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let element = try args[1].expectString("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let element: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Array<Foundation.Data>.Element)",
            "  - Swift.Array<Swift.Bool> (Swift.Array<Swift.Bool>.Element)",
            "  - Swift.Array<Swift.Double> (Swift.Array<Swift.Double>.Element)",
            "  - Swift.Array<Swift.Int> (Swift.Array<Swift.Int>.Element)",
            "  - Swift.Array<Swift.String> (Swift.Array<Swift.String>.Element)",
            "  - Swift.Array<Swift.UInt8> (Swift.Array<Swift.UInt8>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._customContainsEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._customContainsEquatableElement(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let element: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Foundation.Data>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let element = try args[1].expectBool("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Bool>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let element = try args[1].expectDouble("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Double>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let element = try args[1].expectInt("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Int>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let element = try args[1].expectString("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.String>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let element: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Array<Foundation.Data>.Element)",
            "  - Swift.Array<Swift.Bool> (Swift.Array<Swift.Bool>.Element)",
            "  - Swift.Array<Swift.Double> (Swift.Array<Swift.Double>.Element)",
            "  - Swift.Array<Swift.Int> (Swift.Array<Swift.Int>.Element)",
            "  - Swift.Array<Swift.String> (Swift.Array<Swift.String>.Element)",
            "  - Swift.Array<Swift.UInt8> (Swift.Array<Swift.UInt8>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._customIndexOfEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._customIndexOfEquatableElement(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let element: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Foundation.Data>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let element = try args[1].expectBool("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Bool>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let element = try args[1].expectDouble("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Double>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let element = try args[1].expectInt("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Int>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let element = try args[1].expectString("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.String>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let element: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Array<Foundation.Data>.Element)",
            "  - Swift.Array<Swift.Bool> (Swift.Array<Swift.Bool>.Element)",
            "  - Swift.Array<Swift.Double> (Swift.Array<Swift.Double>.Element)",
            "  - Swift.Array<Swift.Int> (Swift.Array<Swift.Int>.Element)",
            "  - Swift.Array<Swift.String> (Swift.Array<Swift.String>.Element)",
            "  - Swift.Array<Swift.UInt8> (Swift.Array<Swift.UInt8>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._customLastIndexOfEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._customLastIndexOfEquatableElement(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._customRemoveLast() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let returnHostTypeID_Data = vm.hostTypeID(named: "Data")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        let result = receiver._customRemoveLast()
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Data)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._customRemoveLast() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        let result = receiver._customRemoveLast()
        switch result {
        case .some(let unwrapped):
            return .bool(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._customRemoveLast() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        let result = receiver._customRemoveLast()
        switch result {
        case .some(let unwrapped):
            return .double(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._customRemoveLast() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        let result = receiver._customRemoveLast()
        switch result {
        case .some(let unwrapped):
            return .int(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._customRemoveLast() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        let result = receiver._customRemoveLast()
        switch result {
        case .some(let unwrapped):
            return .string(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._customRemoveLast() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let returnHostTypeID_UInt8 = vm.hostTypeID(named: "UInt8")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        let result = receiver._customRemoveLast()
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_UInt8)
        case .none:
            return .nilValue
        }
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._customRemoveLast() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._customRemoveLast()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customRemoveLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let n = try args[1].expectInt("n")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        let result = receiver._customRemoveLast(n)
        return .bool(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customRemoveLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let n = try args[1].expectInt("n")
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        let result = receiver._customRemoveLast(n)
        return .bool(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customRemoveLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let n = try args[1].expectInt("n")
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        let result = receiver._customRemoveLast(n)
        return .bool(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customRemoveLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let n = try args[1].expectInt("n")
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        let result = receiver._customRemoveLast(n)
        return .bool(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customRemoveLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let n = try args[1].expectInt("n")
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        let result = receiver._customRemoveLast(n)
        return .bool(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._customRemoveLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let n = try args[1].expectInt("n")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        let result = receiver._customRemoveLast(n)
        return .bool(result)
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._customRemoveLast(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._customRemoveLast(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let index = try args[1].expectInt("index")
    let bounds: Swift.Range<Swift.Int> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let index = try args[1].expectInt("index")
    let bounds: Swift.Range<Swift.Int> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let index = try args[1].expectInt("index")
    let bounds: Swift.Range<Swift.Int> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let index = try args[1].expectInt("index")
    let bounds: Swift.Range<Swift.Int> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let index = try args[1].expectInt("index")
    let bounds: Swift.Range<Swift.Int> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let index = try args[1].expectInt("index")
    let bounds: Swift.Range<Swift.Int> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int, bounds: Swift.Range<Swift.Int>)",
            "  - Swift.Array<Swift.Bool> (Swift.Int, bounds: Swift.Range<Swift.Int>)",
            "  - Swift.Array<Swift.Double> (Swift.Int, bounds: Swift.Range<Swift.Int>)",
            "  - Swift.Array<Swift.Int> (Swift.Int, bounds: Swift.Range<Swift.Int>)",
            "  - Swift.Array<Swift.String> (Swift.Int, bounds: Swift.Range<Swift.Int>)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int, bounds: Swift.Range<Swift.Int>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._failEarlyRangeCheck(_:bounds:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Int__Swift_u002E_Range_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._failEarlyRangeCheck(_:bounds:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let matchingSubscriptCheck: Swift._DependenceToken = try vm.withHost(args[3], typeName: "Swift._DependenceToken", as: Swift._DependenceToken.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._getElement(index, wasNativeTypeChecked: wasNativeTypeChecked, matchingSubscriptCheck: matchingSubscriptCheck)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let matchingSubscriptCheck: Swift._DependenceToken = try vm.withHost(args[3], typeName: "Swift._DependenceToken", as: Swift._DependenceToken.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._getElement(index, wasNativeTypeChecked: wasNativeTypeChecked, matchingSubscriptCheck: matchingSubscriptCheck)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let matchingSubscriptCheck: Swift._DependenceToken = try vm.withHost(args[3], typeName: "Swift._DependenceToken", as: Swift._DependenceToken.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._getElement(index, wasNativeTypeChecked: wasNativeTypeChecked, matchingSubscriptCheck: matchingSubscriptCheck)
    return .double(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let matchingSubscriptCheck: Swift._DependenceToken = try vm.withHost(args[3], typeName: "Swift._DependenceToken", as: Swift._DependenceToken.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._getElement(index, wasNativeTypeChecked: wasNativeTypeChecked, matchingSubscriptCheck: matchingSubscriptCheck)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let matchingSubscriptCheck: Swift._DependenceToken = try vm.withHost(args[3], typeName: "Swift._DependenceToken", as: Swift._DependenceToken.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._getElement(index, wasNativeTypeChecked: wasNativeTypeChecked, matchingSubscriptCheck: matchingSubscriptCheck)
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let index = try args[1].expectInt("index")
    let wasNativeTypeChecked = try args[2].expectBool("wasNativeTypeChecked")
    let matchingSubscriptCheck: Swift._DependenceToken = try vm.withHost(args[3], typeName: "Swift._DependenceToken", as: Swift._DependenceToken.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._getElement(index, wasNativeTypeChecked: wasNativeTypeChecked, matchingSubscriptCheck: matchingSubscriptCheck)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken)",
            "  - Swift.Array<Swift.Bool> (Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken)",
            "  - Swift.Array<Swift.Double> (Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken)",
            "  - Swift.Array<Swift.Int> (Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken)",
            "  - Swift.Array<Swift.String> (Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int, wasNativeTypeChecked: Swift.Bool, matchingSubscriptCheck: Swift._DependenceToken)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___getElement_u0028___u003A_wasNativeTypeChecked_u003A_matchingSubscriptCheck_u003A__u0029___Swift_u002E_Int__Swift_u002E_Bool__Swift_u002E__DependenceToken__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._hoistableIsNativeTypeChecked() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._hoistableIsNativeTypeChecked()
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._hoistableIsNativeTypeChecked() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._hoistableIsNativeTypeChecked()
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._hoistableIsNativeTypeChecked() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._hoistableIsNativeTypeChecked()
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._hoistableIsNativeTypeChecked() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._hoistableIsNativeTypeChecked()
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._hoistableIsNativeTypeChecked() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._hoistableIsNativeTypeChecked()
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._hoistableIsNativeTypeChecked() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._hoistableIsNativeTypeChecked()
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._hoistableIsNativeTypeChecked() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___hoistableIsNativeTypeChecked_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._hoistableIsNativeTypeChecked()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (seed: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (seed: Swift.Int)",
            "  - Swift.Array<Swift.Double> (seed: Swift.Int)",
            "  - Swift.Array<Swift.Int> (seed: Swift.Int)",
            "  - Swift.Array<Swift.String> (seed: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (seed: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._rawHashValue(seed:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._rawHashValue(seed:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Foundation_u002E_Data__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.append(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let newElement: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        receiver.append(newElement)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.append(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let newElement = try args[1].expectBool("newElement")
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        receiver.append(newElement)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Double__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.append(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let newElement = try args[1].expectDouble("newElement")
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        receiver.append(newElement)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.append(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let newElement = try args[1].expectInt("newElement")
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        receiver.append(newElement)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_String__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.append(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let newElement = try args[1].expectString("newElement")
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        receiver.append(newElement)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_UInt8__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.append(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let newElement: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        receiver.append(newElement)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Foundation_u002E_Data__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Double__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_String__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_UInt8__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Foundation.Data)",
            "  - Swift.Array<Swift.Bool> (Swift.Bool)",
            "  - Swift.Array<Swift.Double> (Swift.Double)",
            "  - Swift.Array<Swift.Int> (Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.String)",
            "  - Swift.Array<Swift.UInt8> (Swift.UInt8)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.append(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Foundation_u002E_Data__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Double__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_String__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__append_u0028___u003A__u0029___Swift_u002E_UInt8__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.append(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element_u003E___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.applying(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let difference: Swift.CollectionDifference<Foundation.Data> = try vm.withHost(args[1], typeName: "Swift.CollectionDifference<Foundation.Data>", as: Swift.CollectionDifference<Foundation.Data>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.applying(difference)
    switch result {
    case .some(let unwrapped):
        var unwrapped_value_elements: [Value] = []
        unwrapped_value_elements.reserveCapacity(unwrapped.count)
        for unwrapped_value_element in unwrapped {
            unwrapped_value_elements.append(.host(HostRef(box: makeOpaqueBox(unwrapped_value_element)), vm.hostTypeID(named: "Data")))
        }
        let unwrapped_value_arrayBox = ArrBox(unwrapped_value_elements)
        return .array(unwrapped_value_arrayBox)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element_u003E___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.applying(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let difference: Swift.CollectionDifference<Swift.Bool> = try vm.withHost(args[1], typeName: "Swift.CollectionDifference<Swift.Bool>", as: Swift.CollectionDifference<Swift.Bool>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.applying(difference)
    switch result {
    case .some(let unwrapped):
        var unwrapped_value_elements: [Value] = []
        unwrapped_value_elements.reserveCapacity(unwrapped.count)
        for unwrapped_value_element in unwrapped {
            unwrapped_value_elements.append(.bool(unwrapped_value_element))
        }
        let unwrapped_value_arrayBox = ArrBox(unwrapped_value_elements)
        return .array(unwrapped_value_arrayBox)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element_u003E___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.applying(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let difference: Swift.CollectionDifference<Swift.Double> = try vm.withHost(args[1], typeName: "Swift.CollectionDifference<Swift.Double>", as: Swift.CollectionDifference<Swift.Double>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.applying(difference)
    switch result {
    case .some(let unwrapped):
        var unwrapped_value_elements: [Value] = []
        unwrapped_value_elements.reserveCapacity(unwrapped.count)
        for unwrapped_value_element in unwrapped {
            unwrapped_value_elements.append(.double(unwrapped_value_element))
        }
        let unwrapped_value_arrayBox = ArrBox(unwrapped_value_elements)
        return .array(unwrapped_value_arrayBox)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element_u003E___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.applying(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let difference: Swift.CollectionDifference<Swift.Int> = try vm.withHost(args[1], typeName: "Swift.CollectionDifference<Swift.Int>", as: Swift.CollectionDifference<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.applying(difference)
    switch result {
    case .some(let unwrapped):
        var unwrapped_value_elements: [Value] = []
        unwrapped_value_elements.reserveCapacity(unwrapped.count)
        for unwrapped_value_element in unwrapped {
            unwrapped_value_elements.append(.int(unwrapped_value_element))
        }
        let unwrapped_value_arrayBox = ArrBox(unwrapped_value_elements)
        return .array(unwrapped_value_arrayBox)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element_u003E___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.applying(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let difference: Swift.CollectionDifference<Swift.String> = try vm.withHost(args[1], typeName: "Swift.CollectionDifference<Swift.String>", as: Swift.CollectionDifference<Swift.String>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.applying(difference)
    switch result {
    case .some(let unwrapped):
        var unwrapped_value_elements: [Value] = []
        unwrapped_value_elements.reserveCapacity(unwrapped.count)
        for unwrapped_value_element in unwrapped {
            unwrapped_value_elements.append(.string(unwrapped_value_element))
        }
        let unwrapped_value_arrayBox = ArrBox(unwrapped_value_elements)
        return .array(unwrapped_value_arrayBox)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element_u003E___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.applying(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let difference: Swift.CollectionDifference<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.CollectionDifference<Swift.UInt8>", as: Swift.CollectionDifference<Swift.UInt8>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.applying(difference)
    switch result {
    case .some(let unwrapped):
        var unwrapped_value_elements: [Value] = []
        unwrapped_value_elements.reserveCapacity(unwrapped.count)
        for unwrapped_value_element in unwrapped {
            unwrapped_value_elements.append(.host(HostRef(box: makeOpaqueBox(unwrapped_value_element)), vm.hostTypeID(named: "UInt8")))
        }
        let unwrapped_value_arrayBox = ArrBox(unwrapped_value_elements)
        return .array(unwrapped_value_arrayBox)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element_u003E___Element_Foundation_u002E_Data(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element_u003E___Element_Swift_u002E_Bool(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element_u003E___Element_Swift_u002E_Double(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element_u003E___Element_Swift_u002E_Int(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element_u003E___Element_Swift_u002E_String(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element_u003E___Element_Swift_u002E_UInt8(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.CollectionDifference<Swift.Array<Foundation.Data>.Element>)",
            "  - Swift.Array<Swift.Bool> (Swift.CollectionDifference<Swift.Array<Swift.Bool>.Element>)",
            "  - Swift.Array<Swift.Double> (Swift.CollectionDifference<Swift.Array<Swift.Double>.Element>)",
            "  - Swift.Array<Swift.Int> (Swift.CollectionDifference<Swift.Array<Swift.Int>.Element>)",
            "  - Swift.Array<Swift.String> (Swift.CollectionDifference<Swift.Array<Swift.String>.Element>)",
            "  - Swift.Array<Swift.UInt8> (Swift.CollectionDifference<Swift.Array<Swift.UInt8>.Element>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.applying(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Element_u003E___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element_u003E___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element_u003E___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element_u003E___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element_u003E___Element_Swift_u002E_String(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Element_u003E___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.applying(_:) is not available on this platform")
            }
        }
        throw VMError.typeError("Array element type not supported for Array.applying(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) { return try HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Array.applying(_:) is not available on this platform")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(where:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let predicate_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let predicate: (Foundation.Data) throws -> Swift.Bool = try vm.withHostClosureAdapter(predicate_handle) { predicate_adapter in
        return { arg0 in
            let adapterResult = try predicate_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), predicate_adapter.hostTypeID(named: "Data"))])
            let predicate_result = try adapterResult.expectBool("contains result")
            return predicate_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.contains(where: predicate)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(where:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let predicate_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let predicate: (Swift.Bool) throws -> Swift.Bool = try vm.withHostClosureAdapter(predicate_handle) { predicate_adapter in
        return { arg0 in
            let adapterResult = try predicate_adapter.invoke([.bool(arg0)])
            let predicate_result = try adapterResult.expectBool("contains result")
            return predicate_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.contains(where: predicate)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(where:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let predicate_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let predicate: (Swift.Double) throws -> Swift.Bool = try vm.withHostClosureAdapter(predicate_handle) { predicate_adapter in
        return { arg0 in
            let adapterResult = try predicate_adapter.invoke([.double(arg0)])
            let predicate_result = try adapterResult.expectBool("contains result")
            return predicate_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.contains(where: predicate)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(where:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let predicate_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let predicate: (Swift.Int) throws -> Swift.Bool = try vm.withHostClosureAdapter(predicate_handle) { predicate_adapter in
        return { arg0 in
            let adapterResult = try predicate_adapter.invoke([.int(arg0)])
            let predicate_result = try adapterResult.expectBool("contains result")
            return predicate_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.contains(where: predicate)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(where:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let predicate_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let predicate: (Swift.String) throws -> Swift.Bool = try vm.withHostClosureAdapter(predicate_handle) { predicate_adapter in
        return { arg0 in
            let adapterResult = try predicate_adapter.invoke([.string(arg0)])
            let predicate_result = try adapterResult.expectBool("contains result")
            return predicate_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = try receiver.contains(where: predicate)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(where:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let predicate_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let predicate: (Swift.UInt8) throws -> Swift.Bool = try vm.withHostClosureAdapter(predicate_handle) { predicate_adapter in
        return { arg0 in
            let adapterResult = try predicate_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), predicate_adapter.hostTypeID(named: "UInt8"))])
            let predicate_result = try adapterResult.expectBool("contains result")
            return predicate_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.contains(where: predicate)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (where: (Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.Bool> (where: (Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.Double> (where: (Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.Int> (where: (Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.String> (where: (Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.UInt8> (where: (Swift.Array<Element>.Element) throws -> Swift.Bool)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.contains(where:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028_where_u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.contains(where:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let start = try args[1].expectInt("start")
    let end = try args[2].expectInt("end")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let start = try args[1].expectInt("start")
    let end = try args[2].expectInt("end")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let start = try args[1].expectInt("start")
    let end = try args[2].expectInt("end")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let start = try args[1].expectInt("start")
    let end = try args[2].expectInt("end")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let start = try args[1].expectInt("start")
    let end = try args[2].expectInt("end")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let start = try args[1].expectInt("start")
    let end = try args[2].expectInt("end")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (from: Swift.Int, to: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (from: Swift.Int, to: Swift.Int)",
            "  - Swift.Array<Swift.Double> (from: Swift.Int, to: Swift.Int)",
            "  - Swift.Array<Swift.Int> (from: Swift.Int, to: Swift.Int)",
            "  - Swift.Array<Swift.String> (from: Swift.Int, to: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (from: Swift.Int, to: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.distance(from:to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.distance(from:to:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.dropFirst(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.dropFirst(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.dropLast(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.dropLast(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.enumerated() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__enumerated_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.enumerated()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.filter(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let isIncluded_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let isIncluded: (Foundation.Data) throws -> Swift.Bool = try vm.withHostClosureAdapter(isIncluded_handle) { isIncluded_adapter in
        return { arg0 in
            let adapterResult = try isIncluded_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), isIncluded_adapter.hostTypeID(named: "Data"))])
            let isIncluded_result = try adapterResult.expectBool("filter result")
            return isIncluded_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.filter(isIncluded)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.filter(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let isIncluded_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let isIncluded: (Swift.Bool) throws -> Swift.Bool = try vm.withHostClosureAdapter(isIncluded_handle) { isIncluded_adapter in
        return { arg0 in
            let adapterResult = try isIncluded_adapter.invoke([.bool(arg0)])
            let isIncluded_result = try adapterResult.expectBool("filter result")
            return isIncluded_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.filter(isIncluded)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.filter(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let isIncluded_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let isIncluded: (Swift.Double) throws -> Swift.Bool = try vm.withHostClosureAdapter(isIncluded_handle) { isIncluded_adapter in
        return { arg0 in
            let adapterResult = try isIncluded_adapter.invoke([.double(arg0)])
            let isIncluded_result = try adapterResult.expectBool("filter result")
            return isIncluded_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.filter(isIncluded)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.filter(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let isIncluded_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let isIncluded: (Swift.Int) throws -> Swift.Bool = try vm.withHostClosureAdapter(isIncluded_handle) { isIncluded_adapter in
        return { arg0 in
            let adapterResult = try isIncluded_adapter.invoke([.int(arg0)])
            let isIncluded_result = try adapterResult.expectBool("filter result")
            return isIncluded_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.filter(isIncluded)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.filter(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let isIncluded_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let isIncluded: (Swift.String) throws -> Swift.Bool = try vm.withHostClosureAdapter(isIncluded_handle) { isIncluded_adapter in
        return { arg0 in
            let adapterResult = try isIncluded_adapter.invoke([.string(arg0)])
            let isIncluded_result = try adapterResult.expectBool("filter result")
            return isIncluded_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = try receiver.filter(isIncluded)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.filter(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let isIncluded_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let isIncluded: (Swift.UInt8) throws -> Swift.Bool = try vm.withHostClosureAdapter(isIncluded_handle) { isIncluded_adapter in
        return { arg0 in
            let adapterResult = try isIncluded_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), isIncluded_adapter.hostTypeID(named: "UInt8"))])
            let isIncluded_result = try adapterResult.expectBool("filter result")
            return isIncluded_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.filter(isIncluded)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ((Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.Bool> ((Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.Double> ((Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.Int> ((Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.String> ((Swift.Array<Element>.Element) throws -> Swift.Bool)",
            "  - Swift.Array<Swift.UInt8> ((Swift.Array<Element>.Element) throws -> Swift.Bool)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.filter(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__filter_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.filter(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    receiver.formIndex(after: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    receiver.formIndex(after: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    receiver.formIndex(after: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    receiver.formIndex(after: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    receiver.formIndex(after: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    receiver.formIndex(after: &i)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (after: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (after: Swift.Int)",
            "  - Swift.Array<Swift.Double> (after: Swift.Int)",
            "  - Swift.Array<Swift.Int> (after: Swift.Int)",
            "  - Swift.Array<Swift.String> (after: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (after: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.formIndex(after:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.formIndex(after:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    receiver.formIndex(before: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    receiver.formIndex(before: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    receiver.formIndex(before: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    receiver.formIndex(before: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    receiver.formIndex(before: &i)
    return .bool(true)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.formIndex(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    var i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    receiver.formIndex(before: &i)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (before: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (before: Swift.Int)",
            "  - Swift.Array<Swift.Double> (before: Swift.Int)",
            "  - Swift.Array<Swift.Int> (before: Swift.Int)",
            "  - Swift.Array<Swift.String> (before: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (before: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.formIndex(before:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__formIndex_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.formIndex(before:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int, offsetBy: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int, offsetBy: Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int, offsetBy: Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int, offsetBy: Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int, offsetBy: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int, offsetBy: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.index(_:offsetBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.index(_:offsetBy:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let limit = try args[3].expectInt("limit")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let limit = try args[3].expectInt("limit")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let limit = try args[3].expectInt("limit")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let limit = try args[3].expectInt("limit")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let limit = try args[3].expectInt("limit")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let i = try args[1].expectInt("i")
    let distance = try args[2].expectInt("distance")
    let limit = try args[3].expectInt("limit")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int, offsetBy: Swift.Int, limitedBy: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int, offsetBy: Swift.Int, limitedBy: Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int, offsetBy: Swift.Int, limitedBy: Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int, offsetBy: Swift.Int, limitedBy: Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int, offsetBy: Swift.Int, limitedBy: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int, offsetBy: Swift.Int, limitedBy: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.index(_:offsetBy:limitedBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.index(_:offsetBy:limitedBy:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (after: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (after: Swift.Int)",
            "  - Swift.Array<Swift.Double> (after: Swift.Int)",
            "  - Swift.Array<Swift.Int> (after: Swift.Int)",
            "  - Swift.Array<Swift.String> (after: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (after: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.index(after:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.index(after:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.index(before: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(before: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(before: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(before: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.index(before: i)
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let i = try args[1].expectInt("i")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.index(before: i)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (before: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (before: Swift.Int)",
            "  - Swift.Array<Swift.Double> (before: Swift.Int)",
            "  - Swift.Array<Swift.Int> (before: Swift.Int)",
            "  - Swift.Array<Swift.String> (before: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (before: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.index(before:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_before_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.index(before:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> metatype") }
    let result = Swift.Array<Foundation.Data>()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> metatype") }
    let result = Swift.Array<Swift.Bool>()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> metatype") }
    let result = Swift.Array<Swift.Double>()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> metatype") }
    let result = Swift.Array<Swift.Int>()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> metatype") }
    let result = Swift.Array<Swift.String>()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> metatype") }
    let result = Swift.Array<Swift.UInt8>()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Array<Foundation.Data> ()",
        "  - Swift.Array<Swift.Bool> ()",
        "  - Swift.Array<Swift.Double> ()",
        "  - Swift.Array<Swift.Int> ()",
        "  - Swift.Array<Swift.String> ()",
        "  - Swift.Array<Swift.UInt8> ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Array.init() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Foundation_u002E_Data__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.init(repeating:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> metatype") }
    let repeatedValue: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let count = try args[2].expectInt("count")
    let result = Swift.Array<Foundation.Data>(repeating: repeatedValue, count: count)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_Bool__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.init(repeating:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> metatype") }
    let repeatedValue = try args[1].expectBool("repeatedValue")
    let count = try args[2].expectInt("count")
    let result = Swift.Array<Swift.Bool>(repeating: repeatedValue, count: count)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_Double__Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.init(repeating:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> metatype") }
    let repeatedValue = try args[1].expectDouble("repeatedValue")
    let count = try args[2].expectInt("count")
    let result = Swift.Array<Swift.Double>(repeating: repeatedValue, count: count)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.init(repeating:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> metatype") }
    let repeatedValue = try args[1].expectInt("repeatedValue")
    let count = try args[2].expectInt("count")
    let result = Swift.Array<Swift.Int>(repeating: repeatedValue, count: count)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_String__Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.init(repeating:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> metatype") }
    let repeatedValue = try args[1].expectString("repeatedValue")
    let count = try args[2].expectInt("count")
    let result = Swift.Array<Swift.String>(repeating: repeatedValue, count: count)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.init(repeating:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> metatype") }
    let repeatedValue: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    let count = try args[2].expectInt("count")
    let result = Swift.Array<Swift.UInt8>(repeating: repeatedValue, count: count)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Element__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Foundation_u002E_Data__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_Bool__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_Double__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_String__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E__init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Array<Foundation.Data> (repeating: Foundation.Data, count: Swift.Int)",
        "  - Swift.Array<Swift.Bool> (repeating: Swift.Bool, count: Swift.Int)",
        "  - Swift.Array<Swift.Double> (repeating: Swift.Double, count: Swift.Int)",
        "  - Swift.Array<Swift.Int> (repeating: Swift.Int, count: Swift.Int)",
        "  - Swift.Array<Swift.String> (repeating: Swift.String, count: Swift.Int)",
        "  - Swift.Array<Swift.UInt8> (repeating: Swift.UInt8, count: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Array.init(repeating:count:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Foundation_u002E_Data__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.insert(_:at:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let newElement: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let i = try args[2].expectInt("i")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        receiver.insert(newElement, at: i)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Bool__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.insert(_:at:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let newElement = try args[1].expectBool("newElement")
    let i = try args[2].expectInt("i")
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        receiver.insert(newElement, at: i)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Double__Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.insert(_:at:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let newElement = try args[1].expectDouble("newElement")
    let i = try args[2].expectInt("i")
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        receiver.insert(newElement, at: i)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.insert(_:at:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let newElement = try args[1].expectInt("newElement")
    let i = try args[2].expectInt("i")
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        receiver.insert(newElement, at: i)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_String__Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.insert(_:at:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let newElement = try args[1].expectString("newElement")
    let i = try args[2].expectInt("i")
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        receiver.insert(newElement, at: i)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.insert(_:at:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let newElement: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    let i = try args[2].expectInt("i")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        receiver.insert(newElement, at: i)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Element__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Foundation_u002E_Data__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Bool__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Double__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_String__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Foundation.Data, at: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Bool, at: Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Double, at: Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int, at: Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.String, at: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.UInt8, at: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.insert(_:at:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Foundation_u002E_Data__Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Bool__Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Double__Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_String__Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__insert_u0028___u003A_at_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.insert(_:at:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.makeIterator() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__makeIterator_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.makeIterator()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Foundation.Data> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Foundation.Data> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Foundation.Data> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Foundation.Data> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Foundation.Data> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Bool> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Bool> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Bool> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Bool> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Bool> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Bool> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Double> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Double> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Double> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Double> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Double> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Double> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Int> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Int> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Int> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Int> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Int> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.Int> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.String> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.String> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.String> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.String> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.String> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.String> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.UInt8> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.UInt8> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.UInt8> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.UInt8> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.UInt8> ((Swift.Array<Element>.Element) throws -> T)",
            "  - Swift.Array<Swift.UInt8> ((Swift.Array<Element>.Element) throws -> T)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.map(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if closureReturnType == "Foundation.Data" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Bool" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Double" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Int" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.String" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.UInt8" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            }
            else {
                let supported = ["Foundation.Data", "Swift.Bool", "Swift.Double", "Swift.Int", "Swift.String", "Swift.UInt8"].map { "    - \($0)" }.joined(separator: "\n")
                throw VMError.typeError("Closure return type '\(closureReturnType ?? "nil")' not supported for Array.map(_:). Supported return types:\n\(supported)")
            }
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if closureReturnType == "Foundation.Data" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Bool" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Double" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Int" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.String" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.UInt8" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            }
            else {
                let supported = ["Foundation.Data", "Swift.Bool", "Swift.Double", "Swift.Int", "Swift.String", "Swift.UInt8"].map { "    - \($0)" }.joined(separator: "\n")
                throw VMError.typeError("Closure return type '\(closureReturnType ?? "nil")' not supported for Array.map(_:). Supported return types:\n\(supported)")
            }
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if closureReturnType == "Foundation.Data" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Bool" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Double" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Int" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.String" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.UInt8" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            }
            else {
                let supported = ["Foundation.Data", "Swift.Bool", "Swift.Double", "Swift.Int", "Swift.String", "Swift.UInt8"].map { "    - \($0)" }.joined(separator: "\n")
                throw VMError.typeError("Closure return type '\(closureReturnType ?? "nil")' not supported for Array.map(_:). Supported return types:\n\(supported)")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if closureReturnType == "Foundation.Data" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Bool" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Double" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Int" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.String" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.UInt8" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            }
            else {
                let supported = ["Foundation.Data", "Swift.Bool", "Swift.Double", "Swift.Int", "Swift.String", "Swift.UInt8"].map { "    - \($0)" }.joined(separator: "\n")
                throw VMError.typeError("Closure return type '\(closureReturnType ?? "nil")' not supported for Array.map(_:). Supported return types:\n\(supported)")
            }
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if closureReturnType == "Foundation.Data" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Bool" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Double" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Int" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.String" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.UInt8" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_String(vm: &vm, convertedArgs)
            }
            else {
                let supported = ["Foundation.Data", "Swift.Bool", "Swift.Double", "Swift.Int", "Swift.String", "Swift.UInt8"].map { "    - \($0)" }.joined(separator: "\n")
                throw VMError.typeError("Closure return type '\(closureReturnType ?? "nil")' not supported for Array.map(_:). Supported return types:\n\(supported)")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if closureReturnType == "Foundation.Data" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Foundation_u002E_Data__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Bool" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Bool__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Double" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Double__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.Int" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_Int__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.String" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_String__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            }
            else if closureReturnType == "Swift.UInt8" {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__map_u0028___u003A__u0029____u0028_Swift_u002E_Array_u003C_Element_u003E__u002E_Element_u0029__u0020_throws_u0020__u002D__u003E__u0020_T__T_Swift_u002E_UInt8__E_Swift_u002E_Never__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            }
            else {
                let supported = ["Foundation.Data", "Swift.Bool", "Swift.Double", "Swift.Int", "Swift.String", "Swift.UInt8"].map { "    - \($0)" }.joined(separator: "\n")
                throw VMError.typeError("Closure return type '\(closureReturnType ?? "nil")' not supported for Array.map(_:). Supported return types:\n\(supported)")
            }
        }
        throw VMError.typeError("Array element type not supported for Array.map(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.moveSubranges(_:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let subranges: Swift.RangeSet<Swift.Array<Foundation.Data>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Foundation.Data>.Index>", as: Swift.RangeSet<Swift.Array<Foundation.Data>.Index>.self) { host in
        host
    }
    let insertionPoint: Swift.Array<Foundation.Data>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Foundation.Data>.Index", as: Swift.Array<Foundation.Data>.Index.self) { host in
        host
    }
    let returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E_ = vm.hostTypeID(named: "Range<Swift.Array<Foundation.Data>.Index>")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        let result = receiver.moveSubranges(subranges, to: insertionPoint)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E_)
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.moveSubranges(_:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.Bool>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.Bool>.Index>", as: Swift.RangeSet<Swift.Array<Swift.Bool>.Index>.self) { host in
        host
    }
    let insertionPoint: Swift.Array<Swift.Bool>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.Bool>.Index", as: Swift.Array<Swift.Bool>.Index.self) { host in
        host
    }
    let returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E_ = vm.hostTypeID(named: "Range<Swift.Array<Swift.Bool>.Index>")
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        let result = receiver.moveSubranges(subranges, to: insertionPoint)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E_)
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.moveSubranges(_:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.Double>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.Double>.Index>", as: Swift.RangeSet<Swift.Array<Swift.Double>.Index>.self) { host in
        host
    }
    let insertionPoint: Swift.Array<Swift.Double>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.Double>.Index", as: Swift.Array<Swift.Double>.Index.self) { host in
        host
    }
    let returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E_ = vm.hostTypeID(named: "Range<Swift.Array<Swift.Double>.Index>")
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        let result = receiver.moveSubranges(subranges, to: insertionPoint)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E_)
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.moveSubranges(_:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.Int>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.Int>.Index>", as: Swift.RangeSet<Swift.Array<Swift.Int>.Index>.self) { host in
        host
    }
    let insertionPoint: Swift.Array<Swift.Int>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.Int>.Index", as: Swift.Array<Swift.Int>.Index.self) { host in
        host
    }
    let returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E_ = vm.hostTypeID(named: "Range<Swift.Array<Swift.Int>.Index>")
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        let result = receiver.moveSubranges(subranges, to: insertionPoint)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E_)
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.moveSubranges(_:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.String>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.String>.Index>", as: Swift.RangeSet<Swift.Array<Swift.String>.Index>.self) { host in
        host
    }
    let insertionPoint: Swift.Array<Swift.String>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.String>.Index", as: Swift.Array<Swift.String>.Index.self) { host in
        host
    }
    let returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E_ = vm.hostTypeID(named: "Range<Swift.Array<Swift.String>.Index>")
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        let result = receiver.moveSubranges(subranges, to: insertionPoint)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E_)
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.moveSubranges(_:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.UInt8>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.UInt8>.Index>", as: Swift.RangeSet<Swift.Array<Swift.UInt8>.Index>.self) { host in
        host
    }
    let insertionPoint: Swift.Array<Swift.UInt8>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.UInt8>.Index", as: Swift.Array<Swift.UInt8>.Index.self) { host in
        host
    }
    let returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E_ = vm.hostTypeID(named: "Range<Swift.Array<Swift.UInt8>.Index>")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        let result = receiver.moveSubranges(subranges, to: insertionPoint)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E_)
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Element_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.RangeSet<Swift.Array<Foundation.Data>.Index>, to: Swift.Array<Foundation.Data>.Index)",
            "  - Swift.Array<Swift.Bool> (Swift.RangeSet<Swift.Array<Swift.Bool>.Index>, to: Swift.Array<Swift.Bool>.Index)",
            "  - Swift.Array<Swift.Double> (Swift.RangeSet<Swift.Array<Swift.Double>.Index>, to: Swift.Array<Swift.Double>.Index)",
            "  - Swift.Array<Swift.Int> (Swift.RangeSet<Swift.Array<Swift.Int>.Index>, to: Swift.Array<Swift.Int>.Index)",
            "  - Swift.Array<Swift.String> (Swift.RangeSet<Swift.Array<Swift.String>.Index>, to: Swift.Array<Swift.String>.Index)",
            "  - Swift.Array<Swift.UInt8> (Swift.RangeSet<Swift.Array<Swift.UInt8>.Index>, to: Swift.Array<Swift.UInt8>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.moveSubranges(_:to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
            }
        }
        throw VMError.typeError("Array element type not supported for Array.moveSubranges(_:to:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Element_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) { return try HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__moveSubranges_u0028___u003A_to_u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Index_u003E___Swift_u002E_Array_u003C_Element_u003E__u002E_Index(vm: &vm, args) }
    throw VMError.unsupported("Array.moveSubranges(_:to:) is not available on this platform")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.prefix(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.prefix(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let position: Swift.Array<Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Foundation.Data>.Index", as: Swift.Array<Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let position: Swift.Array<Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Bool>.Index", as: Swift.Array<Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let position: Swift.Array<Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Double>.Index", as: Swift.Array<Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let position: Swift.Array<Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Int>.Index", as: Swift.Array<Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let position: Swift.Array<Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.String>.Index", as: Swift.Array<Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let position: Swift.Array<Swift.UInt8>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.UInt8>.Index", as: Swift.Array<Swift.UInt8>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (through: Swift.Array<Foundation.Data>.Index)",
            "  - Swift.Array<Swift.Bool> (through: Swift.Array<Swift.Bool>.Index)",
            "  - Swift.Array<Swift.Double> (through: Swift.Array<Swift.Double>.Index)",
            "  - Swift.Array<Swift.Int> (through: Swift.Array<Swift.Int>.Index)",
            "  - Swift.Array<Swift.String> (through: Swift.Array<Swift.String>.Index)",
            "  - Swift.Array<Swift.UInt8> (through: Swift.Array<Swift.UInt8>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.prefix(through:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.prefix(through:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let end: Swift.Array<Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Foundation.Data>.Index", as: Swift.Array<Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let end: Swift.Array<Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Bool>.Index", as: Swift.Array<Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let end: Swift.Array<Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Double>.Index", as: Swift.Array<Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let end: Swift.Array<Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Int>.Index", as: Swift.Array<Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let end: Swift.Array<Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.String>.Index", as: Swift.Array<Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let end: Swift.Array<Swift.UInt8>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.UInt8>.Index", as: Swift.Array<Swift.UInt8>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (upTo: Swift.Array<Foundation.Data>.Index)",
            "  - Swift.Array<Swift.Bool> (upTo: Swift.Array<Swift.Bool>.Index)",
            "  - Swift.Array<Swift.Double> (upTo: Swift.Array<Swift.Double>.Index)",
            "  - Swift.Array<Swift.Int> (upTo: Swift.Array<Swift.Int>.Index)",
            "  - Swift.Array<Swift.String> (upTo: Swift.Array<Swift.String>.Index)",
            "  - Swift.Array<Swift.UInt8> (upTo: Swift.Array<Swift.UInt8>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.prefix(upTo:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.prefix(upTo:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.randomElement() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__randomElement_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.randomElement()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let index = try args[1].expectInt("index")
    let returnHostTypeID_Data = vm.hostTypeID(named: "Data")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        let result = receiver.remove(at: index)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Data)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let index = try args[1].expectInt("index")
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        let result = receiver.remove(at: index)
        return .bool(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let index = try args[1].expectInt("index")
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        let result = receiver.remove(at: index)
        return .double(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let index = try args[1].expectInt("index")
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        let result = receiver.remove(at: index)
        return .int(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let index = try args[1].expectInt("index")
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        let result = receiver.remove(at: index)
        return .string(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let index = try args[1].expectInt("index")
    let returnHostTypeID_UInt8 = vm.hostTypeID(named: "UInt8")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        let result = receiver.remove(at: index)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_UInt8)
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (at: Swift.Int)",
            "  - Swift.Array<Swift.Bool> (at: Swift.Int)",
            "  - Swift.Array<Swift.Double> (at: Swift.Int)",
            "  - Swift.Array<Swift.Int> (at: Swift.Int)",
            "  - Swift.Array<Swift.String> (at: Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (at: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.remove(at:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.remove(at:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (keepingCapacity: Swift.Bool)",
            "  - Swift.Array<Swift.Bool> (keepingCapacity: Swift.Bool)",
            "  - Swift.Array<Swift.Double> (keepingCapacity: Swift.Bool)",
            "  - Swift.Array<Swift.Int> (keepingCapacity: Swift.Bool)",
            "  - Swift.Array<Swift.String> (keepingCapacity: Swift.Bool)",
            "  - Swift.Array<Swift.UInt8> (keepingCapacity: Swift.Bool)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.removeAll(keepingCapacity:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.removeAll(keepingCapacity:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.removeFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let returnHostTypeID_Data = vm.hostTypeID(named: "Data")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        let result = receiver.removeFirst()
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Data)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.removeFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        let result = receiver.removeFirst()
        return .bool(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.removeFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        let result = receiver.removeFirst()
        return .double(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.removeFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        let result = receiver.removeFirst()
        return .int(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.removeFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        let result = receiver.removeFirst()
        return .string(result)
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.removeFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let returnHostTypeID_UInt8 = vm.hostTypeID(named: "UInt8")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        let result = receiver.removeFirst()
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_UInt8)
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.removeFirst() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.removeFirst()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let k = try args[1].expectInt("k")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        receiver.removeFirst(k)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let k = try args[1].expectInt("k")
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        receiver.removeFirst(k)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let k = try args[1].expectInt("k")
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        receiver.removeFirst(k)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let k = try args[1].expectInt("k")
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        receiver.removeFirst(k)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let k = try args[1].expectInt("k")
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        receiver.removeFirst(k)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let k = try args[1].expectInt("k")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        receiver.removeFirst(k)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.removeFirst(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeFirst_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.removeFirst(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeSubrange(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let bounds: Swift.Range<Swift.Array<Foundation.Data>.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.Array<Foundation.Data>.Index>", as: Swift.Range<Swift.Array<Foundation.Data>.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        receiver.removeSubrange(bounds)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeSubrange(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let bounds: Swift.Range<Swift.Array<Swift.Bool>.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.Array<Swift.Bool>.Index>", as: Swift.Range<Swift.Array<Swift.Bool>.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        receiver.removeSubrange(bounds)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeSubrange(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let bounds: Swift.Range<Swift.Array<Swift.Double>.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.Array<Swift.Double>.Index>", as: Swift.Range<Swift.Array<Swift.Double>.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        receiver.removeSubrange(bounds)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeSubrange(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let bounds: Swift.Range<Swift.Array<Swift.Int>.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.Array<Swift.Int>.Index>", as: Swift.Range<Swift.Array<Swift.Int>.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        receiver.removeSubrange(bounds)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeSubrange(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let bounds: Swift.Range<Swift.Array<Swift.String>.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.Array<Swift.String>.Index>", as: Swift.Range<Swift.Array<Swift.String>.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        receiver.removeSubrange(bounds)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removeSubrange(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let bounds: Swift.Range<Swift.Array<Swift.UInt8>.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.Array<Swift.UInt8>.Index>", as: Swift.Range<Swift.Array<Swift.UInt8>.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        receiver.removeSubrange(bounds)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Range<Swift.Array<Foundation.Data>.Index>)",
            "  - Swift.Array<Swift.Bool> (Swift.Range<Swift.Array<Swift.Bool>.Index>)",
            "  - Swift.Array<Swift.Double> (Swift.Range<Swift.Array<Swift.Double>.Index>)",
            "  - Swift.Array<Swift.Int> (Swift.Range<Swift.Array<Swift.Int>.Index>)",
            "  - Swift.Array<Swift.String> (Swift.Range<Swift.Array<Swift.String>.Index>)",
            "  - Swift.Array<Swift.UInt8> (Swift.Range<Swift.Array<Swift.UInt8>.Index>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.removeSubrange(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.removeSubrange(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let subranges: Swift.RangeSet<Swift.Array<Foundation.Data>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Foundation.Data>.Index>", as: Swift.RangeSet<Swift.Array<Foundation.Data>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.Bool>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.Bool>.Index>", as: Swift.RangeSet<Swift.Array<Swift.Bool>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.Double>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.Double>.Index>", as: Swift.RangeSet<Swift.Array<Swift.Double>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.Int>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.Int>.Index>", as: Swift.RangeSet<Swift.Array<Swift.Int>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.String>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.String>.Index>", as: Swift.RangeSet<Swift.Array<Swift.String>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let subranges: Swift.RangeSet<Swift.Array<Swift.UInt8>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Array<Swift.UInt8>.Index>", as: Swift.RangeSet<Swift.Array<Swift.UInt8>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Element_Foundation_u002E_Data(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Element_Swift_u002E_Bool(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Element_Swift_u002E_Double(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Element_Swift_u002E_Int(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Element_Swift_u002E_String(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Element_Swift_u002E_UInt8(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.RangeSet<Swift.Array<Foundation.Data>.Index>)",
            "  - Swift.Array<Swift.Bool> (Swift.RangeSet<Swift.Array<Swift.Bool>.Index>)",
            "  - Swift.Array<Swift.Double> (Swift.RangeSet<Swift.Array<Swift.Double>.Index>)",
            "  - Swift.Array<Swift.Int> (Swift.RangeSet<Swift.Array<Swift.Int>.Index>)",
            "  - Swift.Array<Swift.String> (Swift.RangeSet<Swift.Array<Swift.String>.Index>)",
            "  - Swift.Array<Swift.UInt8> (Swift.RangeSet<Swift.Array<Swift.UInt8>.Index>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.removingSubranges(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index_u003E___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index_u003E___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index_u003E___Element_Swift_u002E_String(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index_u003E___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
            }
        }
        throw VMError.typeError("Array element type not supported for Array.removingSubranges(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) { return try HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Array_u003C_Element_u003E__u002E_Index_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Array.removingSubranges(_:) is not available on this platform")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.reserveCapacity(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.reserveCapacity(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.reversed()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.reversed()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.reversed()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.reversed()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.reversed()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.reversed()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.reversed() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__reversed_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.reversed()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Data")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.bool(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.double(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> ()",
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
            "  - Swift.Array<Swift.UInt8> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.shuffled() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__shuffled_u0028__u0029___Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.shuffled()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Int)",
            "  - Swift.Array<Swift.Bool> (Swift.Int)",
            "  - Swift.Array<Swift.Double> (Swift.Int)",
            "  - Swift.Array<Swift.Int> (Swift.Int)",
            "  - Swift.Array<Swift.String> (Swift.Int)",
            "  - Swift.Array<Swift.UInt8> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.suffix(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.suffix(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let start: Swift.Array<Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Foundation.Data>.Index", as: Swift.Array<Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let start: Swift.Array<Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Bool>.Index", as: Swift.Array<Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let start: Swift.Array<Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Double>.Index", as: Swift.Array<Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let start: Swift.Array<Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Int>.Index", as: Swift.Array<Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let start: Swift.Array<Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.String>.Index", as: Swift.Array<Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let start: Swift.Array<Swift.UInt8>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.UInt8>.Index", as: Swift.Array<Swift.UInt8>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (from: Swift.Array<Foundation.Data>.Index)",
            "  - Swift.Array<Swift.Bool> (from: Swift.Array<Swift.Bool>.Index)",
            "  - Swift.Array<Swift.Double> (from: Swift.Array<Swift.Double>.Index)",
            "  - Swift.Array<Swift.Int> (from: Swift.Array<Swift.Int>.Index)",
            "  - Swift.Array<Swift.String> (from: Swift.Array<Swift.String>.Index)",
            "  - Swift.Array<Swift.UInt8> (from: Swift.Array<Swift.UInt8>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.suffix(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.suffix(from:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.swapAt(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let i: Swift.Array<Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Foundation.Data>.Index", as: Swift.Array<Foundation.Data>.Index.self) { host in
        host
    }
    let j: Swift.Array<Foundation.Data>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Foundation.Data>.Index", as: Swift.Array<Foundation.Data>.Index.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { receiver in
        receiver.swapAt(i, j)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.swapAt(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let i: Swift.Array<Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Bool>.Index", as: Swift.Array<Swift.Bool>.Index.self) { host in
        host
    }
    let j: Swift.Array<Swift.Bool>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.Bool>.Index", as: Swift.Array<Swift.Bool>.Index.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { receiver in
        receiver.swapAt(i, j)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.swapAt(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let i: Swift.Array<Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Double>.Index", as: Swift.Array<Swift.Double>.Index.self) { host in
        host
    }
    let j: Swift.Array<Swift.Double>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.Double>.Index", as: Swift.Array<Swift.Double>.Index.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { receiver in
        receiver.swapAt(i, j)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.swapAt(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let i: Swift.Array<Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.Int>.Index", as: Swift.Array<Swift.Int>.Index.self) { host in
        host
    }
    let j: Swift.Array<Swift.Int>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.Int>.Index", as: Swift.Array<Swift.Int>.Index.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { receiver in
        receiver.swapAt(i, j)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.swapAt(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let i: Swift.Array<Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.String>.Index", as: Swift.Array<Swift.String>.Index.self) { host in
        host
    }
    let j: Swift.Array<Swift.String>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.String>.Index", as: Swift.Array<Swift.String>.Index.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { receiver in
        receiver.swapAt(i, j)
        return args[0]
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.swapAt(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let i: Swift.Array<Swift.UInt8>.Index = try vm.withHost(args[1], typeName: "Swift.Array<Swift.UInt8>.Index", as: Swift.Array<Swift.UInt8>.Index.self) { host in
        host
    }
    let j: Swift.Array<Swift.UInt8>.Index = try vm.withHost(args[2], typeName: "Swift.Array<Swift.UInt8>.Index", as: Swift.Array<Swift.UInt8>.Index.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { receiver in
        receiver.swapAt(i, j)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Index__Swift_u002E_Array_u003C_Element_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Foundation.Data>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.UInt8>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Foundation.Data> (Swift.Array<Foundation.Data>.Index, Swift.Array<Foundation.Data>.Index)",
            "  - Swift.Array<Swift.Bool> (Swift.Array<Swift.Bool>.Index, Swift.Array<Swift.Bool>.Index)",
            "  - Swift.Array<Swift.Double> (Swift.Array<Swift.Double>.Index, Swift.Array<Swift.Double>.Index)",
            "  - Swift.Array<Swift.Int> (Swift.Array<Swift.Int>.Index, Swift.Array<Swift.Int>.Index)",
            "  - Swift.Array<Swift.String> (Swift.Array<Swift.String>.Index, Swift.Array<Swift.String>.Index)",
            "  - Swift.Array<Swift.UInt8> (Swift.Array<Swift.UInt8>.Index, Swift.Array<Swift.UInt8>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.swapAt(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case let .host(_, tid) = sampleElement, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM array to host array of Foundation.Data inline
            var hostElements: [Foundation.Data] = []
            for element in box.elements {
                guard case let .host(ref, _) = element else { throw VMError.typeError("Array element is not a host value") }
                guard let typedValue = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostElements.append(typedValue)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__u002E_Index__Element_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Index__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Index__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Index__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Index__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.UInt8 inline
            var hostElements: [UInt8] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not UInt8 (Int)") }
                hostElements.append(UInt8(i))
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__swapAt_u0028___u003A___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__u002E_Index__Element_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.swapAt(_:_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___baseAddressIfContiguous_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>._baseAddressIfContiguous expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._baseAddressIfContiguous
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___baseAddressIfContiguous_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>._baseAddressIfContiguous expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._baseAddressIfContiguous
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___baseAddressIfContiguous_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>._baseAddressIfContiguous expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._baseAddressIfContiguous
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___baseAddressIfContiguous_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>._baseAddressIfContiguous expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._baseAddressIfContiguous
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E___baseAddressIfContiguous_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>._baseAddressIfContiguous expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._baseAddressIfContiguous
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E___baseAddressIfContiguous_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>._baseAddressIfContiguous expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._baseAddressIfContiguous
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___baseAddressIfContiguous(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E___baseAddressIfContiguous_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>._baseAddressIfContiguous has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__capacity_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.capacity expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.capacity
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__capacity_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.capacity expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.capacity
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__capacity_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.capacity expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.capacity
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__capacity_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.capacity expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.capacity
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__capacity_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.capacity expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.capacity
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__capacity_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.capacity expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.capacity
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__capacity(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__capacity_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.capacity has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.count expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.count
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.count expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.count
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.count expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.count
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.count expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.count
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.count expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.count
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.count expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.count
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__count(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__count_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.count has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__customMirror_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__debugDescription_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__description_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__endIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.endIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.endIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__endIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.endIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.endIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__endIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.endIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.endIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__endIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.endIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.endIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__endIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.endIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.endIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__endIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.endIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.endIndex
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__endIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__endIndex_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.endIndex has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__first_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.first expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.first
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__first_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.first expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.first
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__first_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.first expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.first
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__first_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.first expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.first
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__first_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.first expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.first
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__first_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.first expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.first
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__first(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__first_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.first has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__hashValue_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__indices_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.indices expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.indices
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__indices_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.indices expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.indices
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__indices_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.indices expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.indices
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__indices_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.indices expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.indices
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__indices_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.indices expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.indices
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__indices_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.indices expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.indices
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__indices(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__indices_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.indices has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__isEmpty_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.isEmpty expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.isEmpty
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__isEmpty_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.isEmpty expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.isEmpty
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__isEmpty_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.isEmpty expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.isEmpty
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__isEmpty_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.isEmpty expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.isEmpty
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__isEmpty_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.isEmpty expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.isEmpty
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__isEmpty_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.isEmpty expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.isEmpty
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__isEmpty(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__isEmpty_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.isEmpty has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__last_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.last expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.last
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__last_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.last expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.last
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__last_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.last expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.last
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__last_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.last expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.last
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__last_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.last expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.last
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__last_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.last expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.last
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__last(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__last_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.last has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__lazy_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.lazy expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.lazy
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Foundation.Data>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__lazy_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.lazy expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.lazy
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__lazy_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.lazy expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.lazy
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__lazy_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.lazy expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.lazy
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__lazy_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.lazy expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.lazy
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__lazy_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.lazy expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.lazy
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__lazy(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__lazy_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.lazy has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__startIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.startIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.startIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__startIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.startIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.startIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__startIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.startIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.startIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__startIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.startIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.startIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__startIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.startIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.startIndex
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__startIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.startIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.startIndex
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__startIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__startIndex_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.startIndex has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__underestimatedCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.underestimatedCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Foundation.Data>", as: Swift.Array<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.underestimatedCount
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__underestimatedCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.underestimatedCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.underestimatedCount
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__underestimatedCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.underestimatedCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.underestimatedCount
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__underestimatedCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.underestimatedCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.underestimatedCount
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_String_u003E__underestimatedCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.underestimatedCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.underestimatedCount
    return .int(result)
}

public func Host_Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E__underestimatedCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Array<Element>.underestimatedCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.UInt8>", as: Swift.Array<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.underestimatedCount
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__underestimatedCount(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Array<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Array_u003C_Foundation_u002E_Data_u003E__underestimatedCount_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Array<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Array<Foundation.Data>.underestimatedCount has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

