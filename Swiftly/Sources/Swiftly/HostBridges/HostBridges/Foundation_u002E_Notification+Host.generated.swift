// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Foundation.Notification

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Notification__Foundation_u002E_Notification(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Notification.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Notification metatype") }
    let lhs: Foundation.Notification = try vm.withHost(args[1], typeName: "Foundation.Notification", as: Foundation.Notification.self) { host in
        host
    }
    let rhs: Foundation.Notification = try vm.withHost(args[2], typeName: "Foundation.Notification", as: Foundation.Notification.self) { host in
        host
    }
    let result = lhs == rhs
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Notification__Foundation_u002E_Notification(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Notification") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Notification__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Notification__Foundation_u002E_Notification(vm: &vm, args)
        } else {
            throw VMError.unsupported("Notification.==(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Notification (lhs: Foundation.Notification, rhs: Foundation.Notification)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Notification.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Notification__Foundation_u002E_Notification(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Notification__Foundation_u002E_Notification(vm: &vm, args) }
    throw VMError.unsupported("Notification.==(lhs:rhs:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification_init_u0028_name_u003A_object_u003A_userInfo_u003A__u0029___Foundation_u002E_Notification_u002E_Name__Swift_u002E_Optional_u003C_Swift_u002E_Any_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_AnyHashable_u002C_Swift_u002E_Any_u003E__u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Notification.init(name:object:userInfo:) expects 3 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Notification metatype") }
    let name: Foundation.Notification.Name = try vm.withHost(args[1], typeName: "Foundation.Notification.Name", as: Foundation.Notification.Name.self) { host in
        host
    }
    var object: Any? = nil
    if case .nilValue = args[2] {
        object = nil
    } else {
        object = try vm.convertToAny(args[2])
    }
    var userInfo: Swift.Dictionary<AnyHashable,Any>? = nil
    if case .nilValue = args[3] {
        userInfo = nil
    } else {
        userInfo = try vm.withHost(args[3], typeName: "Swift.Dictionary<AnyHashable,Any>", as: Swift.Dictionary<AnyHashable,Any>.self) { host in
            host
        }
    }
    let result = Foundation.Notification(name: name, object: object, userInfo: userInfo)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification_init_u0028_name_u003A_object_u003A_userInfo_u003A__u0029___Foundation_u002E_Notification_u002E_Name__Swift_u002E_Optional_u003C_Swift_u002E_Any_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_AnyHashable_u002C_Swift_u002E_Any_u003E__u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Notification") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Notification_init_u0028_name_u003A_object_u003A_userInfo_u003A__u0029___Foundation_u002E_Notification_u002E_Name__Swift_u002E_Optional_u003C_Swift_u002E_Any_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_AnyHashable_u002C_Swift_u002E_Any_u003E__u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Notification.init(name:object:userInfo:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Notification (name: Foundation.Notification.Name, object: Swift.Optional<Swift.Any>, userInfo: Swift.Optional<Swift.Dictionary<Swift.AnyHashable,Swift.Any>>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Notification.init(name:object:userInfo:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification_init_u0028_name_u003A_object_u003A_userInfo_u003A__u0029___Foundation_u002E_Notification_u002E_Name__Swift_u002E_Optional_u003C_Swift_u002E_Any_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_AnyHashable_u002C_Swift_u002E_Any_u003E__u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification_init_u0028_name_u003A_object_u003A_userInfo_u003A__u0029___Foundation_u002E_Notification_u002E_Name__Swift_u002E_Optional_u003C_Swift_u002E_Any_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_AnyHashable_u002C_Swift_u002E_Any_u003E__u003E_(vm: &vm, args) }
    throw VMError.unsupported("Notification.init(name:object:userInfo:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Notification.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    let receiver = try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Notification"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Notification") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Notification_customMirror_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Notification.customMirror is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Notification ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Notification.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification_customMirror(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Notification.customMirror is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification_debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Notification.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    let receiver = try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Notification") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Notification_debugDescription_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Notification.debugDescription is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Notification ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Notification.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification_debugDescription(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Notification.debugDescription is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Notification.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    let receiver = try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Notification") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Notification_description_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Notification.description is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Notification ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Notification.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification_description(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification_description(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Notification.description is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Notification.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    let receiver = try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Notification") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Notification_hashValue_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Notification.hashValue is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Notification ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Notification.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification_hashValue(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Notification.hashValue is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification_name_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Notification.name expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    let receiver = try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { host in
        host
    }
    let result = receiver.name
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Notification"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification_name(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Notification") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Notification_name_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Notification.name is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Notification ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Notification.name has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_Notification_name_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.Notification.name setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    let newValue: Foundation.Notification.Name = try vm.withHost(args[1], typeName: "Foundation.Notification.Name", as: Foundation.Notification.Name.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { receiver in
        receiver.name = newValue
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_Notification_name(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "Notification") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_Notification_name_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.Notification.name is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Notification (value: Foundation.Notification.Name)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.Notification.name has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification_name(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification_name(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Notification.name is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_Notification_name(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_Notification_name(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.Notification.name is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification_object_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Notification.object expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    let receiver = try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { host in
        host
    }
    let result = receiver.object
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Notification"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification_object(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Notification") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Notification_object_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Notification.object is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Notification ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Notification.object has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_Notification_object_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.Notification.object setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    var newValue: Any? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try vm.convertToAny(args[1])
    }
    return try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { receiver in
        receiver.object = newValue
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_Notification_object(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "Notification") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_Notification_object_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.Notification.object is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Notification (value: Swift.Optional<Swift.Any>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.Notification.object has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification_object(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification_object(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Notification.object is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_Notification_object(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_Notification_object(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.Notification.object is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Notification_userInfo_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Notification.userInfo expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    let receiver = try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { host in
        host
    }
    let result = receiver.userInfo
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Notification"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Notification_userInfo(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Notification") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Notification_userInfo_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Notification.userInfo is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Notification ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Notification.userInfo has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_Notification_userInfo_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.Notification.userInfo setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be Notification host") }
    var newValue: Swift.Dictionary<AnyHashable,Any>? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try vm.withHost(args[1], typeName: "Swift.Dictionary<AnyHashable,Any>", as: Swift.Dictionary<AnyHashable,Any>.self) { host in
            host
        }
    }
    return try vm.withHost(args[0], typeName: "Notification", as: Foundation.Notification.self) { receiver in
        receiver.userInfo = newValue
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_Notification_userInfo(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "Notification") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_Notification_userInfo_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.Notification.userInfo is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Notification (value: Swift.Optional<Swift.Dictionary<Swift.AnyHashable,Swift.Any>>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.Notification.userInfo has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Notification_userInfo(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Notification_userInfo(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Notification.userInfo is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_Notification_userInfo(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_Notification_userInfo(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.Notification.userInfo is not available on this platform")
}

