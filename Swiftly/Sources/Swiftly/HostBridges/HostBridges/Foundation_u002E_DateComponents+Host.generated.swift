// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Foundation.DateComponents

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_DateComponents__Foundation_u002E_DateComponents(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("DateComponents.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents metatype") }
    let lhs: Foundation.DateComponents = try vm.withHost(args[1], typeName: "Foundation.DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let rhs: Foundation.DateComponents = try vm.withHost(args[2], typeName: "Foundation.DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = lhs == rhs
    return .bool(result)
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_DateComponents__Foundation_u002E_DateComponents(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_DateComponents__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_DateComponents__Foundation_u002E_DateComponents(vm: &vm, args)
        } else {
            throw VMError.unsupported("DateComponents.==(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (lhs: Foundation.DateComponents, rhs: Foundation.DateComponents)",
    ] .joined(separator: "\n")
    throw VMError.typeError("DateComponents.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_DateComponents__Foundation_u002E_DateComponents(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_DateComponents__Foundation_u002E_DateComponents(vm: &vm, args) }
    throw VMError.unsupported("DateComponents.==(lhs:rhs:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("DateComponents.encode(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let encoder: Swift.Encoder = try vm.withHost(args[1], typeName: "Swift.Encoder", as: Swift.Encoder.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    try receiver.encode(to: encoder)
    return .bool(true)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.DateComponents") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_DateComponents_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("DateComponents.encode(to:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (to: Swift.Encoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("DateComponents.encode(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args) }
    throw VMError.unsupported("DateComponents.encode(to:) is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_init_u0028_calendar_u003A_timeZone_u003A_era_u003A_year_u003A_month_u003A_day_u003A_hour_u003A_minute_u003A_second_u003A_nanosecond_u003A_weekday_u003A_weekdayOrdinal_u003A_quarter_u003A_weekOfMonth_u003A_weekOfYear_u003A_yearForWeekOfYear_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Calendar_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_TimeZone_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 17 else { throw VMError.typeError("DateComponents.init(calendar:timeZone:era:year:month:day:hour:minute:second:nanosecond:weekday:weekdayOrdinal:quarter:weekOfMonth:weekOfYear:yearForWeekOfYear:) expects 16 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents metatype") }
    var calendar: Foundation.Calendar? = nil
    if case .nilValue = args[1] {
        calendar = nil
    } else {
        calendar = try vm.withHost(args[1], typeName: "Foundation.Calendar", as: Foundation.Calendar.self) { host in
            host
        }
    }
    var timeZone: Foundation.TimeZone? = nil
    if case .nilValue = args[2] {
        timeZone = nil
    } else {
        timeZone = try vm.withHost(args[2], typeName: "Foundation.TimeZone", as: Foundation.TimeZone.self) { host in
            host
        }
    }
    var era: Swift.Int? = nil
    if case .nilValue = args[3] {
        era = nil
    } else {
        era = try args[3].expectInt("era")
    }
    var year: Swift.Int? = nil
    if case .nilValue = args[4] {
        year = nil
    } else {
        year = try args[4].expectInt("year")
    }
    var month: Swift.Int? = nil
    if case .nilValue = args[5] {
        month = nil
    } else {
        month = try args[5].expectInt("month")
    }
    var day: Swift.Int? = nil
    if case .nilValue = args[6] {
        day = nil
    } else {
        day = try args[6].expectInt("day")
    }
    var hour: Swift.Int? = nil
    if case .nilValue = args[7] {
        hour = nil
    } else {
        hour = try args[7].expectInt("hour")
    }
    var minute: Swift.Int? = nil
    if case .nilValue = args[8] {
        minute = nil
    } else {
        minute = try args[8].expectInt("minute")
    }
    var second: Swift.Int? = nil
    if case .nilValue = args[9] {
        second = nil
    } else {
        second = try args[9].expectInt("second")
    }
    var nanosecond: Swift.Int? = nil
    if case .nilValue = args[10] {
        nanosecond = nil
    } else {
        nanosecond = try args[10].expectInt("nanosecond")
    }
    var weekday: Swift.Int? = nil
    if case .nilValue = args[11] {
        weekday = nil
    } else {
        weekday = try args[11].expectInt("weekday")
    }
    var weekdayOrdinal: Swift.Int? = nil
    if case .nilValue = args[12] {
        weekdayOrdinal = nil
    } else {
        weekdayOrdinal = try args[12].expectInt("weekdayOrdinal")
    }
    var quarter: Swift.Int? = nil
    if case .nilValue = args[13] {
        quarter = nil
    } else {
        quarter = try args[13].expectInt("quarter")
    }
    var weekOfMonth: Swift.Int? = nil
    if case .nilValue = args[14] {
        weekOfMonth = nil
    } else {
        weekOfMonth = try args[14].expectInt("weekOfMonth")
    }
    var weekOfYear: Swift.Int? = nil
    if case .nilValue = args[15] {
        weekOfYear = nil
    } else {
        weekOfYear = try args[15].expectInt("weekOfYear")
    }
    var yearForWeekOfYear: Swift.Int? = nil
    if case .nilValue = args[16] {
        yearForWeekOfYear = nil
    } else {
        yearForWeekOfYear = try args[16].expectInt("yearForWeekOfYear")
    }
    let result = Foundation.DateComponents(calendar: calendar, timeZone: timeZone, era: era, year: year, month: month, day: day, hour: hour, minute: minute, second: second, nanosecond: nanosecond, weekday: weekday, weekdayOrdinal: weekdayOrdinal, quarter: quarter, weekOfMonth: weekOfMonth, weekOfYear: weekOfYear, yearForWeekOfYear: yearForWeekOfYear)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_init_u0028_calendar_u003A_timeZone_u003A_era_u003A_year_u003A_month_u003A_day_u003A_hour_u003A_minute_u003A_second_u003A_nanosecond_u003A_weekday_u003A_weekdayOrdinal_u003A_quarter_u003A_weekOfMonth_u003A_weekOfYear_u003A_yearForWeekOfYear_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Calendar_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_TimeZone_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_DateComponents_init_u0028_calendar_u003A_timeZone_u003A_era_u003A_year_u003A_month_u003A_day_u003A_hour_u003A_minute_u003A_second_u003A_nanosecond_u003A_weekday_u003A_weekdayOrdinal_u003A_quarter_u003A_weekOfMonth_u003A_weekOfYear_u003A_yearForWeekOfYear_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Calendar_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_TimeZone_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("DateComponents.init(calendar:timeZone:era:year:month:day:hour:minute:second:nanosecond:weekday:weekdayOrdinal:quarter:weekOfMonth:weekOfYear:yearForWeekOfYear:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (calendar: Swift.Optional<Foundation.Calendar>, timeZone: Swift.Optional<Foundation.TimeZone>, era: Swift.Optional<Swift.Int>, year: Swift.Optional<Swift.Int>, month: Swift.Optional<Swift.Int>, day: Swift.Optional<Swift.Int>, hour: Swift.Optional<Swift.Int>, minute: Swift.Optional<Swift.Int>, second: Swift.Optional<Swift.Int>, nanosecond: Swift.Optional<Swift.Int>, weekday: Swift.Optional<Swift.Int>, weekdayOrdinal: Swift.Optional<Swift.Int>, quarter: Swift.Optional<Swift.Int>, weekOfMonth: Swift.Optional<Swift.Int>, weekOfYear: Swift.Optional<Swift.Int>, yearForWeekOfYear: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("DateComponents.init(calendar:timeZone:era:year:month:day:hour:minute:second:nanosecond:weekday:weekdayOrdinal:quarter:weekOfMonth:weekOfYear:yearForWeekOfYear:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_init_u0028_calendar_u003A_timeZone_u003A_era_u003A_year_u003A_month_u003A_day_u003A_hour_u003A_minute_u003A_second_u003A_nanosecond_u003A_weekday_u003A_weekdayOrdinal_u003A_quarter_u003A_weekOfMonth_u003A_weekOfYear_u003A_yearForWeekOfYear_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Calendar_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_TimeZone_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_init_u0028_calendar_u003A_timeZone_u003A_era_u003A_year_u003A_month_u003A_day_u003A_hour_u003A_minute_u003A_second_u003A_nanosecond_u003A_weekday_u003A_weekdayOrdinal_u003A_quarter_u003A_weekOfMonth_u003A_weekOfYear_u003A_yearForWeekOfYear_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Calendar_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_TimeZone_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E_(vm: &vm, args) }
    throw VMError.unsupported("DateComponents.init(calendar:timeZone:era:year:month:day:hour:minute:second:nanosecond:weekday:weekdayOrdinal:quarter:weekOfMonth:weekOfYear:yearForWeekOfYear:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("DateComponents.init(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents metatype") }
    let decoder: Swift.Decoder = try vm.withHost(args[1], typeName: "Swift.Decoder", as: Swift.Decoder.self) { host in
        host
    }
    let result = try Foundation.DateComponents(from: decoder)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.DateComponents") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_DateComponents_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("DateComponents.init(from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (from: Swift.Decoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("DateComponents.init(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args) }
    throw VMError.unsupported("DateComponents.init(from:) is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_isValidDate_u0028_in_u003A__u0029___Foundation_u002E_Calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("DateComponents.isValidDate(in:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let calendar: Foundation.Calendar = try vm.withHost(args[1], typeName: "Foundation.Calendar", as: Foundation.Calendar.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.isValidDate(in: calendar)
    return .bool(result)
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_isValidDate_u0028_in_u003A__u0029___Foundation_u002E_Calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_DateComponents_isValidDate_u0028_in_u003A__u0029___Foundation_u002E_Calendar(vm: &vm, args)
        } else {
            throw VMError.unsupported("DateComponents.isValidDate(in:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (in: Foundation.Calendar)",
    ] .joined(separator: "\n")
    throw VMError.typeError("DateComponents.isValidDate(in:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_isValidDate_u0028_in_u003A__u0029___Foundation_u002E_Calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_isValidDate_u0028_in_u003A__u0029___Foundation_u002E_Calendar(vm: &vm, args) }
    throw VMError.unsupported("DateComponents.isValidDate(in:) is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_setValue_u0028___u003A_for_u003A__u0029___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Foundation_u002E_Calendar_u002E_Component(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("DateComponents.setValue(_:for:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var value: Swift.Int? = nil
    if case .nilValue = args[1] {
        value = nil
    } else {
        value = try args[1].expectInt("value")
    }
    let component: Foundation.Calendar.Component = try vm.withHost(args[2], typeName: "Foundation.Calendar.Component", as: Foundation.Calendar.Component.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.setValue(value, for: component)
        return args[0]
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_setValue_u0028___u003A_for_u003A__u0029___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Foundation_u002E_Calendar_u002E_Component(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_DateComponents_setValue_u0028___u003A_for_u003A__u0029___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Foundation_u002E_Calendar_u002E_Component(vm: &vm, args)
        } else {
            throw VMError.unsupported("DateComponents.setValue(_:for:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (Swift.Optional<Swift.Int>, for: Foundation.Calendar.Component)",
    ] .joined(separator: "\n")
    throw VMError.typeError("DateComponents.setValue(_:for:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_setValue_u0028___u003A_for_u003A__u0029___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Foundation_u002E_Calendar_u002E_Component(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_setValue_u0028___u003A_for_u003A__u0029___Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E___Foundation_u002E_Calendar_u002E_Component(vm: &vm, args) }
    throw VMError.unsupported("DateComponents.setValue(_:for:) is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_value_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Component(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("DateComponents.value(for:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let component: Foundation.Calendar.Component = try vm.withHost(args[1], typeName: "Foundation.Calendar.Component", as: Foundation.Calendar.Component.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.value(for: component)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_value_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Component(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_DateComponents_value_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Component(vm: &vm, args)
        } else {
            throw VMError.unsupported("DateComponents.value(for:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (for: Foundation.Calendar.Component)",
    ] .joined(separator: "\n")
    throw VMError.typeError("DateComponents.value(for:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_value_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Component(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_value_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Component(vm: &vm, args) }
    throw VMError.unsupported("DateComponents.value(for:) is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_calendar_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.calendar expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.calendar
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "DateComponents"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_calendar_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.calendar is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.calendar has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_calendar_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.calendar setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Foundation.Calendar? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try vm.withHost(args[1], typeName: "Foundation.Calendar", as: Foundation.Calendar.self) { host in
            host
        }
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.calendar = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_calendar_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.calendar is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Foundation.Calendar>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.calendar has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_calendar(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.calendar is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_calendar(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.calendar is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "DateComponents"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_customMirror_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.customMirror is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_customMirror(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.customMirror is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_date_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.date expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.date
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "DateComponents"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_date_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.date is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.date has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_date(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.date is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_day_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.day expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.day
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_day(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_day_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.day is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.day has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_day_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.day setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("day")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.day = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_day(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_day_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.day is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.day has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_day(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_day(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.day is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_day(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_day(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.day is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
public func Host_Foundation_u002E_DateComponents_dayOfYear_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.dayOfYear expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.dayOfYear
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
public func HostDispatcher_Foundation_u002E_DateComponents_dayOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 15, iOS 18, tvOS 18, watchOS 11, *) { return try Host_Foundation_u002E_DateComponents_dayOfYear_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.dayOfYear is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.dayOfYear has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
public func HostSet_Foundation_u002E_DateComponents_dayOfYear_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.dayOfYear setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("dayOfYear")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.dayOfYear = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
public func HostSetter_Foundation_u002E_DateComponents_dayOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 15, iOS 18, tvOS 18, watchOS 11, *) {
            return try HostSet_Foundation_u002E_DateComponents_dayOfYear_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.dayOfYear is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.dayOfYear has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_dayOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15, iOS 18, tvOS 18, watchOS 11, *) { return try HostDispatcher_Foundation_u002E_DateComponents_dayOfYear(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.dayOfYear is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_dayOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15, iOS 18, tvOS 18, watchOS 11, *) { return try HostSetter_Foundation_u002E_DateComponents_dayOfYear(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.dayOfYear is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_debugDescription_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.debugDescription is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_debugDescription(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.debugDescription is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_description_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.description is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_description(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_description(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.description is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_era_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.era expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.era
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_era(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_era_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.era is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.era has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_era_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.era setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("era")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.era = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_era(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_era_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.era is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.era has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_era(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_era(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.era is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_era(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_era(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.era is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_hashValue_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.hashValue is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_hashValue(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.hashValue is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_hour_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.hour expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.hour
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_hour(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_hour_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.hour is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.hour has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_hour_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.hour setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("hour")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.hour = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_hour(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_hour_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.hour is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.hour has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_hour(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_hour(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.hour is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_hour(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_hour(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.hour is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_isLeapMonth_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.isLeapMonth expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.isLeapMonth
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_isLeapMonth(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_isLeapMonth_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.isLeapMonth is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.isLeapMonth has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_isLeapMonth_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.isLeapMonth setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Bool? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectBool("isLeapMonth")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.isLeapMonth = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_isLeapMonth(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_isLeapMonth_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.isLeapMonth is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Bool>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.isLeapMonth has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_isLeapMonth(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_isLeapMonth(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.isLeapMonth is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_isLeapMonth(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_isLeapMonth(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.isLeapMonth is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public func Host_Foundation_u002E_DateComponents_isRepeatedDay_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.isRepeatedDay expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.isRepeatedDay
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_isRepeatedDay(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *) { return try Host_Foundation_u002E_DateComponents_isRepeatedDay_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.isRepeatedDay is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.isRepeatedDay has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public func HostSet_Foundation_u002E_DateComponents_isRepeatedDay_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.isRepeatedDay setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Bool? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectBool("isRepeatedDay")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.isRepeatedDay = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public func HostSetter_Foundation_u002E_DateComponents_isRepeatedDay(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_isRepeatedDay_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.isRepeatedDay is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Bool>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.isRepeatedDay has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_isRepeatedDay(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_isRepeatedDay(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.isRepeatedDay is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_isRepeatedDay(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *) { return try HostSetter_Foundation_u002E_DateComponents_isRepeatedDay(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.isRepeatedDay is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_isValidDate_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.isValidDate expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.isValidDate
    return .bool(result)
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_isValidDate(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_isValidDate_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.isValidDate is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.isValidDate has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_isValidDate(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_isValidDate(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.isValidDate is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_minute_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.minute expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.minute
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_minute(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_minute_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.minute is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.minute has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_minute_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.minute setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("minute")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.minute = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_minute(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_minute_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.minute is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.minute has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_minute(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_minute(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.minute is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_minute(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_minute(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.minute is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_month_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.month expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.month
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_month(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_month_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.month is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.month has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_month_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.month setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("month")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.month = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_month(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_month_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.month is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.month has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_month(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_month(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.month is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_month(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_month(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.month is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_nanosecond_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.nanosecond expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.nanosecond
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_nanosecond(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_nanosecond_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.nanosecond is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.nanosecond has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_nanosecond_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.nanosecond setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("nanosecond")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.nanosecond = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_nanosecond(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_nanosecond_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.nanosecond is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.nanosecond has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_nanosecond(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_nanosecond(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.nanosecond is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_nanosecond(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_nanosecond(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.nanosecond is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_quarter_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.quarter expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.quarter
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_quarter(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_quarter_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.quarter is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.quarter has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_quarter_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.quarter setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("quarter")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.quarter = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_quarter(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_quarter_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.quarter is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.quarter has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_quarter(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_quarter(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.quarter is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_quarter(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_quarter(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.quarter is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_second_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.second expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.second
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_second(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_second_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.second is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.second has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_second_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.second setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("second")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.second = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_second(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_second_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.second is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.second has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_second(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_second(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.second is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_second(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_second(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.second is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_timeZone_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.timeZone expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.timeZone
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "DateComponents"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_timeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_timeZone_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.timeZone is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.timeZone has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_timeZone_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.timeZone setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Foundation.TimeZone? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try vm.withHost(args[1], typeName: "Foundation.TimeZone", as: Foundation.TimeZone.self) { host in
            host
        }
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.timeZone = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_timeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_timeZone_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.timeZone is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Foundation.TimeZone>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.timeZone has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_timeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_timeZone(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.timeZone is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_timeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_timeZone(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.timeZone is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_weekOfMonth_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.weekOfMonth expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.weekOfMonth
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_weekOfMonth(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_weekOfMonth_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.weekOfMonth is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.weekOfMonth has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_weekOfMonth_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.weekOfMonth setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("weekOfMonth")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.weekOfMonth = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_weekOfMonth(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_weekOfMonth_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.weekOfMonth is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.weekOfMonth has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_weekOfMonth(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_weekOfMonth(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.weekOfMonth is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_weekOfMonth(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_weekOfMonth(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.weekOfMonth is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_weekOfYear_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.weekOfYear expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.weekOfYear
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_weekOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_weekOfYear_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.weekOfYear is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.weekOfYear has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_weekOfYear_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.weekOfYear setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("weekOfYear")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.weekOfYear = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_weekOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_weekOfYear_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.weekOfYear is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.weekOfYear has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_weekOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_weekOfYear(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.weekOfYear is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_weekOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_weekOfYear(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.weekOfYear is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_weekday_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.weekday expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.weekday
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_weekday(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_weekday_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.weekday is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.weekday has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_weekday_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.weekday setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("weekday")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.weekday = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_weekday(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_weekday_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.weekday is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.weekday has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_weekday(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_weekday(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.weekday is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_weekday(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_weekday(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.weekday is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_weekdayOrdinal_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.weekdayOrdinal expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.weekdayOrdinal
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_weekdayOrdinal(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_weekdayOrdinal_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.weekdayOrdinal is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.weekdayOrdinal has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_weekdayOrdinal_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.weekdayOrdinal setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("weekdayOrdinal")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.weekdayOrdinal = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_weekdayOrdinal(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_weekdayOrdinal_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.weekdayOrdinal is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.weekdayOrdinal has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_weekdayOrdinal(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_weekdayOrdinal(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.weekdayOrdinal is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_weekdayOrdinal(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_weekdayOrdinal(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.weekdayOrdinal is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_year_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.year expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.year
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_year(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_year_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.year is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.year has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_year_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.year setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("year")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.year = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_year(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_year_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.year is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.year has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_year(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_year(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.year is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_year(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_year(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.year is not available on this platform")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_DateComponents_yearForWeekOfYear_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.DateComponents.yearForWeekOfYear expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    let receiver = try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { host in
        host
    }
    let result = receiver.yearForWeekOfYear
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_DateComponents_yearForWeekOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "DateComponents") {
        switch args[0] {
        case .host:
            if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_DateComponents_yearForWeekOfYear_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.DateComponents.yearForWeekOfYear is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.DateComponents ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.DateComponents.yearForWeekOfYear has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_DateComponents_yearForWeekOfYear_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.DateComponents.yearForWeekOfYear setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be DateComponents host") }
    var newValue: Swift.Int? = nil
    if case .nilValue = args[1] {
        newValue = nil
    } else {
        newValue = try args[1].expectInt("yearForWeekOfYear")
    }
    return try vm.withHost(args[0], typeName: "DateComponents", as: Foundation.DateComponents.self) { receiver in
        receiver.yearForWeekOfYear = newValue
        return .nilValue
    }
}

@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_DateComponents_yearForWeekOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "DateComponents") {
        if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_DateComponents_yearForWeekOfYear_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.DateComponents.yearForWeekOfYear is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.DateComponents (value: Swift.Optional<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.DateComponents.yearForWeekOfYear has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_DateComponents_yearForWeekOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_DateComponents_yearForWeekOfYear(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.DateComponents.yearForWeekOfYear is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_DateComponents_yearForWeekOfYear(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.9, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_DateComponents_yearForWeekOfYear(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.DateComponents.yearForWeekOfYear is not available on this platform")
}

