// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Int

public func Host_Swift_u002E_Int__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs != rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.!=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0025__u0028_lhs_u003A_rhs_u003A__u0029___op_percent__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.%(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs % rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u0025__u0028_lhs_u003A_rhs_u003A__u0029___op_percent__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0025__u0028_lhs_u003A_rhs_u003A__u0029___op_percent__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.%(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0025__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_percent_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.%=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs %= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u0025__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_percent_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0025__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_percent_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.%=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u0028_lhs_u003A_rhs_u003A__u0029___op_amp__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs & rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u0028_lhs_u003A_rhs_u003A__u0029___op_amp__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u0028_lhs_u003A_rhs_u003A__u0029___op_amp__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Int__u0026__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_star__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&*(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs &* rhs
    return .int(result)
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func HostDispatcher_Swift_u002E_Int__u0026__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_star__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
            return try Host_Swift_u002E_Int__u0026__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_star__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Int.&*(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&*(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Int__u0026__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_star__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) { return try HostDispatcher_Swift_u002E_Int__u0026__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_star__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Int.&*(lhs:rhs:) is not available on this platform")
}

public func Host_Swift_u002E_Int__u0026__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_star_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&*=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs &*= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_star_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_star_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&*=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_plus__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs &+ rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_plus__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_plus__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&+(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_plus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&+=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs &+= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_plus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_plus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&+=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_minus__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&-(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs &- rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_minus__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_minus__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&-(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_minus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&-=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs &-= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_minus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_minus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&-=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u003C__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_lt_lt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&<<(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs &<< rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u003C__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_lt_lt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u003C__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_lt_lt__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&<<(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u003C__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_lt_lt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&<<=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs &<<= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u003C__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_lt_lt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u003C__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_lt_lt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&<<=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs &= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u003E__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_gt_gt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&>>(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs &>> rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u003E__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_gt_gt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u003E__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_gt_gt__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&>>(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u0026__u003E__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_gt_gt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.&>>=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs &>>= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u0026__u003E__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_gt_gt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u0026__u003E__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_amp_gt_gt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.&>>=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_star__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.*(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs * rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_star__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_star__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.*(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_star_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.*=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs *= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_star_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_star_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.*=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs + rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.+(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002B__u0028_x_u003A__u0029___op_plus__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.+(x:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let x = try args[1].expectInt("x")
    let result = +x
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u002B__u0028_x_u003A__u0029___op_plus__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002B__u0028_x_u003A__u0029___op_plus__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (x: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.+(x:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.+=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs += rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.+=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.-(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs - rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.-(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002D__u0028_operand_u003A__u0029___op_minus__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.-(operand:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let operand = try args[1].expectInt("operand")
    let result = -operand
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u002D__u0028_operand_u003A__u0029___op_minus__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002D__u0028_operand_u003A__u0029___op_minus__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (operand: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.-(operand:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.-=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs -= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.-=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002F__u0028_lhs_u003A_rhs_u003A__u0029___op_slash__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int./(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs / rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u002F__u0028_lhs_u003A_rhs_u003A__u0029___op_slash__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002F__u0028_lhs_u003A_rhs_u003A__u0029___op_slash__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int./(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u002F__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_slash_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int./=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs /= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u002F__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_slash_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u002F__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_slash_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int./=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.<(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs < rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.<(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u003C__u0028_x_u003A_y_u003A__u0029___op_lt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.<(x:y:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let x = try args[1].expectInt("x")
    let y = try args[2].expectInt("y")
    let result = x < y
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int__u003C__u0028_x_u003A_y_u003A__u0029___op_lt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u003C__u0028_x_u003A_y_u003A__u0029___op_lt__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (x: Swift.Int, y: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.<(x:y:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.<=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs <= rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.<=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs == rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u003D__u003D__u0028_x_u003A_y_u003A__u0029___op_eq_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.==(x:y:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let x = try args[1].expectInt("x")
    let y = try args[2].expectInt("y")
    let result = x == y
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int__u003D__u003D__u0028_x_u003A_y_u003A__u0029___op_eq_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u003D__u003D__u0028_x_u003A_y_u003A__u0029___op_eq_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (x: Swift.Int, y: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.==(x:y:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.>(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs > rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.>(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.>=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs >= rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.>=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u005E__u0028_lhs_u003A_rhs_u003A__u0029___op_caret__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.^(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs ^ rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u005E__u0028_lhs_u003A_rhs_u003A__u0029___op_caret__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u005E__u0028_lhs_u003A_rhs_u003A__u0029___op_caret__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.^(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u005E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_caret_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.^=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs ^= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u005E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_caret_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u005E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_caret_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.^=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__binaryLogarithm_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Int._binaryLogarithm() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver._binaryLogarithm()
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__binaryLogarithm_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__binaryLogarithm_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int._binaryLogarithm() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(*, deprecated, message: "Use &+ instead.")
public func Host_Swift_u002E_Int__maskingAdd_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int._maskingAdd(_:_:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = Swift.Int._maskingAdd(lhs, rhs)
    return .int(result)
}

@available(*, deprecated, message: "Use &+ instead.")
public func HostDispatcher_Swift_u002E_Int__maskingAdd_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__maskingAdd_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (Swift.Int, Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int._maskingAdd(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Int__maskingAdd_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if true { return try HostDispatcher_Swift_u002E_Int__maskingAdd_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Int._maskingAdd(_:_:) is not available on this platform")
}

@available(*, deprecated, message: "Use &- instead.")
public func Host_Swift_u002E_Int__maskingSubtract_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int._maskingSubtract(_:_:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = Swift.Int._maskingSubtract(lhs, rhs)
    return .int(result)
}

@available(*, deprecated, message: "Use &- instead.")
public func HostDispatcher_Swift_u002E_Int__maskingSubtract_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__maskingSubtract_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (Swift.Int, Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int._maskingSubtract(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Int__maskingSubtract_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if true { return try HostDispatcher_Swift_u002E_Int__maskingSubtract_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Int._maskingSubtract(_:_:) is not available on this platform")
}

public func Host_Swift_u002E_Int__nonMaskingLeftShift_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int._nonMaskingLeftShift(_:_:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = Swift.Int._nonMaskingLeftShift(lhs, rhs)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__nonMaskingLeftShift_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__nonMaskingLeftShift_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (Swift.Int, Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int._nonMaskingLeftShift(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__nonMaskingRightShift_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int._nonMaskingRightShift(_:_:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = Swift.Int._nonMaskingRightShift(lhs, rhs)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__nonMaskingRightShift_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__nonMaskingRightShift_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (Swift.Int, Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int._nonMaskingRightShift(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (seed: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int._rawHashValue(seed:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__step_u0028_after_u003A_from_u003A_by_u003A__u0029____u0028_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__u002C__u0020_Swift_u002E_Int_u0029___Swift_u002E_Int__Swift_u002E_Int_u002E_Stride(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Int._step(after:from:by:) expects 3 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let current: (Swift.Optional<Swift.Int>, Swift.Int) = try vm.withHost(args[1], typeName: "(Swift.Optional<Swift.Int>, Swift.Int)", as: (Swift.Optional<Swift.Int>, Swift.Int).self) { host in
        host
    }
    let start = try args[2].expectInt("start")
    let distance: Swift.Int.Stride = try vm.withHost(args[3], typeName: "Swift.Int.Stride", as: Swift.Int.Stride.self) { host in
        host
    }
    let result = Swift.Int._step(after: current, from: start, by: distance)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int__step_u0028_after_u003A_from_u003A_by_u003A__u0029____u0028_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__u002C__u0020_Swift_u002E_Int_u0029___Swift_u002E_Int__Swift_u002E_Int_u002E_Stride(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__step_u0028_after_u003A_from_u003A_by_u003A__u0029____u0028_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__u002C__u0020_Swift_u002E_Int_u0029___Swift_u002E_Int__Swift_u002E_Int_u002E_Stride(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (after: (Swift.Optional<Swift.Int>, Swift.Int), from: Swift.Int, by: Swift.Int.Stride)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int._step(after:from:by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__toCustomAnyHashable_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Int._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Int"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Int__toCustomAnyHashable_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__toCustomAnyHashable_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int._toCustomAnyHashable() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_addingReportingOverflow_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.addingReportingOverflow(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let other = try args[1].expectInt("other")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.addingReportingOverflow(other)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_addingReportingOverflow_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_addingReportingOverflow_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.addingReportingOverflow(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_advanced_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.advanced(by:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let n = try args[1].expectInt("n")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.advanced(by: n)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_advanced_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_advanced_u0028_by_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (by: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.advanced(by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_distance_u0028_to_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.distance(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let other = try args[1].expectInt("other")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.distance(to: other)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_distance_u0028_to_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_distance_u0028_to_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (to: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.distance(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_dividedReportingOverflow_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.dividedReportingOverflow(by:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let other = try args[1].expectInt("other")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.dividedReportingOverflow(by: other)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_dividedReportingOverflow_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_dividedReportingOverflow_u0028_by_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (by: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.dividedReportingOverflow(by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_dividingFullWidth_u0028___u003A__u0029____u0028_Swift_u002E_Int_u002C__u0020_Swift_u002E_Int_u002E_Magnitude_u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.dividingFullWidth(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let dividend: (Swift.Int, Swift.Int.Magnitude) = try vm.withHost(args[1], typeName: "(Swift.Int, Swift.Int.Magnitude)", as: (Swift.Int, Swift.Int.Magnitude).self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.dividingFullWidth(dividend)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_dividingFullWidth_u0028___u003A__u0029____u0028_Swift_u002E_Int_u002C__u0020_Swift_u002E_Int_u002E_Magnitude_u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_dividingFullWidth_u0028___u003A__u0029____u0028_Swift_u002E_Int_u002C__u0020_Swift_u002E_Int_u002E_Magnitude_u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int ((Swift.Int, Swift.Int.Magnitude))",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.dividingFullWidth(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.encode(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let encoder: Swift.Encoder = try vm.withHost(args[1], typeName: "Swift.Encoder", as: Swift.Encoder.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    try receiver.encode(to: encoder)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (to: Swift.Encoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.encode(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Int.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let result = Swift.Int()
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_init_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.init() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public func Host_Swift_u002E_Int_init_u0028___u003A__u0029___Swift_u002E_Float16(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.init(_:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let source: Swift.Float16 = try vm.withHost(args[1], typeName: "Swift.Float16", as: Swift.Float16.self) { host in
        host
    }
    let result = Swift.Int(source)
    return .int(result)
}

@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public func HostDispatcher_Swift_u002E_Int_init_u0028___u003A__u0029___Swift_u002E_Float16(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        if #available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *) {
            return try Host_Swift_u002E_Int_init_u0028___u003A__u0029___Swift_u002E_Float16(vm: &vm, args)
        } else {
            throw VMError.unsupported("Int.init(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (Swift.Float16)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.init(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Int_init_u0028___u003A__u0029___Swift_u002E_Float16(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *) { return try HostDispatcher_Swift_u002E_Int_init_u0028___u003A__u0029___Swift_u002E_Float16(vm: &vm, args) }
    throw VMError.unsupported("Int.init(_:) is not available on this platform")
}

public func Host_Swift_u002E_Int_init_u0028__truncatingBits_u003A__u0029___Swift_u002E_UInt(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.init(_truncatingBits:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let bits: Swift.UInt = try vm.withHost(args[1], typeName: "Swift.UInt", as: Swift.UInt.self) { host in
        host
    }
    let result = Swift.Int(_truncatingBits: bits)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_init_u0028__truncatingBits_u003A__u0029___Swift_u002E_UInt(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_init_u0028__truncatingBits_u003A__u0029___Swift_u002E_UInt(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (_truncatingBits: Swift.UInt)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.init(_truncatingBits:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_init_u0028_bigEndian_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.init(bigEndian:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let value = try args[1].expectInt("value")
    let result = Swift.Int(bigEndian: value)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_init_u0028_bigEndian_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_init_u0028_bigEndian_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (bigEndian: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.init(bigEndian:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_init_u0028_bitPattern_u003A__u0029___Swift_u002E_Optional_u003C_Swift_u002E_OpaquePointer_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.init(bitPattern:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var pointer: Swift.OpaquePointer? = nil
    if case .nilValue = args[1] {
        pointer = nil
    } else {
        pointer = try vm.withHost(args[1], typeName: "Swift.OpaquePointer", as: Swift.OpaquePointer.self) { host in
            host
        }
    }
    let result = Swift.Int(bitPattern: pointer)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_init_u0028_bitPattern_u003A__u0029___Swift_u002E_Optional_u003C_Swift_u002E_OpaquePointer_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_init_u0028_bitPattern_u003A__u0029___Swift_u002E_Optional_u003C_Swift_u002E_OpaquePointer_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (bitPattern: Swift.Optional<Swift.OpaquePointer>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.init(bitPattern:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public func Host_Swift_u002E_Int_init_u0028_exactly_u003A__u0029___Swift_u002E_Float16(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.init(exactly:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let source: Swift.Float16 = try vm.withHost(args[1], typeName: "Swift.Float16", as: Swift.Float16.self) { host in
        host
    }
    let result = Swift.Int(exactly: source)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public func HostDispatcher_Swift_u002E_Int_init_u0028_exactly_u003A__u0029___Swift_u002E_Float16(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        if #available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *) {
            return try Host_Swift_u002E_Int_init_u0028_exactly_u003A__u0029___Swift_u002E_Float16(vm: &vm, args)
        } else {
            throw VMError.unsupported("Int.init(exactly:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (exactly: Swift.Float16)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.init(exactly:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Int_init_u0028_exactly_u003A__u0029___Swift_u002E_Float16(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *) { return try HostDispatcher_Swift_u002E_Int_init_u0028_exactly_u003A__u0029___Swift_u002E_Float16(vm: &vm, args) }
    throw VMError.unsupported("Int.init(exactly:) is not available on this platform")
}

public func Host_Swift_u002E_Int_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.init(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let decoder: Swift.Decoder = try vm.withHost(args[1], typeName: "Swift.Decoder", as: Swift.Decoder.self) { host in
        host
    }
    let result = try Swift.Int(from: decoder)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (from: Swift.Decoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.init(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_init_u0028_littleEndian_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.init(littleEndian:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let value = try args[1].expectInt("value")
    let result = Swift.Int(littleEndian: value)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_init_u0028_littleEndian_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_init_u0028_littleEndian_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (littleEndian: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.init(littleEndian:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_multipliedFullWidth_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.multipliedFullWidth(by:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let other = try args[1].expectInt("other")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.multipliedFullWidth(by: other)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_multipliedFullWidth_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_multipliedFullWidth_u0028_by_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (by: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.multipliedFullWidth(by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_multipliedReportingOverflow_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.multipliedReportingOverflow(by:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let other = try args[1].expectInt("other")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.multipliedReportingOverflow(by: other)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_multipliedReportingOverflow_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_multipliedReportingOverflow_u0028_by_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (by: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.multipliedReportingOverflow(by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_negate_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Int.negate() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    return try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { receiver in
        receiver.negate()
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Int_negate_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_negate_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.negate() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_quotientAndRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.quotientAndRemainder(dividingBy:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let rhs = try args[1].expectInt("rhs")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.quotientAndRemainder(dividingBy: rhs)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_quotientAndRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_quotientAndRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (dividingBy: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.quotientAndRemainder(dividingBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_random_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.random(in:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let range: Swift.Range<Swift.Int> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let result = Swift.Int.random(in: range)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_random_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_random_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (in: Swift.Range<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.random(in:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_remainderReportingOverflow_u0028_dividingBy_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.remainderReportingOverflow(dividingBy:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let other = try args[1].expectInt("other")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.remainderReportingOverflow(dividingBy: other)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_remainderReportingOverflow_u0028_dividingBy_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_remainderReportingOverflow_u0028_dividingBy_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (dividingBy: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.remainderReportingOverflow(dividingBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_signum_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Int.signum() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.signum()
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_signum_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_signum_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.signum() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_subtractingReportingOverflow_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.subtractingReportingOverflow(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let other = try args[1].expectInt("other")
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.subtractingReportingOverflow(other)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_subtractingReportingOverflow_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int_subtractingReportingOverflow_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.subtractingReportingOverflow(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u007C__u0028_lhs_u003A_rhs_u003A__u0029___op_pipe__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.|(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    let result = lhs | rhs
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u007C__u0028_lhs_u003A_rhs_u003A__u0029___op_pipe__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u007C__u0028_lhs_u003A_rhs_u003A__u0029___op_pipe__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.|(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u007C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_pipe_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Int.|=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    var lhs = try args[1].expectInt("lhs")
    let rhs = try args[2].expectInt("rhs")
    lhs |= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Int__u007C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_pipe_eq__Swift_u002E_Int__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u007C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_pipe_eq__Swift_u002E_Int__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (lhs: Swift.Int, rhs: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.|=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__u007E__u0028_x_u003A__u0029___op_tilde__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Int.~(x:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let x = try args[1].expectInt("x")
    let result = ~x
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__u007E__u0028_x_u003A__u0029___op_tilde__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Int") {
        return try Host_Swift_u002E_Int__u007E__u0028_x_u003A__u0029___op_tilde__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Int (x: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Int.~(x:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__cVarArgEncoding_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int._cVarArgEncoding expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver._cVarArgEncoding
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Int__cVarArgEncoding(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int__cVarArgEncoding_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int._cVarArgEncoding has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__highBitIndex_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int._highBitIndex expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let result = Swift.Int._highBitIndex
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int__highBitIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Int__highBitIndex_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int._highBitIndex has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int__lowWord_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int._lowWord expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver._lowWord
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int__lowWord(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int__lowWord_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int._lowWord has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_bigEndian_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.bigEndian expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.bigEndian
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_bigEndian(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_bigEndian_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.bigEndian has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_bitWidth_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.bitWidth expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let result = Swift.Int.bitWidth
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_bitWidth(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Int_bitWidth_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.bitWidth has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_byteSwapped_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.byteSwapped expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.byteSwapped
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_byteSwapped(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_byteSwapped_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.byteSwapped has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
public func Host_Swift_u002E_Int_codingKey_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.codingKey expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.codingKey
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
public func HostDispatcher_Swift_u002E_Int_codingKey(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host:
            if #available(macOS 12.3, iOS 15.4, tvOS 15.4, watchOS 8.5, *) { return try Host_Swift_u002E_Int_codingKey_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Swift.Int.codingKey is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.codingKey has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Int_codingKey(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 12.3, iOS 15.4, tvOS 15.4, watchOS 8.5, *) { return try HostDispatcher_Swift_u002E_Int_codingKey(vm: &vm, args) }
    throw VMError.unsupported("Getter for Swift.Int.codingKey is not available on this platform")
}

public func Host_Swift_u002E_Int_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_customMirror_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(*, deprecated, message: "Int.customPlaygroundQuickLook will be removed in a future Swift version")
public func Host_Swift_u002E_Int_customPlaygroundQuickLook_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.customPlaygroundQuickLook expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.customPlaygroundQuickLook
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

@available(*, deprecated, message: "Int.customPlaygroundQuickLook will be removed in a future Swift version")
public func HostDispatcher_Swift_u002E_Int_customPlaygroundQuickLook(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host:
            if true { return try Host_Swift_u002E_Int_customPlaygroundQuickLook_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Swift.Int.customPlaygroundQuickLook is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.customPlaygroundQuickLook has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Int_customPlaygroundQuickLook(vm: inout VM, _ args: [Value]) throws -> Value {
    if true { return try HostDispatcher_Swift_u002E_Int_customPlaygroundQuickLook(vm: &vm, args) }
    throw VMError.unsupported("Getter for Swift.Int.customPlaygroundQuickLook is not available on this platform")
}

public func Host_Swift_u002E_Int_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func HostDispatcher_Swift_u002E_Int_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_description_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_hashValue_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_isSigned_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.isSigned expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let result = Swift.Int.isSigned
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Int_isSigned(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Int_isSigned_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.isSigned has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_leadingZeroBitCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.leadingZeroBitCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.leadingZeroBitCount
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_leadingZeroBitCount(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_leadingZeroBitCount_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.leadingZeroBitCount has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_littleEndian_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.littleEndian expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.littleEndian
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_littleEndian(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_littleEndian_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.littleEndian has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_magnitude_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.magnitude expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.magnitude
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_magnitude(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_magnitude_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.magnitude has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_max_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.max expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let result = Swift.Int.max
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_max(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Int_max_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.max has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_min_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.min expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let result = Swift.Int.min
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_min(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Int_min_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.min has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_nonzeroBitCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.nonzeroBitCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.nonzeroBitCount
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_nonzeroBitCount(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_nonzeroBitCount_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.nonzeroBitCount has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_trailingZeroBitCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.trailingZeroBitCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.trailingZeroBitCount
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_trailingZeroBitCount(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_trailingZeroBitCount_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.trailingZeroBitCount has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_words_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.words expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Int host") }
    let receiver = try vm.withHost(args[0], typeName: "Int", as: Swift.Int.self) { host in
        host
    }
    let result = receiver.words
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Int"))
}

public func HostDispatcher_Swift_u002E_Int_words(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Int_words_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.words has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Int_zero_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Int.zero expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Int metatype") }
    let result = Swift.Int.zero
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Int_zero(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Int") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Int_zero_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Int ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Int.zero has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

