// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Foundation.Locale

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Locale__Foundation_u002E_Locale(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Locale.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let lhs: Foundation.Locale = try vm.withHost(args[1], typeName: "Foundation.Locale", as: Foundation.Locale.self) { host in
        host
    }
    let rhs: Foundation.Locale = try vm.withHost(args[2], typeName: "Foundation.Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = lhs == rhs
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Locale__Foundation_u002E_Locale(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Locale__Foundation_u002E_Locale(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.==(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (lhs: Foundation.Locale, rhs: Foundation.Locale)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Locale__Foundation_u002E_Locale(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Locale__Foundation_u002E_Locale(vm: &vm, args) }
    throw VMError.unsupported("Locale.==(lhs:rhs:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "identifier(_:from:)")
@available(iOS, deprecated: 16, renamed: "identifier(_:from:)")
@available(tvOS, deprecated: 16, renamed: "identifier(_:from:)")
@available(watchOS, deprecated: 9, renamed: "identifier(_:from:)")
public func Host_Foundation_u002E_Locale_canonicalIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.canonicalIdentifier(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let string = try args[1].expectString("string")
    let result = Foundation.Locale.canonicalIdentifier(from: string)
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "identifier(_:from:)")
@available(iOS, deprecated: 16, renamed: "identifier(_:from:)")
@available(tvOS, deprecated: 16, renamed: "identifier(_:from:)")
@available(watchOS, deprecated: 9, renamed: "identifier(_:from:)")
public func HostDispatcher_Foundation_u002E_Locale_canonicalIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_canonicalIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.canonicalIdentifier(from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (from: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.canonicalIdentifier(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_canonicalIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_canonicalIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.canonicalIdentifier(from:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_canonicalLanguageIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.canonicalLanguageIdentifier(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let string = try args[1].expectString("string")
    let result = Foundation.Locale.canonicalLanguageIdentifier(from: string)
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_canonicalLanguageIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_canonicalLanguageIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.canonicalLanguageIdentifier(from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (from: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.canonicalLanguageIdentifier(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_canonicalLanguageIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_canonicalLanguageIdentifier_u0028_from_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.canonicalLanguageIdentifier(from:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).characterDirection`")
@available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
@available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
@available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).characterDirection`")
public func Host_Foundation_u002E_Locale_characterDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.characterDirection(forLanguage:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let isoLangCode = try args[1].expectString("isoLangCode")
    let result = Foundation.Locale.characterDirection(forLanguage: isoLangCode)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).characterDirection`")
@available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
@available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
@available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).characterDirection`")
public func HostDispatcher_Foundation_u002E_Locale_characterDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_characterDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.characterDirection(forLanguage:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forLanguage: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.characterDirection(forLanguage:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_characterDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_characterDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.characterDirection(forLanguage:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Components(identifier:)` to access components")
@available(iOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
@available(tvOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
@available(watchOS, deprecated: 9, message: "Use `Locale.Components(identifier:)` to access components")
public func Host_Foundation_u002E_Locale_components_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.components(fromIdentifier:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let string = try args[1].expectString("string")
    let result = Foundation.Locale.components(fromIdentifier: string)
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .string(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Components(identifier:)` to access components")
@available(iOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
@available(tvOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
@available(watchOS, deprecated: 9, message: "Use `Locale.Components(identifier:)` to access components")
public func HostDispatcher_Foundation_u002E_Locale_components_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_components_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.components(fromIdentifier:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (fromIdentifier: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.components(fromIdentifier:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_components_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_components_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.components(fromIdentifier:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.encode(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let encoder: Swift.Encoder = try vm.withHost(args[1], typeName: "Swift.Encoder", as: Swift.Encoder.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    try receiver.encode(to: encoder)
    return .bool(true)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.encode(to:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (to: Swift.Encoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.encode(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args) }
    throw VMError.unsupported("Locale.encode(to:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_identifier_u0028___u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.identifier(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let type: Foundation.Locale.IdentifierType = try vm.withHost(args[1], typeName: "Foundation.Locale.IdentifierType", as: Foundation.Locale.IdentifierType.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.identifier(type)
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_identifier_u0028___u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) {
            return try Host_Foundation_u002E_Locale_identifier_u0028___u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.identifier(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (Foundation.Locale.IdentifierType)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.identifier(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_identifier_u0028___u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_identifier_u0028___u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType(vm: &vm, args) }
    throw VMError.unsupported("Locale.identifier(_:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_identifier_u0028___u003A_from_u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Locale.identifier(_:from:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let type: Foundation.Locale.IdentifierType = try vm.withHost(args[1], typeName: "Foundation.Locale.IdentifierType", as: Foundation.Locale.IdentifierType.self) { host in
        host
    }
    let string = try args[2].expectString("string")
    let result = Foundation.Locale.identifier(type, from: string)
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_identifier_u0028___u003A_from_u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) {
            return try Host_Foundation_u002E_Locale_identifier_u0028___u003A_from_u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType__Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.identifier(_:from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (Foundation.Locale.IdentifierType, from: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.identifier(_:from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_identifier_u0028___u003A_from_u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_identifier_u0028___u003A_from_u003A__u0029___Foundation_u002E_Locale_u002E_IdentifierType__Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.identifier(_:from:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_identifier_u0028_fromComponents_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.identifier(fromComponents:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    guard case let .dict(components_dictBox) = args[1] else { throw VMError.typeError("components expects Swift.Dictionary<Swift.String,Swift.String>") }
    var components_dictValue: Swift.Dictionary<Swift.String,Swift.String> = [:]
    for (rawKey, rawValue) in components_dictBox.storage {
        let components_value = try rawValue.expectString("components[\(rawKey)]")
        components_dictValue[rawKey] = components_value
    }
    let components = components_dictValue
    let result = Foundation.Locale.identifier(fromComponents: components)
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_identifier_u0028_fromComponents_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_identifier_u0028_fromComponents_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.identifier(fromComponents:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (fromComponents: Swift.Dictionary<Swift.String,Swift.String>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.identifier(fromComponents:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_identifier_u0028_fromComponents_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_identifier_u0028_fromComponents_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Locale.identifier(fromComponents:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_identifier_u0028_fromWindowsLocaleCode_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.identifier(fromWindowsLocaleCode:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let code = try args[1].expectInt("code")
    let result = Foundation.Locale.identifier(fromWindowsLocaleCode: code)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_identifier_u0028_fromWindowsLocaleCode_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_identifier_u0028_fromWindowsLocaleCode_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.identifier(fromWindowsLocaleCode:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (fromWindowsLocaleCode: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.identifier(fromWindowsLocaleCode:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_identifier_u0028_fromWindowsLocaleCode_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_identifier_u0028_fromWindowsLocaleCode_u003A__u0029___Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Locale.identifier(fromWindowsLocaleCode:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_init_u0028_components_u003A__u0029___Foundation_u002E_Locale_u002E_Components(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.init(components:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let components: Foundation.Locale.Components = try vm.withHost(args[1], typeName: "Foundation.Locale.Components", as: Foundation.Locale.Components.self) { host in
        host
    }
    let result = Foundation.Locale(components: components)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_init_u0028_components_u003A__u0029___Foundation_u002E_Locale_u002E_Components(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) {
            return try Host_Foundation_u002E_Locale_init_u0028_components_u003A__u0029___Foundation_u002E_Locale_u002E_Components(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.init(components:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (components: Foundation.Locale.Components)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.init(components:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_init_u0028_components_u003A__u0029___Foundation_u002E_Locale_u002E_Components(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_init_u0028_components_u003A__u0029___Foundation_u002E_Locale_u002E_Components(vm: &vm, args) }
    throw VMError.unsupported("Locale.init(components:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.init(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let decoder: Swift.Decoder = try vm.withHost(args[1], typeName: "Swift.Decoder", as: Swift.Decoder.self) { host in
        host
    }
    let result = try Foundation.Locale(from: decoder)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.init(from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (from: Swift.Decoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.init(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args) }
    throw VMError.unsupported("Locale.init(from:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.init(identifier:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let identifier = try args[1].expectString("identifier")
    let result = Foundation.Locale(identifier: identifier)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.init(identifier:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (identifier: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.init(identifier:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.init(identifier:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_init_u0028_languageCode_u003A_script_u003A_languageRegion_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_LanguageCode_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Script_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Region_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Locale.init(languageCode:script:languageRegion:) expects 3 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    var languageCode: Foundation.Locale.LanguageCode? = nil
    if case .nilValue = args[1] {
        languageCode = nil
    } else {
        languageCode = try vm.withHost(args[1], typeName: "Foundation.Locale.LanguageCode", as: Foundation.Locale.LanguageCode.self) { host in
            host
        }
    }
    var script: Foundation.Locale.Script? = nil
    if case .nilValue = args[2] {
        script = nil
    } else {
        script = try vm.withHost(args[2], typeName: "Foundation.Locale.Script", as: Foundation.Locale.Script.self) { host in
            host
        }
    }
    var languageRegion: Foundation.Locale.Region? = nil
    if case .nilValue = args[3] {
        languageRegion = nil
    } else {
        languageRegion = try vm.withHost(args[3], typeName: "Foundation.Locale.Region", as: Foundation.Locale.Region.self) { host in
            host
        }
    }
    let result = Foundation.Locale(languageCode: languageCode, script: script, languageRegion: languageRegion)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_init_u0028_languageCode_u003A_script_u003A_languageRegion_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_LanguageCode_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Script_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Region_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) {
            return try Host_Foundation_u002E_Locale_init_u0028_languageCode_u003A_script_u003A_languageRegion_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_LanguageCode_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Script_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Region_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.init(languageCode:script:languageRegion:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (languageCode: Swift.Optional<Foundation.Locale.LanguageCode>, script: Swift.Optional<Foundation.Locale.Script>, languageRegion: Swift.Optional<Foundation.Locale.Region>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.init(languageCode:script:languageRegion:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_init_u0028_languageCode_u003A_script_u003A_languageRegion_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_LanguageCode_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Script_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Region_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_init_u0028_languageCode_u003A_script_u003A_languageRegion_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_LanguageCode_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Script_u003E___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u002E_Region_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Locale.init(languageCode:script:languageRegion:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_init_u0028_languageComponents_u003A__u0029___Foundation_u002E_Locale_u002E_Language_u002E_Components(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.init(languageComponents:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let languageComponents: Foundation.Locale.Language.Components = try vm.withHost(args[1], typeName: "Foundation.Locale.Language.Components", as: Foundation.Locale.Language.Components.self) { host in
        host
    }
    let result = Foundation.Locale(languageComponents: languageComponents)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_init_u0028_languageComponents_u003A__u0029___Foundation_u002E_Locale_u002E_Language_u002E_Components(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) {
            return try Host_Foundation_u002E_Locale_init_u0028_languageComponents_u003A__u0029___Foundation_u002E_Locale_u002E_Language_u002E_Components(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.init(languageComponents:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (languageComponents: Foundation.Locale.Language.Components)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.init(languageComponents:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_init_u0028_languageComponents_u003A__u0029___Foundation_u002E_Locale_u002E_Language_u002E_Components(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_init_u0028_languageComponents_u003A__u0029___Foundation_u002E_Locale_u002E_Language_u002E_Components(vm: &vm, args) }
    throw VMError.unsupported("Locale.init(languageComponents:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
@available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
@available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
@available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
public func Host_Foundation_u002E_Locale_lineDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.lineDirection(forLanguage:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let isoLangCode = try args[1].expectString("isoLangCode")
    let result = Foundation.Locale.lineDirection(forLanguage: isoLangCode)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
@available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
@available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
@available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
public func HostDispatcher_Foundation_u002E_Locale_lineDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_lineDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.lineDirection(forLanguage:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forLanguage: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.lineDirection(forLanguage:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_lineDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_lineDirection_u0028_forLanguage_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.lineDirection(forLanguage:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Identifier(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(for:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let calendarIdentifier: Foundation.Calendar.Identifier = try vm.withHost(args[1], typeName: "Foundation.Calendar.Identifier", as: Foundation.Calendar.Identifier.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(for: calendarIdentifier)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Identifier(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Identifier(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(for:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (for: Foundation.Calendar.Identifier)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(for:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Identifier(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_for_u003A__u0029___Foundation_u002E_Calendar_u002E_Identifier(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(for:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_forCollationIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(forCollationIdentifier:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let collationIdentifier = try args[1].expectString("collationIdentifier")
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(forCollationIdentifier: collationIdentifier)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCollationIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_forCollationIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(forCollationIdentifier:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forCollationIdentifier: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(forCollationIdentifier:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCollationIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCollationIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(forCollationIdentifier:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_forCollatorIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(forCollatorIdentifier:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let collatorIdentifier = try args[1].expectString("collatorIdentifier")
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(forCollatorIdentifier: collatorIdentifier)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCollatorIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_forCollatorIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(forCollatorIdentifier:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forCollatorIdentifier: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(forCollatorIdentifier:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCollatorIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCollatorIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(forCollatorIdentifier:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_forCurrencyCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(forCurrencyCode:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let currencyCode = try args[1].expectString("currencyCode")
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(forCurrencyCode: currencyCode)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCurrencyCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_forCurrencyCode_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(forCurrencyCode:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forCurrencyCode: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(forCurrencyCode:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCurrencyCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forCurrencyCode_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(forCurrencyCode:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_forIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(forIdentifier:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let identifier = try args[1].expectString("identifier")
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(forIdentifier: identifier)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_forIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(forIdentifier:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forIdentifier: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(forIdentifier:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(forIdentifier:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_forLanguageCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(forLanguageCode:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let languageCode = try args[1].expectString("languageCode")
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(forLanguageCode: languageCode)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forLanguageCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_forLanguageCode_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(forLanguageCode:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forLanguageCode: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(forLanguageCode:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forLanguageCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forLanguageCode_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(forLanguageCode:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_forRegionCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(forRegionCode:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let regionCode = try args[1].expectString("regionCode")
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(forRegionCode: regionCode)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forRegionCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_forRegionCode_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(forRegionCode:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forRegionCode: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(forRegionCode:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forRegionCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forRegionCode_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(forRegionCode:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_forScriptCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(forScriptCode:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let scriptCode = try args[1].expectString("scriptCode")
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(forScriptCode: scriptCode)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forScriptCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_forScriptCode_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(forScriptCode:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forScriptCode: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(forScriptCode:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forScriptCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forScriptCode_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(forScriptCode:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_localizedString_u0028_forVariantCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.localizedString(forVariantCode:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let variantCode = try args[1].expectString("variantCode")
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.localizedString(forVariantCode: variantCode)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forVariantCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_localizedString_u0028_forVariantCode_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.localizedString(forVariantCode:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (forVariantCode: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.localizedString(forVariantCode:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forVariantCode_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_localizedString_u0028_forVariantCode_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.localizedString(forVariantCode:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_windowsLocaleCode_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Locale.windowsLocaleCode(fromIdentifier:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let identifier = try args[1].expectString("identifier")
    let result = Foundation.Locale.windowsLocaleCode(fromIdentifier: identifier)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_windowsLocaleCode_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Locale") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Locale_windowsLocaleCode_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Locale.windowsLocaleCode(fromIdentifier:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Locale (fromIdentifier: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Locale.windowsLocaleCode(fromIdentifier:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_windowsLocaleCode_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_windowsLocaleCode_u0028_fromIdentifier_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("Locale.windowsLocaleCode(fromIdentifier:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_alternateQuotationBeginDelimiter_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.alternateQuotationBeginDelimiter expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.alternateQuotationBeginDelimiter
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_alternateQuotationBeginDelimiter(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_alternateQuotationBeginDelimiter_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.alternateQuotationBeginDelimiter is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.alternateQuotationBeginDelimiter has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_alternateQuotationBeginDelimiter(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_alternateQuotationBeginDelimiter(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.alternateQuotationBeginDelimiter is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_alternateQuotationEndDelimiter_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.alternateQuotationEndDelimiter expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.alternateQuotationEndDelimiter
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_alternateQuotationEndDelimiter(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_alternateQuotationEndDelimiter_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.alternateQuotationEndDelimiter is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.alternateQuotationEndDelimiter has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_alternateQuotationEndDelimiter(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_alternateQuotationEndDelimiter(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.alternateQuotationEndDelimiter is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_autoupdatingCurrent_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.autoupdatingCurrent expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.autoupdatingCurrent
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_autoupdatingCurrent(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_autoupdatingCurrent_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.autoupdatingCurrent is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.autoupdatingCurrent has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_autoupdatingCurrent(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_autoupdatingCurrent(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.autoupdatingCurrent is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_availableIdentifiers_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.availableIdentifiers expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.availableIdentifiers
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_availableIdentifiers(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_availableIdentifiers_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.availableIdentifiers is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.availableIdentifiers has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_availableIdentifiers(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_availableIdentifiers(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.availableIdentifiers is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_availableNumberingSystems_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.availableNumberingSystems expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.availableNumberingSystems
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "NumberingSystem")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_availableNumberingSystems(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_availableNumberingSystems_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.availableNumberingSystems is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.availableNumberingSystems has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_availableNumberingSystems(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_availableNumberingSystems(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.availableNumberingSystems is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_calendar_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.calendar expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.calendar
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_calendar_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.calendar is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.calendar has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_calendar(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_calendar(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.calendar is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_collation_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.collation expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.collation
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_collation(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_collation_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.collation is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.collation has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_collation(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_collation(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.collation is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "collation.identifier")
@available(iOS, deprecated: 16, renamed: "collation.identifier")
@available(tvOS, deprecated: 16, renamed: "collation.identifier")
@available(watchOS, deprecated: 9, renamed: "collation.identifier")
public func Host_Foundation_u002E_Locale_collationIdentifier_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.collationIdentifier expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.collationIdentifier
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "collation.identifier")
@available(iOS, deprecated: 16, renamed: "collation.identifier")
@available(tvOS, deprecated: 16, renamed: "collation.identifier")
@available(watchOS, deprecated: 9, renamed: "collation.identifier")
public func HostDispatcher_Foundation_u002E_Locale_collationIdentifier(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_collationIdentifier_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.collationIdentifier is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.collationIdentifier has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_collationIdentifier(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_collationIdentifier(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.collationIdentifier is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_collatorIdentifier_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.collatorIdentifier expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.collatorIdentifier
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_collatorIdentifier(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_collatorIdentifier_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.collatorIdentifier is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.collatorIdentifier has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_collatorIdentifier(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_collatorIdentifier(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.collatorIdentifier is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_commonISOCurrencyCodes_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.commonISOCurrencyCodes expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.commonISOCurrencyCodes
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_commonISOCurrencyCodes(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_commonISOCurrencyCodes_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.commonISOCurrencyCodes is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.commonISOCurrencyCodes has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_commonISOCurrencyCodes(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_commonISOCurrencyCodes(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.commonISOCurrencyCodes is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_currency_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.currency expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.currency
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Locale"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_currency(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_currency_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.currency is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.currency has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_currency(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_currency(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.currency is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "currency.identifier")
@available(iOS, deprecated: 16, renamed: "currency.identifier")
@available(tvOS, deprecated: 16, renamed: "currency.identifier")
@available(watchOS, deprecated: 9, renamed: "currency.identifier")
public func Host_Foundation_u002E_Locale_currencyCode_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.currencyCode expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.currencyCode
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "currency.identifier")
@available(iOS, deprecated: 16, renamed: "currency.identifier")
@available(tvOS, deprecated: 16, renamed: "currency.identifier")
@available(watchOS, deprecated: 9, renamed: "currency.identifier")
public func HostDispatcher_Foundation_u002E_Locale_currencyCode(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_currencyCode_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.currencyCode is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.currencyCode has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_currencyCode(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_currencyCode(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.currencyCode is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_currencySymbol_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.currencySymbol expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.currencySymbol
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_currencySymbol(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_currencySymbol_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.currencySymbol is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.currencySymbol has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_currencySymbol(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_currencySymbol(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.currencySymbol is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_current_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.current expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.current
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_current(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_current_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.current is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.current has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_current(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_current(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.current is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_customMirror_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.customMirror is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_customMirror(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.customMirror is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_debugDescription_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.debugDescription is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_debugDescription(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.debugDescription is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_decimalSeparator_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.decimalSeparator expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.decimalSeparator
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_decimalSeparator(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_decimalSeparator_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.decimalSeparator is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.decimalSeparator has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_decimalSeparator(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_decimalSeparator(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.decimalSeparator is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_description_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.description is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_description(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_description(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.description is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_exemplarCharacterSet_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.exemplarCharacterSet expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.exemplarCharacterSet
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Locale"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_exemplarCharacterSet(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_exemplarCharacterSet_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.exemplarCharacterSet is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.exemplarCharacterSet has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_exemplarCharacterSet(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_exemplarCharacterSet(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.exemplarCharacterSet is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_firstDayOfWeek_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.firstDayOfWeek expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.firstDayOfWeek
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_firstDayOfWeek(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_firstDayOfWeek_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.firstDayOfWeek is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.firstDayOfWeek has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_firstDayOfWeek(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_firstDayOfWeek(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.firstDayOfWeek is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_groupingSeparator_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.groupingSeparator expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.groupingSeparator
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_groupingSeparator(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_groupingSeparator_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.groupingSeparator is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.groupingSeparator has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_groupingSeparator(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_groupingSeparator(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.groupingSeparator is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_hashValue_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.hashValue is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_hashValue(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.hashValue is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_hourCycle_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.hourCycle expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.hourCycle
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_hourCycle(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_hourCycle_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.hourCycle is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.hourCycle has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_hourCycle(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_hourCycle(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.hourCycle is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_identifier_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.identifier expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.identifier
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_identifier(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_identifier_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.identifier is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.identifier has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_identifier(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_identifier(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.identifier is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Currency.isoCurrencies` instead")
@available(iOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
@available(tvOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
@available(watchOS, deprecated: 9, message: "Use `Locale.Currency.isoCurrencies` instead")
public func Host_Foundation_u002E_Locale_isoCurrencyCodes_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.isoCurrencyCodes expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.isoCurrencyCodes
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Currency.isoCurrencies` instead")
@available(iOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
@available(tvOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
@available(watchOS, deprecated: 9, message: "Use `Locale.Currency.isoCurrencies` instead")
public func HostDispatcher_Foundation_u002E_Locale_isoCurrencyCodes(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_isoCurrencyCodes_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.isoCurrencyCodes is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.isoCurrencyCodes has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_isoCurrencyCodes(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_isoCurrencyCodes(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.isoCurrencyCodes is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
@available(iOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
@available(tvOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
@available(watchOS, deprecated: 9, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
public func Host_Foundation_u002E_Locale_isoLanguageCodes_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.isoLanguageCodes expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.isoLanguageCodes
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
@available(iOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
@available(tvOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
@available(watchOS, deprecated: 9, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
public func HostDispatcher_Foundation_u002E_Locale_isoLanguageCodes(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_isoLanguageCodes_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.isoLanguageCodes is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.isoLanguageCodes has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_isoLanguageCodes(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_isoLanguageCodes(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.isoLanguageCodes is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Region.isoRegions` instead")
@available(iOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
@available(tvOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
@available(watchOS, deprecated: 9, message: "Use `Locale.Region.isoRegions` instead")
public func Host_Foundation_u002E_Locale_isoRegionCodes_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.isoRegionCodes expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.isoRegionCodes
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `Locale.Region.isoRegions` instead")
@available(iOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
@available(tvOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
@available(watchOS, deprecated: 9, message: "Use `Locale.Region.isoRegions` instead")
public func HostDispatcher_Foundation_u002E_Locale_isoRegionCodes(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_isoRegionCodes_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.isoRegionCodes is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.isoRegionCodes has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_isoRegionCodes(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_isoRegionCodes(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.isoRegionCodes is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_language_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.language expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.language
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_language(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_language_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.language is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.language has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_language(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_language(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.language is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "language.languageCode.identifier")
@available(iOS, deprecated: 16, renamed: "language.languageCode.identifier")
@available(tvOS, deprecated: 16, renamed: "language.languageCode.identifier")
@available(watchOS, deprecated: 9, renamed: "language.languageCode.identifier")
public func Host_Foundation_u002E_Locale_languageCode_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.languageCode expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.languageCode
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "language.languageCode.identifier")
@available(iOS, deprecated: 16, renamed: "language.languageCode.identifier")
@available(tvOS, deprecated: 16, renamed: "language.languageCode.identifier")
@available(watchOS, deprecated: 9, renamed: "language.languageCode.identifier")
public func HostDispatcher_Foundation_u002E_Locale_languageCode(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_languageCode_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.languageCode is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.languageCode has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_languageCode(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_languageCode(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.languageCode is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_measurementSystem_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.measurementSystem expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.measurementSystem
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_measurementSystem(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_measurementSystem_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.measurementSystem is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.measurementSystem has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_measurementSystem(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_measurementSystem(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.measurementSystem is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_numberingSystem_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.numberingSystem expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.numberingSystem
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Locale"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_numberingSystem(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_numberingSystem_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.numberingSystem is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.numberingSystem has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_numberingSystem(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_numberingSystem(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.numberingSystem is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_preferredLanguages_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.preferredLanguages expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.preferredLanguages
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_preferredLanguages(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_preferredLanguages_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.preferredLanguages is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.preferredLanguages has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_preferredLanguages(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_preferredLanguages(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.preferredLanguages is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public func Host_Foundation_u002E_Locale_preferredLocales_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.preferredLocales expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Locale metatype") }
    let result = Foundation.Locale.preferredLocales
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Locale")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public func HostDispatcher_Foundation_u002E_Locale_preferredLocales(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .metatype:
            if #available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *) { return try Host_Foundation_u002E_Locale_preferredLocales_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.preferredLocales is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.preferredLocales has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_preferredLocales(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *) { return try HostDispatcher_Foundation_u002E_Locale_preferredLocales(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.preferredLocales is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_quotationBeginDelimiter_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.quotationBeginDelimiter expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.quotationBeginDelimiter
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_quotationBeginDelimiter(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_quotationBeginDelimiter_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.quotationBeginDelimiter is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.quotationBeginDelimiter has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_quotationBeginDelimiter(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_quotationBeginDelimiter(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.quotationBeginDelimiter is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Locale_quotationEndDelimiter_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.quotationEndDelimiter expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.quotationEndDelimiter
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Locale_quotationEndDelimiter(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_quotationEndDelimiter_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.quotationEndDelimiter is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.quotationEndDelimiter has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_quotationEndDelimiter(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_quotationEndDelimiter(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.quotationEndDelimiter is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_region_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.region expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.region
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Locale"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_region(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_region_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.region is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.region has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_region(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_region(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.region is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "region.identifier")
@available(iOS, deprecated: 16, renamed: "region.identifier")
@available(tvOS, deprecated: 16, renamed: "region.identifier")
@available(watchOS, deprecated: 9, renamed: "region.identifier")
public func Host_Foundation_u002E_Locale_regionCode_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.regionCode expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.regionCode
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "region.identifier")
@available(iOS, deprecated: 16, renamed: "region.identifier")
@available(tvOS, deprecated: 16, renamed: "region.identifier")
@available(watchOS, deprecated: 9, renamed: "region.identifier")
public func HostDispatcher_Foundation_u002E_Locale_regionCode(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_regionCode_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.regionCode is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.regionCode has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_regionCode(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_regionCode(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.regionCode is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "language.script.identifier")
@available(iOS, deprecated: 16, renamed: "language.script.identifier")
@available(tvOS, deprecated: 16, renamed: "language.script.identifier")
@available(watchOS, deprecated: 9, renamed: "language.script.identifier")
public func Host_Foundation_u002E_Locale_scriptCode_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.scriptCode expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.scriptCode
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "language.script.identifier")
@available(iOS, deprecated: 16, renamed: "language.script.identifier")
@available(tvOS, deprecated: 16, renamed: "language.script.identifier")
@available(watchOS, deprecated: 9, renamed: "language.script.identifier")
public func HostDispatcher_Foundation_u002E_Locale_scriptCode(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_scriptCode_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.scriptCode is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.scriptCode has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_scriptCode(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_scriptCode(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.scriptCode is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_subdivision_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.subdivision expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.subdivision
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Locale"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_subdivision(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_subdivision_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.subdivision is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.subdivision has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_subdivision(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_subdivision(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.subdivision is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_timeZone_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.timeZone expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.timeZone
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Locale"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_timeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_timeZone_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.timeZone is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.timeZone has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_timeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_timeZone(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.timeZone is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `measurementSystem` instead")
@available(iOS, deprecated: 16, message: "Use `measurementSystem` instead")
@available(tvOS, deprecated: 16, message: "Use `measurementSystem` instead")
@available(watchOS, deprecated: 9, message: "Use `measurementSystem` instead")
public func Host_Foundation_u002E_Locale_usesMetricSystem_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.usesMetricSystem expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.usesMetricSystem
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, message: "Use `measurementSystem` instead")
@available(iOS, deprecated: 16, message: "Use `measurementSystem` instead")
@available(tvOS, deprecated: 16, message: "Use `measurementSystem` instead")
@available(watchOS, deprecated: 9, message: "Use `measurementSystem` instead")
public func HostDispatcher_Foundation_u002E_Locale_usesMetricSystem(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_usesMetricSystem_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.usesMetricSystem is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.usesMetricSystem has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_usesMetricSystem(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_usesMetricSystem(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.usesMetricSystem is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_Locale_variant_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.variant expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.variant
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Locale"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_Locale_variant(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_Locale_variant_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.variant is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.variant has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_variant(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_Locale_variant(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.variant is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "variant.identifier")
@available(iOS, deprecated: 16, renamed: "variant.identifier")
@available(tvOS, deprecated: 16, renamed: "variant.identifier")
@available(watchOS, deprecated: 9, renamed: "variant.identifier")
public func Host_Foundation_u002E_Locale_variantCode_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Locale.variantCode expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Locale host") }
    let receiver = try vm.withHost(args[0], typeName: "Locale", as: Foundation.Locale.self) { host in
        host
    }
    let result = receiver.variantCode
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS, deprecated: 13, renamed: "variant.identifier")
@available(iOS, deprecated: 16, renamed: "variant.identifier")
@available(tvOS, deprecated: 16, renamed: "variant.identifier")
@available(watchOS, deprecated: 9, renamed: "variant.identifier")
public func HostDispatcher_Foundation_u002E_Locale_variantCode(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Locale") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Locale_variantCode_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Locale.variantCode is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Locale ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Locale.variantCode has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Locale_variantCode(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Locale_variantCode(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Locale.variantCode is not available on this platform")
}

