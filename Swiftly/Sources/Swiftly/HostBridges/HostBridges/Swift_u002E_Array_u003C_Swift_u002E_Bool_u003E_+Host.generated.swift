// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Array<Swift.Bool>

public func Host_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Bool>") }
    var lhs_arrayValue: Swift.Array<Swift.Bool> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectBool("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Bool>") }
    var rhs_arrayValue: Swift.Array<Swift.Bool> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectBool("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Double>") }
    var lhs_arrayValue: Swift.Array<Swift.Double> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectDouble("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Double>") }
    var rhs_arrayValue: Swift.Array<Swift.Double> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectDouble("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.Int>") }
    var lhs_arrayValue: Swift.Array<Swift.Int> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectInt("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.Int>") }
    var rhs_arrayValue: Swift.Array<Swift.Int> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectInt("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Array.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> metatype") }
    guard case let .array(lhs_arrayBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Array<Swift.String>") }
    var lhs_arrayValue: Swift.Array<Swift.String> = []
    lhs_arrayValue.reserveCapacity(lhs_arrayBox.elements.count)
    for (index, elementValue) in lhs_arrayBox.elements.enumerated() {
        let lhs_element = try elementValue.expectString("lhs[\(index)]")
        lhs_arrayValue.append(lhs_element)
    }
    let lhs = lhs_arrayValue
    guard case let .array(rhs_arrayBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Array<Swift.String>") }
    var rhs_arrayValue: Swift.Array<Swift.String> = []
    rhs_arrayValue.reserveCapacity(rhs_arrayBox.elements.count)
    for (index, elementValue) in rhs_arrayBox.elements.enumerated() {
        let rhs_element = try elementValue.expectString("rhs[\(index)]")
        rhs_arrayValue.append(rhs_element)
    }
    let rhs = rhs_arrayValue
    let result = lhs == rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Element_u003E___Swift_u002E_Array_u003C_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E___Element_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E___Element_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E___Element_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
        return try Host_Swift_u002E_Array_u003C_Element_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Swift_u002E_Array_u003C_Swift_u002E_String_u003E___Element_Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Array<Swift.Bool> (lhs: Swift.Array<Swift.Bool>, rhs: Swift.Array<Swift.Bool>)",
        "  - Swift.Array<Swift.Double> (lhs: Swift.Array<Swift.Double>, rhs: Swift.Array<Swift.Double>)",
        "  - Swift.Array<Swift.Int> (lhs: Swift.Array<Swift.Int>, rhs: Swift.Array<Swift.Int>)",
        "  - Swift.Array<Swift.String> (lhs: Swift.Array<Swift.String>, rhs: Swift.Array<Swift.String>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Array.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Array._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Swift.Bool> ()",
            "  - Swift.Array<Swift.Double> ()",
            "  - Swift.Array<Swift.Int> ()",
            "  - Swift.Array<Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array._toCustomAnyHashable() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E___toCustomAnyHashable_u0028__u0029___Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array._toCustomAnyHashable()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let element = try args[1].expectBool("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.contains(element)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let element = try args[1].expectDouble("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.contains(element)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let element = try args[1].expectInt("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.contains(element)
    return .bool(result)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.contains(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let element = try args[1].expectString("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.contains(element)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Swift.Bool> (Swift.Array<Swift.Bool>.Element)",
            "  - Swift.Array<Swift.Double> (Swift.Array<Swift.Double>.Element)",
            "  - Swift.Array<Swift.Int> (Swift.Array<Swift.Int>.Element)",
            "  - Swift.Array<Swift.String> (Swift.Array<Swift.String>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.contains(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__contains_u0028___u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.contains(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.firstIndex(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let element = try args[1].expectBool("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.firstIndex(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.firstIndex(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let element = try args[1].expectDouble("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.firstIndex(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.firstIndex(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let element = try args[1].expectInt("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.firstIndex(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.firstIndex(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let element = try args[1].expectString("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.firstIndex(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Swift.Bool> (of: Swift.Array<Swift.Bool>.Element)",
            "  - Swift.Array<Swift.Double> (of: Swift.Array<Swift.Double>.Element)",
            "  - Swift.Array<Swift.Int> (of: Swift.Array<Swift.Int>.Element)",
            "  - Swift.Array<Swift.String> (of: Swift.Array<Swift.String>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.firstIndex(of:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__firstIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.firstIndex(of:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

@available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let element = try args[1].expectBool("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

@available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let element = try args[1].expectDouble("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

@available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let element = try args[1].expectInt("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

@available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
public func Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.index(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let element = try args[1].expectString("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.index(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.String>"))
    case .none:
        return .nilValue
    }
}

@available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Swift.Bool> (of: Swift.Array<Swift.Bool>.Element)",
            "  - Swift.Array<Swift.Double> (of: Swift.Array<Swift.Double>.Element)",
            "  - Swift.Array<Swift.Int> (of: Swift.Array<Swift.Int>.Element)",
            "  - Swift.Array<Swift.String> (of: Swift.Array<Swift.String>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.index(of:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.index(of:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    if true { return try HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__index_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: &vm, args) }
    throw VMError.unsupported("Array.index(of:) is not available on this platform")
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.indices(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let element = try args[1].expectBool("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.indices(of: element)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Bool>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.indices(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let element = try args[1].expectDouble("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.indices(of: element)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Double>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.indices(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let element = try args[1].expectInt("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.indices(of: element)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.Int>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.indices(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let element = try args[1].expectString("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.indices(of: element)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Array<Swift.String>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.indices(of:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.indices(of:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.indices(of:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, args)
            } else {
                throw VMError.unsupported("Array.indices(of:) is not available on this platform")
            }
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Swift.Bool> (of: Swift.Array<Swift.Bool>.Element)",
            "  - Swift.Array<Swift.Double> (of: Swift.Array<Swift.Double>.Element)",
            "  - Swift.Array<Swift.Int> (of: Swift.Array<Swift.Int>.Element)",
            "  - Swift.Array<Swift.String> (of: Swift.Array<Swift.String>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.indices(of:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.indices(of:) is not available on this platform")
            }
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.indices(of:) is not available on this platform")
            }
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.indices(of:) is not available on this platform")
            }
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Array.indices(of:) is not available on this platform")
            }
        }
        throw VMError.typeError("Array element type not supported for Array.indices(of:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) { return try HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__indices_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: &vm, args) }
    throw VMError.unsupported("Array.indices(of:) is not available on this platform")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.lastIndex(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let element = try args[1].expectBool("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.lastIndex(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.lastIndex(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let element = try args[1].expectDouble("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.lastIndex(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.lastIndex(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let element = try args[1].expectInt("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.lastIndex(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Array.lastIndex(of:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let element = try args[1].expectString("element")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.lastIndex(of: element)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Array<Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Swift.Bool> (of: Swift.Array<Swift.Bool>.Element)",
            "  - Swift.Array<Swift.Double> (of: Swift.Array<Swift.Double>.Element)",
            "  - Swift.Array<Swift.Int> (of: Swift.Array<Swift.Int>.Element)",
            "  - Swift.Array<Swift.String> (of: Swift.Array<Swift.String>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.lastIndex(of:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__lastIndex_u0028_of_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.lastIndex(of:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.split(separator:maxSplits:omittingEmptySubsequences:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Bool> host") }
    let separator = try args[1].expectBool("separator")
    let maxSplits = try args[2].expectInt("maxSplits")
    let omittingEmptySubsequences = try args[3].expectBool("omittingEmptySubsequences")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Bool>", as: Swift.Array<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.split(separator: separator, maxSplits: maxSplits, omittingEmptySubsequences: omittingEmptySubsequences)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Array<Swift.Bool>.SubSequence")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.split(separator:maxSplits:omittingEmptySubsequences:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Double> host") }
    let separator = try args[1].expectDouble("separator")
    let maxSplits = try args[2].expectInt("maxSplits")
    let omittingEmptySubsequences = try args[3].expectBool("omittingEmptySubsequences")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Double>", as: Swift.Array<Swift.Double>.self) { host in
        host
    }
    let result = receiver.split(separator: separator, maxSplits: maxSplits, omittingEmptySubsequences: omittingEmptySubsequences)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Array<Swift.Double>.SubSequence")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.split(separator:maxSplits:omittingEmptySubsequences:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.Int> host") }
    let separator = try args[1].expectInt("separator")
    let maxSplits = try args[2].expectInt("maxSplits")
    let omittingEmptySubsequences = try args[3].expectBool("omittingEmptySubsequences")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.Int>", as: Swift.Array<Swift.Int>.self) { host in
        host
    }
    let result = receiver.split(separator: separator, maxSplits: maxSplits, omittingEmptySubsequences: omittingEmptySubsequences)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Array<Swift.Int>.SubSequence")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Array.split(separator:maxSplits:omittingEmptySubsequences:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Array<Swift.String> host") }
    let separator = try args[1].expectString("separator")
    let maxSplits = try args[2].expectInt("maxSplits")
    let omittingEmptySubsequences = try args[3].expectBool("omittingEmptySubsequences")
    let receiver = try vm.withHost(args[0], typeName: "Array<Swift.String>", as: Swift.Array<Swift.String>.self) { host in
        host
    }
    let result = receiver.split(separator: separator, maxSplits: maxSplits, omittingEmptySubsequences: omittingEmptySubsequences)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Array<Swift.String>.SubSequence")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Element_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Bool>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Double>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.Int>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Array<Swift.String>") {
            return try Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Array<Swift.Bool> (separator: Swift.Array<Swift.Bool>.Element, maxSplits: Swift.Int, omittingEmptySubsequences: Swift.Bool)",
            "  - Swift.Array<Swift.Double> (separator: Swift.Array<Swift.Double>.Element, maxSplits: Swift.Int, omittingEmptySubsequences: Swift.Bool)",
            "  - Swift.Array<Swift.Int> (separator: Swift.Array<Swift.Int>.Element, maxSplits: Swift.Int, omittingEmptySubsequences: Swift.Bool)",
            "  - Swift.Array<Swift.String> (separator: Swift.Array<Swift.String>.Element, maxSplits: Swift.Int, omittingEmptySubsequences: Swift.Bool)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Array.split(separator:maxSplits:omittingEmptySubsequences:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native array receiver
    else if case let .array(box) = args[0] {
        guard !box.elements.isEmpty else {
            throw VMError.typeError("Cannot infer element type from empty array")
        }
        // Infer element type from first element
        let sampleElement = box.elements[0]
        
        if case .bool = sampleElement {
            // Convert VM array to host array of Swift.Bool inline
            var hostElements: [Bool] = []
            for element in box.elements {
                guard case let .bool(b) = element else { throw VMError.typeError("Array element is not Bool") }
                hostElements.append(b)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Bool_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleElement {
            // Convert VM array to host array of Swift.Double inline
            var hostElements: [Double] = []
            for element in box.elements {
                guard case let .double(d) = element else { throw VMError.typeError("Array element is not Double") }
                hostElements.append(d)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Double_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleElement {
            // Convert VM array to host array of Swift.Int inline
            var hostElements: [Int] = []
            for element in box.elements {
                guard case let .int(i) = element else { throw VMError.typeError("Array element is not Int") }
                hostElements.append(i)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_Int_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleElement {
            // Convert VM array to host array of Swift.String inline
            var hostElements: [String] = []
            for element in box.elements {
                guard case let .string(s) = element else { throw VMError.typeError("Array element is not String") }
                hostElements.append(s)
            }
            let hostRef = HostRef(box: makeOpaqueBox(hostElements))
            let hostArray = Value.host(hostRef, vm.hostTypeID(named: "Swift.Array<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostArray
        
            // Dispatch to correct specialization based on closure return type
            var closureReturnType: String? = nil
            if args.count > 1, case let .closure(closureHandle) = args[1] {
                closureReturnType = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1).returnType
            }
        
            return try Host_Swift_u002E_Array_u003C_Element_u003E__split_u0028_separator_u003A_maxSplits_u003A_omittingEmptySubsequences_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_String_u003E__u002E_Element__Swift_u002E_Int__Swift_u002E_Bool__Element_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Array element type not supported for Array.split(separator:maxSplits:omittingEmptySubsequences:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Array<Element>")
}

