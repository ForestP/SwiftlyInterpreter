// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Dictionary<Swift.String,Foundation.Data>

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Foundation.Data>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Foundation.Data> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value: Foundation.Data = try vm.withHost(rawValue, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
            host
        }
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Foundation.Data>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Foundation.Data> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value: Foundation.Data = try vm.withHost(rawValue, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
            host
        }
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Swift.Bool>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Swift.Bool> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value = try rawValue.expectBool("lhs[\(rawKey)]")
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Swift.Bool>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Swift.Bool> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value = try rawValue.expectBool("rhs[\(rawKey)]")
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Swift.Double>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Swift.Double> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value = try rawValue.expectDouble("lhs[\(rawKey)]")
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Swift.Double>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Swift.Double> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value = try rawValue.expectDouble("rhs[\(rawKey)]")
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Swift.Int>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Swift.Int> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value = try rawValue.expectInt("lhs[\(rawKey)]")
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Swift.Int>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Swift.Int> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value = try rawValue.expectInt("rhs[\(rawKey)]")
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs != rhs
    return .bool(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Swift.String>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Swift.String> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value = try rawValue.expectString("lhs[\(rawKey)]")
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Swift.String>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Swift.String> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value = try rawValue.expectString("rhs[\(rawKey)]")
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs != rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Dictionary<Swift.String,Foundation.Data> (lhs: Swift.Dictionary<Swift.String,Foundation.Data>, rhs: Swift.Dictionary<Swift.String,Foundation.Data>)",
        "  - Swift.Dictionary<Swift.String,Swift.Bool> (lhs: Swift.Dictionary<Swift.String,Swift.Bool>, rhs: Swift.Dictionary<Swift.String,Swift.Bool>)",
        "  - Swift.Dictionary<Swift.String,Swift.Double> (lhs: Swift.Dictionary<Swift.String,Swift.Double>, rhs: Swift.Dictionary<Swift.String,Swift.Double>)",
        "  - Swift.Dictionary<Swift.String,Swift.Int> (lhs: Swift.Dictionary<Swift.String,Swift.Int>, rhs: Swift.Dictionary<Swift.String,Swift.Int>)",
        "  - Swift.Dictionary<Swift.String,Swift.String> (lhs: Swift.Dictionary<Swift.String,Swift.String>, rhs: Swift.Dictionary<Swift.String,Swift.String>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Dictionary.!=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let ptr: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Foundation.Data>.Element> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Foundation.Data>.Element>", as: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Foundation.Data>.Element>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: ptr)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let ptr: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Bool>.Element> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Bool>.Element>", as: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Bool>.Element>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: ptr)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let ptr: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Double>.Element> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Double>.Element>", as: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Double>.Element>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: ptr)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let ptr: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Int>.Element> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Int>.Element>", as: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Int>.Element>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: ptr)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let ptr: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.String>.Element> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.String>.Element>", as: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.String>.Element>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: ptr)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (initializing: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Foundation.Data>.Element>)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (initializing: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Bool>.Element>)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (initializing: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Double>.Element>)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (initializing: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.Int>.Element>)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (initializing: Swift.UnsafeMutableBufferPointer<Swift.Dictionary<Swift.String,Swift.String>.Element>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary._copyContents(initializing:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary._copyContents(initializing:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
            "  - Swift.Dictionary<Swift.String,Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary._copyToContiguousArray() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___copyToContiguousArray_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary._copyToContiguousArray()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let element: Swift.Dictionary<Swift.String,Foundation.Data>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Element", as: Swift.Dictionary<Swift.String,Foundation.Data>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Bool>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Element", as: Swift.Dictionary<Swift.String,Swift.Bool>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Double>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Element", as: Swift.Dictionary<Swift.String,Swift.Double>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Int>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Element", as: Swift.Dictionary<Swift.String,Swift.Int>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let element: Swift.Dictionary<Swift.String,Swift.String>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Element", as: Swift.Dictionary<Swift.String,Swift.String>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Dictionary<Swift.String,Foundation.Data>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Dictionary<Swift.String,Swift.Bool>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Dictionary<Swift.String,Swift.Double>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Dictionary<Swift.String,Swift.Int>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Dictionary<Swift.String,Swift.String>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary._customContainsEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary._customContainsEquatableElement(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let element: Swift.Dictionary<Swift.String,Foundation.Data>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Element", as: Swift.Dictionary<Swift.String,Foundation.Data>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Bool>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Element", as: Swift.Dictionary<Swift.String,Swift.Bool>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Double>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Element", as: Swift.Dictionary<Swift.String,Swift.Double>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Int>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Element", as: Swift.Dictionary<Swift.String,Swift.Int>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let element: Swift.Dictionary<Swift.String,Swift.String>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Element", as: Swift.Dictionary<Swift.String,Swift.String>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Dictionary<Swift.String,Foundation.Data>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Dictionary<Swift.String,Swift.Bool>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Dictionary<Swift.String,Swift.Double>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Dictionary<Swift.String,Swift.Int>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Dictionary<Swift.String,Swift.String>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary._customIndexOfEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary._customIndexOfEquatableElement(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let element: Swift.Dictionary<Swift.String,Foundation.Data>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Element", as: Swift.Dictionary<Swift.String,Foundation.Data>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Bool>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Element", as: Swift.Dictionary<Swift.String,Swift.Bool>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Double>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Element", as: Swift.Dictionary<Swift.String,Swift.Double>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let element: Swift.Dictionary<Swift.String,Swift.Int>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Element", as: Swift.Dictionary<Swift.String,Swift.Int>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let element: Swift.Dictionary<Swift.String,Swift.String>.Element = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Element", as: Swift.Dictionary<Swift.String,Swift.String>.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Dictionary<Swift.String,Foundation.Data>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Dictionary<Swift.String,Swift.Bool>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Dictionary<Swift.String,Swift.Double>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Dictionary<Swift.String,Swift.Int>.Element)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Dictionary<Swift.String,Swift.String>.Element)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary._customLastIndexOfEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary._customLastIndexOfEquatableElement(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let index: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let bounds: Swift.Range<Swift.Dictionary<Swift.String,Foundation.Data>.Index> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Dictionary<Swift.String,Foundation.Data>.Index>", as: Swift.Range<Swift.Dictionary<Swift.String,Foundation.Data>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let index: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let bounds: Swift.Range<Swift.Dictionary<Swift.String,Swift.Bool>.Index> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Dictionary<Swift.String,Swift.Bool>.Index>", as: Swift.Range<Swift.Dictionary<Swift.String,Swift.Bool>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let index: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let bounds: Swift.Range<Swift.Dictionary<Swift.String,Swift.Double>.Index> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Dictionary<Swift.String,Swift.Double>.Index>", as: Swift.Range<Swift.Dictionary<Swift.String,Swift.Double>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let index: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let bounds: Swift.Range<Swift.Dictionary<Swift.String,Swift.Int>.Index> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Dictionary<Swift.String,Swift.Int>.Index>", as: Swift.Range<Swift.Dictionary<Swift.String,Swift.Int>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let index: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let bounds: Swift.Range<Swift.Dictionary<Swift.String,Swift.String>.Index> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Dictionary<Swift.String,Swift.String>.Index>", as: Swift.Range<Swift.Dictionary<Swift.String,Swift.String>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Dictionary<Swift.String,Foundation.Data>.Index, bounds: Swift.Range<Swift.Dictionary<Swift.String,Foundation.Data>.Index>)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Dictionary<Swift.String,Swift.Bool>.Index, bounds: Swift.Range<Swift.Dictionary<Swift.String,Swift.Bool>.Index>)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Dictionary<Swift.String,Swift.Double>.Index, bounds: Swift.Range<Swift.Dictionary<Swift.String,Swift.Double>.Index>)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Dictionary<Swift.String,Swift.Int>.Index, bounds: Swift.Range<Swift.Dictionary<Swift.String,Swift.Int>.Index>)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Dictionary<Swift.String,Swift.String>.Index, bounds: Swift.Range<Swift.Dictionary<Swift.String,Swift.String>.Index>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary._failEarlyRangeCheck(_:bounds:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary._failEarlyRangeCheck(_:bounds:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (seed: Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (seed: Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (seed: Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (seed: Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (seed: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary._rawHashValue(seed:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary._rawHashValue(seed:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let start: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let end: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[2], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let start: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let end: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[2], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let start: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let end: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[2], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let start: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let end: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[2], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let start: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let end: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[2], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (from: Swift.Dictionary<Swift.String,Foundation.Data>.Index, to: Swift.Dictionary<Swift.String,Foundation.Data>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (from: Swift.Dictionary<Swift.String,Swift.Bool>.Index, to: Swift.Dictionary<Swift.String,Swift.Bool>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (from: Swift.Dictionary<Swift.String,Swift.Double>.Index, to: Swift.Dictionary<Swift.String,Swift.Double>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (from: Swift.Dictionary<Swift.String,Swift.Int>.Index, to: Swift.Dictionary<Swift.String,Swift.Int>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (from: Swift.Dictionary<Swift.String,Swift.String>.Index, to: Swift.Dictionary<Swift.String,Swift.String>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.distance(from:to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.distance(from:to:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.dropFirst(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropFirst_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.dropFirst(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.dropLast(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__dropLast_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.dropLast(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
            "  - Swift.Dictionary<Swift.String,Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.enumerated() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__enumerated_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.enumerated()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let i: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let i: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Dictionary<Swift.String,Foundation.Data>.Index, offsetBy: Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Dictionary<Swift.String,Swift.Bool>.Index, offsetBy: Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Dictionary<Swift.String,Swift.Double>.Index, offsetBy: Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Dictionary<Swift.String,Swift.Int>.Index, offsetBy: Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Dictionary<Swift.String,Swift.String>.Index, offsetBy: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.index(_:offsetBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.index(_:offsetBy:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Dictionary.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let i: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let limit: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[3], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Dictionary.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let limit: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[3], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Dictionary.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let limit: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[3], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Dictionary.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let limit: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[3], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Dictionary.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let i: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let limit: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[3], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Dictionary<Swift.String,Foundation.Data>.Index, offsetBy: Swift.Int, limitedBy: Swift.Dictionary<Swift.String,Foundation.Data>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Dictionary<Swift.String,Swift.Bool>.Index, offsetBy: Swift.Int, limitedBy: Swift.Dictionary<Swift.String,Swift.Bool>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Dictionary<Swift.String,Swift.Double>.Index, offsetBy: Swift.Int, limitedBy: Swift.Dictionary<Swift.String,Swift.Double>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Dictionary<Swift.String,Swift.Int>.Index, offsetBy: Swift.Int, limitedBy: Swift.Dictionary<Swift.String,Swift.Int>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Dictionary<Swift.String,Swift.String>.Index, offsetBy: Swift.Int, limitedBy: Swift.Dictionary<Swift.String,Swift.String>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.index(_:offsetBy:limitedBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Swift_u002E_Int__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.index(_:offsetBy:limitedBy:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let i: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let i: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let i: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (after: Swift.Dictionary<Swift.String,Foundation.Data>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (after: Swift.Dictionary<Swift.String,Swift.Bool>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (after: Swift.Dictionary<Swift.String,Swift.Double>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (after: Swift.Dictionary<Swift.String,Swift.Int>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (after: Swift.Dictionary<Swift.String,Swift.String>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.index(after:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_after_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.index(after:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let key = try args[1].expectString("key")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.index(forKey: key)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let key = try args[1].expectString("key")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.index(forKey: key)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let key = try args[1].expectString("key")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.index(forKey: key)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let key = try args[1].expectString("key")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.index(forKey: key)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.index(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let key = try args[1].expectString("key")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.index(forKey: key)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Key(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (forKey: Swift.String)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.index(forKey:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__index_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.index(forKey:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> metatype") }
    let result = Swift.Dictionary<Swift.String,Foundation.Data>()
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .host(HostRef(box: makeOpaqueBox(result_value_value)), vm.hostTypeID(named: "Data"))
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> metatype") }
    let result = Swift.Dictionary<Swift.String,Swift.Bool>()
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .bool(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> metatype") }
    let result = Swift.Dictionary<Swift.String,Swift.Double>()
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .double(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> metatype") }
    let result = Swift.Dictionary<Swift.String,Swift.Int>()
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .int(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> metatype") }
    let result = Swift.Dictionary<Swift.String,Swift.String>()
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .string(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Dictionary<Swift.String,Foundation.Data> ()",
        "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
        "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
        "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
        "  - Swift.Dictionary<Swift.String,Swift.String> ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Dictionary.init() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.init(minimumCapacity:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> metatype") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    let result = Swift.Dictionary<Swift.String,Foundation.Data>(minimumCapacity: minimumCapacity)
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .host(HostRef(box: makeOpaqueBox(result_value_value)), vm.hostTypeID(named: "Data"))
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.init(minimumCapacity:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> metatype") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    let result = Swift.Dictionary<Swift.String,Swift.Bool>(minimumCapacity: minimumCapacity)
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .bool(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.init(minimumCapacity:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> metatype") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    let result = Swift.Dictionary<Swift.String,Swift.Double>(minimumCapacity: minimumCapacity)
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .double(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.init(minimumCapacity:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> metatype") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    let result = Swift.Dictionary<Swift.String,Swift.Int>(minimumCapacity: minimumCapacity)
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .int(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.init(minimumCapacity:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> metatype") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    let result = Swift.Dictionary<Swift.String,Swift.String>(minimumCapacity: minimumCapacity)
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .string(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__init_u0028_minimumCapacity_u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Dictionary<Swift.String,Foundation.Data> (minimumCapacity: Swift.Int)",
        "  - Swift.Dictionary<Swift.String,Swift.Bool> (minimumCapacity: Swift.Int)",
        "  - Swift.Dictionary<Swift.String,Swift.Double> (minimumCapacity: Swift.Int)",
        "  - Swift.Dictionary<Swift.String,Swift.Int> (minimumCapacity: Swift.Int)",
        "  - Swift.Dictionary<Swift.String,Swift.String> (minimumCapacity: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Dictionary.init(minimumCapacity:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
            "  - Swift.Dictionary<Swift.String,Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.makeIterator() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__makeIterator_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.makeIterator()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.popFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { receiver in
        let result = receiver.popFirst()
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.popFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { receiver in
        let result = receiver.popFirst()
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.popFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { receiver in
        let result = receiver.popFirst()
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.popFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { receiver in
        let result = receiver.popFirst()
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.popFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { receiver in
        let result = receiver.popFirst()
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element)
        case .none:
            return .nilValue
        }
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
            "  - Swift.Dictionary<Swift.String,Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.popFirst() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__popFirst_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.popFirst()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.prefix(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.prefix(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let position: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let position: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let position: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let position: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let position: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (through: Swift.Dictionary<Swift.String,Foundation.Data>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (through: Swift.Dictionary<Swift.String,Swift.Bool>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (through: Swift.Dictionary<Swift.String,Swift.Double>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (through: Swift.Dictionary<Swift.String,Swift.Int>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (through: Swift.Dictionary<Swift.String,Swift.String>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.prefix(through:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_through_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.prefix(through:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let end: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let end: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let end: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let end: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let end: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (upTo: Swift.Dictionary<Swift.String,Foundation.Data>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (upTo: Swift.Dictionary<Swift.String,Swift.Bool>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (upTo: Swift.Dictionary<Swift.String,Swift.Double>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (upTo: Swift.Dictionary<Swift.String,Swift.Int>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (upTo: Swift.Dictionary<Swift.String,Swift.String>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.prefix(upTo:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__prefix_u0028_upTo_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.prefix(upTo:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
            "  - Swift.Dictionary<Swift.String,Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.randomElement() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__randomElement_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.randomElement()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let index: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { receiver in
        let result = receiver.remove(at: index)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Element)
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let index: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { receiver in
        let result = receiver.remove(at: index)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Element)
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let index: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { receiver in
        let result = receiver.remove(at: index)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Element)
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let index: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { receiver in
        let result = receiver.remove(at: index)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Element)
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let index: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element = vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>.Element")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { receiver in
        let result = receiver.remove(at: index)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Element)
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (at: Swift.Dictionary<Swift.String,Foundation.Data>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (at: Swift.Dictionary<Swift.String,Swift.Bool>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (at: Swift.Dictionary<Swift.String,Swift.Double>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (at: Swift.Dictionary<Swift.String,Swift.Int>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (at: Swift.Dictionary<Swift.String,Swift.String>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.remove(at:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__remove_u0028_at_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.remove(at:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (keepingCapacity: Swift.Bool)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (keepingCapacity: Swift.Bool)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (keepingCapacity: Swift.Bool)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (keepingCapacity: Swift.Bool)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (keepingCapacity: Swift.Bool)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.removeAll(keepingCapacity:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.removeAll(keepingCapacity:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeValue(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let key = try args[1].expectString("key")
    let returnHostTypeID_Data = vm.hostTypeID(named: "Data")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { receiver in
        let result = receiver.removeValue(forKey: key)
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Data)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeValue(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let key = try args[1].expectString("key")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { receiver in
        let result = receiver.removeValue(forKey: key)
        switch result {
        case .some(let unwrapped):
            return .bool(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeValue(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let key = try args[1].expectString("key")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { receiver in
        let result = receiver.removeValue(forKey: key)
        switch result {
        case .some(let unwrapped):
            return .double(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeValue(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let key = try args[1].expectString("key")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { receiver in
        let result = receiver.removeValue(forKey: key)
        switch result {
        case .some(let unwrapped):
            return .int(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removeValue(forKey:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let key = try args[1].expectString("key")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { receiver in
        let result = receiver.removeValue(forKey: key)
        switch result {
        case .some(let unwrapped):
            return .string(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Key(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (forKey: Swift.String)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.removeValue(forKey:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removeValue_u0028_forKey_u003A__u0029___Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.removeValue(forKey:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let subranges: Swift.RangeSet<Swift.Dictionary<Swift.String,Foundation.Data>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Dictionary<Swift.String,Foundation.Data>.Index>", as: Swift.RangeSet<Swift.Dictionary<Swift.String,Foundation.Data>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let subranges: Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Bool>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Bool>.Index>", as: Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Bool>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let subranges: Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Double>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Double>.Index>", as: Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Double>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let subranges: Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Int>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Int>.Index>", as: Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Int>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let subranges: Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.String>.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.String>.Index>", as: Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.String>.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.RangeSet<Swift.Dictionary<Swift.String,Foundation.Data>.Index>)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Bool>.Index>)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Double>.Index>)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.Int>.Index>)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.RangeSet<Swift.Dictionary<Swift.String,Swift.String>.Index>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.removingSubranges(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
                return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
            } else {
                throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
            }
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.removingSubranges(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) { return try HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Dictionary.removingSubranges(_:) is not available on this platform")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.reserveCapacity(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.reserveCapacity(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.reversed()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.reversed()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.reversed()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.reversed()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.reversed()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
            "  - Swift.Dictionary<Swift.String,Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.reversed() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__reversed_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.reversed()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
            "  - Swift.Dictionary<Swift.String,Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.shuffled() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__shuffled_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.shuffled()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>.Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Int)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.suffix(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028___u003A__u0029___Swift_u002E_Int__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.suffix(_:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let start: Swift.Dictionary<Swift.String,Foundation.Data>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Foundation.Data>.Index", as: Swift.Dictionary<Swift.String,Foundation.Data>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Foundation.Data>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let start: Swift.Dictionary<Swift.String,Swift.Bool>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Bool>.Index", as: Swift.Dictionary<Swift.String,Swift.Bool>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let start: Swift.Dictionary<Swift.String,Swift.Double>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Double>.Index", as: Swift.Dictionary<Swift.String,Swift.Double>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let start: Swift.Dictionary<Swift.String,Swift.Int>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.Int>.Index", as: Swift.Dictionary<Swift.String,Swift.Int>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Dictionary.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let start: Swift.Dictionary<Swift.String,Swift.String>.Index = try vm.withHost(args[1], typeName: "Swift.Dictionary<Swift.String,Swift.String>.Index", as: Swift.Dictionary<Swift.String,Swift.String>.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (from: Swift.Dictionary<Swift.String,Foundation.Data>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (from: Swift.Dictionary<Swift.String,Swift.Bool>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (from: Swift.Dictionary<Swift.String,Swift.Double>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (from: Swift.Dictionary<Swift.String,Swift.Int>.Index)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (from: Swift.Dictionary<Swift.String,Swift.String>.Index)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.suffix(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Foundation_u002E_Data_u003E__u002E_Index__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__suffix_u0028_from_u003A__u0029___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E__u002E_Index__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.suffix(from:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Foundation_u002E_Data__Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.updateValue(_:forKey:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Foundation.Data> host") }
    let value: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let key = try args[2].expectString("key")
    let returnHostTypeID_Data = vm.hostTypeID(named: "Data")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Foundation.Data>", as: Swift.Dictionary<Swift.String,Foundation.Data>.self) { receiver in
        let result = receiver.updateValue(value, forKey: key)
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Data)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Bool__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.updateValue(_:forKey:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let value = try args[1].expectBool("value")
    let key = try args[2].expectString("key")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { receiver in
        let result = receiver.updateValue(value, forKey: key)
        switch result {
        case .some(let unwrapped):
            return .bool(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Double__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.updateValue(_:forKey:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let value = try args[1].expectDouble("value")
    let key = try args[2].expectString("key")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { receiver in
        let result = receiver.updateValue(value, forKey: key)
        switch result {
        case .some(let unwrapped):
            return .double(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Int__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.updateValue(_:forKey:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let value = try args[1].expectInt("value")
    let key = try args[2].expectString("key")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { receiver in
        let result = receiver.updateValue(value, forKey: key)
        switch result {
        case .some(let unwrapped):
            return .int(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_String__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.updateValue(_:forKey:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let value = try args[1].expectString("value")
    let key = try args[2].expectString("key")
    return try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { receiver in
        let result = receiver.updateValue(value, forKey: key)
        switch result {
        case .some(let unwrapped):
            return .string(unwrapped)
        case .none:
            return .nilValue
        }
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Value__Key(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Foundation_u002E_Data__Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Bool__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Double__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Int__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_String__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Foundation.Data> (Foundation.Data, forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Bool> (Swift.Bool, forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Double> (Swift.Double, forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.Int> (Swift.Int, forKey: Swift.String)",
            "  - Swift.Dictionary<Swift.String,Swift.String> (Swift.String, forKey: Swift.String)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary.updateValue(_:forKey:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case let .host(_, tid) = sampleValue, tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM dictionary to host dictionary of <Swift.String, Foundation.Data> inline
            var hostDict: [String: Foundation.Data] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .host(ref, _) = valueVal else { throw VMError.typeError("Expected host value") }
                guard let value = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Foundation_u002E_Data__Swift_u002E_String__Key_Swift_u002E_String__Value_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Bool__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Double__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_Int__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E__updateValue_u0028___u003A_forKey_u003A__u0029___Swift_u002E_String__Swift_u002E_String__Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary.updateValue(_:forKey:)")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

