// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Double

public func Host_Swift_u002E_Double__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs != rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.!=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_star__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.*(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs * rhs
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_star__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002A__u0028_lhs_u003A_rhs_u003A__u0029___op_star__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.*(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_star_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.*=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    var lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    lhs *= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Double__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_star_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002A__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_star_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.*=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs + rhs
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.+(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002B__u0028_x_u003A__u0029___op_plus__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.+(x:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let x = try args[1].expectDouble("x")
    let result = +x
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double__u002B__u0028_x_u003A__u0029___op_plus__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002B__u0028_x_u003A__u0029___op_plus__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (x: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.+(x:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.+=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    var lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    lhs += rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Double__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.+=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.-(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs - rhs
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.-(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002D__u0028_operand_u003A__u0029___op_minus__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.-(operand:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let operand = try args[1].expectDouble("operand")
    let result = -operand
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double__u002D__u0028_operand_u003A__u0029___op_minus__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002D__u0028_operand_u003A__u0029___op_minus__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (operand: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.-(operand:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002D__u0028_x_u003A__u0029___op_minus__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.-(x:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let x = try args[1].expectDouble("x")
    let result = -x
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double__u002D__u0028_x_u003A__u0029___op_minus__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002D__u0028_x_u003A__u0029___op_minus__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (x: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.-(x:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.-=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    var lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    lhs -= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Double__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.-=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002F__u0028_lhs_u003A_rhs_u003A__u0029___op_slash__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double./(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs / rhs
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double__u002F__u0028_lhs_u003A_rhs_u003A__u0029___op_slash__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002F__u0028_lhs_u003A_rhs_u003A__u0029___op_slash__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double./(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u002F__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_slash_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double./=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    var lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    lhs /= rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Double__u002F__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_slash_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u002F__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_slash_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double./=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.<(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs < rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.<(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u003C__u0028_x_u003A_y_u003A__u0029___op_lt__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.<(x:y:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let x = try args[1].expectDouble("x")
    let y = try args[2].expectDouble("y")
    let result = x < y
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double__u003C__u0028_x_u003A_y_u003A__u0029___op_lt__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u003C__u0028_x_u003A_y_u003A__u0029___op_lt__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (x: Swift.Double, y: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.<(x:y:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.<=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs <= rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.<=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs == rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u003D__u003D__u0028_x_u003A_y_u003A__u0029___op_eq_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.==(x:y:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let x = try args[1].expectDouble("x")
    let y = try args[2].expectDouble("y")
    let result = x == y
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double__u003D__u003D__u0028_x_u003A_y_u003A__u0029___op_eq_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u003D__u003D__u0028_x_u003A_y_u003A__u0029___op_eq_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (x: Swift.Double, y: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.==(x:y:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.>(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs > rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.>(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.>=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs >= rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (lhs: Swift.Double, rhs: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.>=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Double__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (seed: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double._rawHashValue(seed:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__step_u0028_after_u003A_from_u003A_by_u003A__u0029____u0028_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__u002C__u0020_Swift_u002E_Double_u0029___Swift_u002E_Double__Swift_u002E_Double_u002E_Stride(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Double._step(after:from:by:) expects 3 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let current: (Swift.Optional<Swift.Int>, Swift.Double) = try vm.withHost(args[1], typeName: "(Swift.Optional<Swift.Int>, Swift.Double)", as: (Swift.Optional<Swift.Int>, Swift.Double).self) { host in
        host
    }
    let start = try args[2].expectDouble("start")
    let distance: Swift.Double.Stride = try vm.withHost(args[3], typeName: "Swift.Double.Stride", as: Swift.Double.Stride.self) { host in
        host
    }
    let result = Swift.Double._step(after: current, from: start, by: distance)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Double"))
}

public func HostDispatcher_Swift_u002E_Double__step_u0028_after_u003A_from_u003A_by_u003A__u0029____u0028_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__u002C__u0020_Swift_u002E_Double_u0029___Swift_u002E_Double__Swift_u002E_Double_u002E_Stride(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__step_u0028_after_u003A_from_u003A_by_u003A__u0029____u0028_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__u002C__u0020_Swift_u002E_Double_u0029___Swift_u002E_Double__Swift_u002E_Double_u002E_Stride(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (after: (Swift.Optional<Swift.Int>, Swift.Double), from: Swift.Double, by: Swift.Double.Stride)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double._step(after:from:by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__toCustomAnyHashable_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Double._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Double"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Double__toCustomAnyHashable_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double__toCustomAnyHashable_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double._toCustomAnyHashable() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_addProduct_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.addProduct(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    return try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { receiver in
        receiver.addProduct(lhs, rhs)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Double_addProduct_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_addProduct_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.Double, Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.addProduct(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_addingProduct_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.addingProduct(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let lhs = try args[1].expectDouble("lhs")
    let rhs = try args[2].expectDouble("rhs")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.addingProduct(lhs, rhs)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_addingProduct_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_addingProduct_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.Double, Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.addingProduct(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_advanced_u0028_by_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.advanced(by:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let amount = try args[1].expectDouble("amount")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.advanced(by: amount)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_advanced_u0028_by_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_advanced_u0028_by_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (by: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.advanced(by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_distance_u0028_to_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.distance(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.distance(to: other)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_distance_u0028_to_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_distance_u0028_to_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (to: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.distance(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.encode(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let encoder: Swift.Encoder = try vm.withHost(args[1], typeName: "Swift.Encoder", as: Swift.Encoder.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    try receiver.encode(to: encoder)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_Double_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (to: Swift.Encoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.encode(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_formRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.formRemainder(dividingBy:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    return try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { receiver in
        receiver.formRemainder(dividingBy: other)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Double_formRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_formRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (dividingBy: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.formRemainder(dividingBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_formSquareRoot_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Double.formSquareRoot() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    return try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { receiver in
        receiver.formSquareRoot()
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Double_formSquareRoot_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_formSquareRoot_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.formSquareRoot() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_formTruncatingRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.formTruncatingRemainder(dividingBy:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    return try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { receiver in
        receiver.formTruncatingRemainder(dividingBy: other)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Double_formTruncatingRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_formTruncatingRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (dividingBy: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.formTruncatingRemainder(dividingBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Double.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double()
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028_bitPattern_u003A__u0029___Swift_u002E_UInt64(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.init(bitPattern:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let bitPattern: Swift.UInt64 = try vm.withHost(args[1], typeName: "Swift.UInt64", as: Swift.UInt64.self) { host in
        host
    }
    let result = Swift.Double(bitPattern: bitPattern)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028_bitPattern_u003A__u0029___Swift_u002E_UInt64(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028_bitPattern_u003A__u0029___Swift_u002E_UInt64(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (bitPattern: Swift.UInt64)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init(bitPattern:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028_floatLiteral_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.init(floatLiteral:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let value = try args[1].expectDouble("value")
    let result = Swift.Double(floatLiteral: value)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028_floatLiteral_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028_floatLiteral_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (floatLiteral: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init(floatLiteral:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.init(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let decoder: Swift.Decoder = try vm.withHost(args[1], typeName: "Swift.Decoder", as: Swift.Decoder.self) { host in
        host
    }
    let result = try Swift.Double(from: decoder)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (from: Swift.Decoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028_integerLiteral_u003A__u0029___Swift_u002E_Int64(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.init(integerLiteral:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let value: Swift.Int64 = try vm.withHost(args[1], typeName: "Swift.Int64", as: Swift.Int64.self) { host in
        host
    }
    let result = Swift.Double(integerLiteral: value)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028_integerLiteral_u003A__u0029___Swift_u002E_Int64(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028_integerLiteral_u003A__u0029___Swift_u002E_Int64(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (integerLiteral: Swift.Int64)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init(integerLiteral:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028_nan_u003A_signaling_u003A__u0029___Swift_u002E_Double_u002E_RawSignificand__Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.init(nan:signaling:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let payload: Swift.Double.RawSignificand = try vm.withHost(args[1], typeName: "Swift.Double.RawSignificand", as: Swift.Double.RawSignificand.self) { host in
        host
    }
    let signaling = try args[2].expectBool("signaling")
    let result = Swift.Double(nan: payload, signaling: signaling)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028_nan_u003A_signaling_u003A__u0029___Swift_u002E_Double_u002E_RawSignificand__Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028_nan_u003A_signaling_u003A__u0029___Swift_u002E_Double_u002E_RawSignificand__Swift_u002E_Bool(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (nan: Swift.Double.RawSignificand, signaling: Swift.Bool)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init(nan:signaling:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028_sign_u003A_exponent_u003A_significand_u003A__u0029___Swift_u002E_FloatingPointSign__Swift_u002E_Int__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Double.init(sign:exponent:significand:) expects 3 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let sign: Swift.FloatingPointSign = try vm.withHost(args[1], typeName: "Swift.FloatingPointSign", as: Swift.FloatingPointSign.self) { host in
        host
    }
    let exponent = try args[2].expectInt("exponent")
    let significand = try args[3].expectDouble("significand")
    let result = Swift.Double(sign: sign, exponent: exponent, significand: significand)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028_sign_u003A_exponent_u003A_significand_u003A__u0029___Swift_u002E_FloatingPointSign__Swift_u002E_Int__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028_sign_u003A_exponent_u003A_significand_u003A__u0029___Swift_u002E_FloatingPointSign__Swift_u002E_Int__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init(sign:exponent:significand:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028_sign_u003A_exponentBitPattern_u003A_significandBitPattern_u003A__u0029___Swift_u002E_FloatingPointSign__Swift_u002E_UInt__Swift_u002E_UInt64(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Double.init(sign:exponentBitPattern:significandBitPattern:) expects 3 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let sign: Swift.FloatingPointSign = try vm.withHost(args[1], typeName: "Swift.FloatingPointSign", as: Swift.FloatingPointSign.self) { host in
        host
    }
    let exponentBitPattern: Swift.UInt = try vm.withHost(args[2], typeName: "Swift.UInt", as: Swift.UInt.self) { host in
        host
    }
    let significandBitPattern: Swift.UInt64 = try vm.withHost(args[3], typeName: "Swift.UInt64", as: Swift.UInt64.self) { host in
        host
    }
    let result = Swift.Double(sign: sign, exponentBitPattern: exponentBitPattern, significandBitPattern: significandBitPattern)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028_sign_u003A_exponentBitPattern_u003A_significandBitPattern_u003A__u0029___Swift_u002E_FloatingPointSign__Swift_u002E_UInt__Swift_u002E_UInt64(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028_sign_u003A_exponentBitPattern_u003A_significandBitPattern_u003A__u0029___Swift_u002E_FloatingPointSign__Swift_u002E_UInt__Swift_u002E_UInt64(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt64)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init(sign:exponentBitPattern:significandBitPattern:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_init_u0028_signOf_u003A_magnitudeOf_u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.init(signOf:magnitudeOf:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let sign = try args[1].expectDouble("sign")
    let mag = try args[2].expectDouble("mag")
    let result = Swift.Double(signOf: sign, magnitudeOf: mag)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_init_u0028_signOf_u003A_magnitudeOf_u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_init_u0028_signOf_u003A_magnitudeOf_u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (signOf: Swift.Double, magnitudeOf: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.init(signOf:magnitudeOf:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isEqual_u0028_to_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.isEqual(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isEqual(to: other)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isEqual_u0028_to_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_isEqual_u0028_to_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (to: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.isEqual(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isLess_u0028_than_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.isLess(than:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isLess(than: other)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isLess_u0028_than_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_isLess_u0028_than_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (than: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.isLess(than:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isLessThanOrEqualTo_u0028___u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.isLessThanOrEqualTo(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isLessThanOrEqualTo(other)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isLessThanOrEqualTo_u0028___u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_isLessThanOrEqualTo_u0028___u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.isLessThanOrEqualTo(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isTotallyOrdered_u0028_belowOrEqualTo_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.isTotallyOrdered(belowOrEqualTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isTotallyOrdered(belowOrEqualTo: other)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isTotallyOrdered_u0028_belowOrEqualTo_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_isTotallyOrdered_u0028_belowOrEqualTo_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (belowOrEqualTo: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.isTotallyOrdered(belowOrEqualTo:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_maximum_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.maximum(_:_:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let x = try args[1].expectDouble("x")
    let y = try args[2].expectDouble("y")
    let result = Swift.Double.maximum(x, y)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_maximum_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_maximum_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.Double, Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.maximum(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_maximumMagnitude_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.maximumMagnitude(_:_:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let x = try args[1].expectDouble("x")
    let y = try args[2].expectDouble("y")
    let result = Swift.Double.maximumMagnitude(x, y)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_maximumMagnitude_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_maximumMagnitude_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.Double, Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.maximumMagnitude(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_minimum_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.minimum(_:_:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let x = try args[1].expectDouble("x")
    let y = try args[2].expectDouble("y")
    let result = Swift.Double.minimum(x, y)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_minimum_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_minimum_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.Double, Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.minimum(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_minimumMagnitude_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Double.minimumMagnitude(_:_:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let x = try args[1].expectDouble("x")
    let y = try args[2].expectDouble("y")
    let result = Swift.Double.minimumMagnitude(x, y)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_minimumMagnitude_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_minimumMagnitude_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.Double, Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.minimumMagnitude(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_negate_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Double.negate() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    return try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { receiver in
        receiver.negate()
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Double_negate_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_negate_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.negate() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_remainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.remainder(dividingBy:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.remainder(dividingBy: other)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_remainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_remainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (dividingBy: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.remainder(dividingBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_round_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Double.round() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    return try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { receiver in
        receiver.round()
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Double_round_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_round_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.round() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_round_u0028___u003A__u0029___Swift_u002E_FloatingPointRoundingRule(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.round(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let rule: Swift.FloatingPointRoundingRule = try vm.withHost(args[1], typeName: "Swift.FloatingPointRoundingRule", as: Swift.FloatingPointRoundingRule.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { receiver in
        receiver.round(rule)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_Double_round_u0028___u003A__u0029___Swift_u002E_FloatingPointRoundingRule(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_round_u0028___u003A__u0029___Swift_u002E_FloatingPointRoundingRule(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.FloatingPointRoundingRule)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.round(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_rounded_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Double.rounded() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.rounded()
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_rounded_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_rounded_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.rounded() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_rounded_u0028___u003A__u0029___Swift_u002E_FloatingPointRoundingRule(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.rounded(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let rule: Swift.FloatingPointRoundingRule = try vm.withHost(args[1], typeName: "Swift.FloatingPointRoundingRule", as: Swift.FloatingPointRoundingRule.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.rounded(rule)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_rounded_u0028___u003A__u0029___Swift_u002E_FloatingPointRoundingRule(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_rounded_u0028___u003A__u0029___Swift_u002E_FloatingPointRoundingRule(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (Swift.FloatingPointRoundingRule)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.rounded(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_squareRoot_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Double.squareRoot() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.squareRoot()
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_squareRoot_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_squareRoot_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.squareRoot() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_truncatingRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Double.truncatingRemainder(dividingBy:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let other = try args[1].expectDouble("other")
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.truncatingRemainder(dividingBy: other)
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_truncatingRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.Double") {
        return try Host_Swift_u002E_Double_truncatingRemainder_u0028_dividingBy_u003A__u0029___Swift_u002E_Double(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Double (dividingBy: Swift.Double)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Double.truncatingRemainder(dividingBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__cVarArgAlignment_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double._cVarArgAlignment expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver._cVarArgAlignment
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Double__cVarArgAlignment(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double__cVarArgAlignment_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double._cVarArgAlignment has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double__cVarArgEncoding_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double._cVarArgEncoding expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver._cVarArgEncoding
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.int(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_Double__cVarArgEncoding(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double__cVarArgEncoding_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double._cVarArgEncoding has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_binade_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.binade expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.binade
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_binade(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_binade_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.binade has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_bitPattern_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.bitPattern expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.bitPattern
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Double"))
}

public func HostDispatcher_Swift_u002E_Double_bitPattern(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_bitPattern_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.bitPattern has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Double"))
}

public func HostDispatcher_Swift_u002E_Double_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_customMirror_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(*, deprecated, message: "Double.customPlaygroundQuickLook will be removed in a future Swift version")
public func Host_Swift_u002E_Double_customPlaygroundQuickLook_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.customPlaygroundQuickLook expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.customPlaygroundQuickLook
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Double"))
}

@available(*, deprecated, message: "Double.customPlaygroundQuickLook will be removed in a future Swift version")
public func HostDispatcher_Swift_u002E_Double_customPlaygroundQuickLook(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host:
            if true { return try Host_Swift_u002E_Double_customPlaygroundQuickLook_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Swift.Double.customPlaygroundQuickLook is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.customPlaygroundQuickLook has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_Double_customPlaygroundQuickLook(vm: inout VM, _ args: [Value]) throws -> Value {
    if true { return try HostDispatcher_Swift_u002E_Double_customPlaygroundQuickLook(vm: &vm, args) }
    throw VMError.unsupported("Getter for Swift.Double.customPlaygroundQuickLook is not available on this platform")
}

public func Host_Swift_u002E_Double_debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func HostDispatcher_Swift_u002E_Double_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_debugDescription_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func HostDispatcher_Swift_u002E_Double_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_description_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_exponent_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.exponent expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.exponent
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Double_exponent(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_exponent_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.exponent has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_exponentBitCount_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.exponentBitCount expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.exponentBitCount
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Double_exponentBitCount(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_exponentBitCount_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.exponentBitCount has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_exponentBitPattern_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.exponentBitPattern expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.exponentBitPattern
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Double"))
}

public func HostDispatcher_Swift_u002E_Double_exponentBitPattern(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_exponentBitPattern_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.exponentBitPattern has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_floatingPointClass_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.floatingPointClass expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.floatingPointClass
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Double"))
}

public func HostDispatcher_Swift_u002E_Double_floatingPointClass(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_floatingPointClass_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.floatingPointClass has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_greatestFiniteMagnitude_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.greatestFiniteMagnitude expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.greatestFiniteMagnitude
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_greatestFiniteMagnitude(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_greatestFiniteMagnitude_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.greatestFiniteMagnitude has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Double_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_hashValue_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_infinity_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.infinity expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.infinity
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_infinity(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_infinity_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.infinity has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isCanonical_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.isCanonical expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isCanonical
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isCanonical(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_isCanonical_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.isCanonical has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isFinite_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.isFinite expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isFinite
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isFinite(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_isFinite_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.isFinite has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isInfinite_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.isInfinite expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isInfinite
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isInfinite(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_isInfinite_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.isInfinite has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isNaN_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.isNaN expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isNaN
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isNaN(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_isNaN_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.isNaN has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isNormal_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.isNormal expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isNormal
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isNormal(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_isNormal_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.isNormal has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isSignalingNaN_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.isSignalingNaN expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isSignalingNaN
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isSignalingNaN(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_isSignalingNaN_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.isSignalingNaN has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isSubnormal_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.isSubnormal expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isSubnormal
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isSubnormal(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_isSubnormal_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.isSubnormal has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_isZero_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.isZero expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.isZero
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Double_isZero(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_isZero_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.isZero has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_leastNonzeroMagnitude_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.leastNonzeroMagnitude expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.leastNonzeroMagnitude
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_leastNonzeroMagnitude(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_leastNonzeroMagnitude_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.leastNonzeroMagnitude has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_leastNormalMagnitude_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.leastNormalMagnitude expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.leastNormalMagnitude
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_leastNormalMagnitude(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_leastNormalMagnitude_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.leastNormalMagnitude has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_magnitude_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.magnitude expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.magnitude
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_magnitude(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_magnitude_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.magnitude has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_nan_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.nan expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.nan
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_nan(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_nan_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.nan has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_nextDown_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.nextDown expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.nextDown
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_nextDown(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_nextDown_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.nextDown has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_nextUp_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.nextUp expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.nextUp
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_nextUp(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_nextUp_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.nextUp has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_pi_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.pi expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.pi
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_pi(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_pi_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.pi has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_radix_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.radix expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.radix
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Double_radix(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_radix_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.radix has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_sign_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.sign expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.sign
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Double"))
}

public func HostDispatcher_Swift_u002E_Double_sign(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_sign_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.sign has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_signalingNaN_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.signalingNaN expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.signalingNaN
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_signalingNaN(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_signalingNaN_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.signalingNaN has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_significand_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.significand expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.significand
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_significand(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_significand_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.significand has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_significandBitCount_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.significandBitCount expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.significandBitCount
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Double_significandBitCount(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_significandBitCount_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.significandBitCount has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_significandBitPattern_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.significandBitPattern expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.significandBitPattern
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Double"))
}

public func HostDispatcher_Swift_u002E_Double_significandBitPattern(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_significandBitPattern_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.significandBitPattern has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_significandWidth_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.significandWidth expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.significandWidth
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Double_significandWidth(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_significandWidth_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.significandWidth has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_ulp_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.ulp expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Double host") }
    let receiver = try vm.withHost(args[0], typeName: "Double", as: Swift.Double.self) { host in
        host
    }
    let result = receiver.ulp
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_ulp(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Double_ulp_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.ulp has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_ulpOfOne_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.ulpOfOne expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.ulpOfOne
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_ulpOfOne(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_ulpOfOne_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.ulpOfOne has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Double_zero_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Double.zero expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Double metatype") }
    let result = Swift.Double.zero
    return .double(result)
}

public func HostDispatcher_Swift_u002E_Double_zero(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Double") {
        switch args[0] {
        case .metatype: return try Host_Swift_u002E_Double_zero_static(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Double ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Double.zero has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

