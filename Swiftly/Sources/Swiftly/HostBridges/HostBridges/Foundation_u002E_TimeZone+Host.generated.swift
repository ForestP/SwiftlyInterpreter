// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Foundation.TimeZone

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_TimeZone__Foundation_u002E_TimeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("TimeZone.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let lhs: Foundation.TimeZone = try vm.withHost(args[1], typeName: "Foundation.TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let rhs: Foundation.TimeZone = try vm.withHost(args[2], typeName: "Foundation.TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = lhs == rhs
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_TimeZone__Foundation_u002E_TimeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_TimeZone__Foundation_u002E_TimeZone(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.==(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (lhs: Foundation.TimeZone, rhs: Foundation.TimeZone)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_TimeZone__Foundation_u002E_TimeZone(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_TimeZone__Foundation_u002E_TimeZone(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.==(lhs:rhs:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_abbreviation_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.abbreviation(for:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let date: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.abbreviation(for: date)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_abbreviation_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_abbreviation_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.abbreviation(for:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (for: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.abbreviation(for:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_abbreviation_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_abbreviation_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.abbreviation(for:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_daylightSavingTimeOffset_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.daylightSavingTimeOffset(for:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let date: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.daylightSavingTimeOffset(for: date)
    return .double(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_daylightSavingTimeOffset_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_daylightSavingTimeOffset_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.daylightSavingTimeOffset(for:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (for: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.daylightSavingTimeOffset(for:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_daylightSavingTimeOffset_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_daylightSavingTimeOffset_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.daylightSavingTimeOffset(for:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.encode(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let encoder: Swift.Encoder = try vm.withHost(args[1], typeName: "Swift.Encoder", as: Swift.Encoder.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    try receiver.encode(to: encoder)
    return .bool(true)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.encode(to:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (to: Swift.Encoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.encode(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.encode(to:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_init_u0028_abbreviation_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.init(abbreviation:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let abbreviation = try args[1].expectString("abbreviation")
    let result = Foundation.TimeZone(abbreviation: abbreviation)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), tid)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_init_u0028_abbreviation_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_init_u0028_abbreviation_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.init(abbreviation:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (abbreviation: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.init(abbreviation:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_init_u0028_abbreviation_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_init_u0028_abbreviation_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.init(abbreviation:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.init(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let decoder: Swift.Decoder = try vm.withHost(args[1], typeName: "Swift.Decoder", as: Swift.Decoder.self) { host in
        host
    }
    let result = try Foundation.TimeZone(from: decoder)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.init(from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (from: Swift.Decoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.init(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.init(from:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.init(identifier:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let identifier = try args[1].expectString("identifier")
    let result = Foundation.TimeZone(identifier: identifier)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), tid)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.init(identifier:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (identifier: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.init(identifier:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_init_u0028_identifier_u003A__u0029___Swift_u002E_String(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.init(identifier:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_init_u0028_secondsFromGMT_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.init(secondsFromGMT:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let seconds = try args[1].expectInt("seconds")
    let result = Foundation.TimeZone(secondsFromGMT: seconds)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), tid)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_init_u0028_secondsFromGMT_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_init_u0028_secondsFromGMT_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.init(secondsFromGMT:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (secondsFromGMT: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.init(secondsFromGMT:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_init_u0028_secondsFromGMT_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_init_u0028_secondsFromGMT_u003A__u0029___Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.init(secondsFromGMT:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_isDaylightSavingTime_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.isDaylightSavingTime(for:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let date: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.isDaylightSavingTime(for: date)
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_isDaylightSavingTime_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_isDaylightSavingTime_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.isDaylightSavingTime(for:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (for: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.isDaylightSavingTime(for:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_isDaylightSavingTime_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_isDaylightSavingTime_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.isDaylightSavingTime(for:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_localizedName_u0028_for_u003A_locale_u003A__u0029___Foundation_u002E_TimeZone_u002E_NameStyle__Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("TimeZone.localizedName(for:locale:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let style: Foundation.TimeZone.NameStyle = try vm.withHost(args[1], typeName: "Foundation.TimeZone.NameStyle", as: Foundation.TimeZone.NameStyle.self) { host in
        host
    }
    var locale: Foundation.Locale? = nil
    if case .nilValue = args[2] {
        locale = nil
    } else {
        locale = try vm.withHost(args[2], typeName: "Foundation.Locale", as: Foundation.Locale.self) { host in
            host
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.localizedName(for: style, locale: locale)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_localizedName_u0028_for_u003A_locale_u003A__u0029___Foundation_u002E_TimeZone_u002E_NameStyle__Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_localizedName_u0028_for_u003A_locale_u003A__u0029___Foundation_u002E_TimeZone_u002E_NameStyle__Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.localizedName(for:locale:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (for: Foundation.TimeZone.NameStyle, locale: Swift.Optional<Foundation.Locale>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.localizedName(for:locale:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_localizedName_u0028_for_u003A_locale_u003A__u0029___Foundation_u002E_TimeZone_u002E_NameStyle__Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_localizedName_u0028_for_u003A_locale_u003A__u0029___Foundation_u002E_TimeZone_u002E_NameStyle__Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.localizedName(for:locale:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition_u0028_after_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.nextDaylightSavingTimeTransition(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let date: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.nextDaylightSavingTimeTransition(after: date)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "TimeZone"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition_u0028_after_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition_u0028_after_u003A__u0029___Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.nextDaylightSavingTimeTransition(after:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (after: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.nextDaylightSavingTimeTransition(after:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition_u0028_after_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition_u0028_after_u003A__u0029___Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.nextDaylightSavingTimeTransition(after:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_secondsFromGMT_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("TimeZone.secondsFromGMT(for:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let date: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.secondsFromGMT(for: date)
    return .int(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_secondsFromGMT_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_TimeZone_secondsFromGMT_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("TimeZone.secondsFromGMT(for:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (for: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("TimeZone.secondsFromGMT(for:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_secondsFromGMT_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_secondsFromGMT_u0028_for_u003A__u0029___Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("TimeZone.secondsFromGMT(for:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_abbreviationDictionary_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.abbreviationDictionary expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let result = Foundation.TimeZone.abbreviationDictionary
    var result_value_storage: [String: Value] = [:]
    for (result_value_key, result_value_value) in result {
        result_value_storage[result_value_key] = .string(result_value_value)
    }
    let result_value_dictBox = DictBox(result_value_storage)
    return .dict(result_value_dictBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_abbreviationDictionary(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_abbreviationDictionary_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.abbreviationDictionary is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.abbreviationDictionary has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_TimeZone_abbreviationDictionary_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.TimeZone.abbreviationDictionary setter expects value") }
    guard case .metatype = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    guard case let .dict(newValue_dictBox) = args[1] else { throw VMError.typeError("abbreviationDictionary expects Swift.Dictionary<Swift.String,Swift.String>") }
    var newValue_dictValue: Swift.Dictionary<Swift.String,Swift.String> = [:]
    for (rawKey, rawValue) in newValue_dictBox.storage {
        let newValue_value = try rawValue.expectString("abbreviationDictionary[\(rawKey)]")
        newValue_dictValue[rawKey] = newValue_value
    }
    let newValue = newValue_dictValue
    Foundation.TimeZone.abbreviationDictionary = newValue
    return .nilValue
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_TimeZone_abbreviationDictionary(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .metatype(receiverTid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "TimeZone") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_TimeZone_abbreviationDictionary_static(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.TimeZone.abbreviationDictionary is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.TimeZone (value: Swift.Dictionary<Swift.String,Swift.String>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.TimeZone.abbreviationDictionary has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_abbreviationDictionary(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_abbreviationDictionary(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.abbreviationDictionary is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_TimeZone_abbreviationDictionary(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_TimeZone_abbreviationDictionary(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.TimeZone.abbreviationDictionary is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_autoupdatingCurrent_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.autoupdatingCurrent expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let result = Foundation.TimeZone.autoupdatingCurrent
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "TimeZone"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_autoupdatingCurrent(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_autoupdatingCurrent_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.autoupdatingCurrent is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.autoupdatingCurrent has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_autoupdatingCurrent(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_autoupdatingCurrent(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.autoupdatingCurrent is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_current_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.current expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let result = Foundation.TimeZone.current
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "TimeZone"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_current(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_current_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.current is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.current has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_current(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_current(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.current is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "TimeZone"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_customMirror_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.customMirror is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_customMirror(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.customMirror is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_debugDescription_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.debugDescription is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_debugDescription(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.debugDescription is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_description_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.description is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_description(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_description(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.description is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func Host_Foundation_u002E_TimeZone_gmt_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.gmt expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let result = Foundation.TimeZone.gmt
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "TimeZone"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public func HostDispatcher_Foundation_u002E_TimeZone_gmt(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .metatype:
            if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try Host_Foundation_u002E_TimeZone_gmt_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.gmt is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.gmt has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_gmt(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13, iOS 16, tvOS 16, watchOS 9, *) { return try HostDispatcher_Foundation_u002E_TimeZone_gmt(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.gmt is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_hashValue_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.hashValue is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_hashValue(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.hashValue is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_identifier_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.identifier expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.identifier
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_identifier(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_identifier_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.identifier is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.identifier has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_identifier(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_identifier(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.identifier is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_knownTimeZoneIdentifiers_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.knownTimeZoneIdentifiers expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let result = Foundation.TimeZone.knownTimeZoneIdentifiers
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.string(result_value_element))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_knownTimeZoneIdentifiers(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_knownTimeZoneIdentifiers_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.knownTimeZoneIdentifiers is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.knownTimeZoneIdentifiers has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_knownTimeZoneIdentifiers(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_knownTimeZoneIdentifiers(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.knownTimeZoneIdentifiers is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.nextDaylightSavingTimeTransition expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone host") }
    let receiver = try vm.withHost(args[0], typeName: "TimeZone", as: Foundation.TimeZone.self) { host in
        host
    }
    let result = receiver.nextDaylightSavingTimeTransition
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "TimeZone"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.nextDaylightSavingTimeTransition is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.nextDaylightSavingTimeTransition has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_nextDaylightSavingTimeTransition(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.nextDaylightSavingTimeTransition is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_TimeZone_timeZoneDataVersion_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.TimeZone.timeZoneDataVersion expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be TimeZone metatype") }
    let result = Foundation.TimeZone.timeZoneDataVersion
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_TimeZone_timeZoneDataVersion(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "TimeZone") {
        switch args[0] {
        case .metatype:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_TimeZone_timeZoneDataVersion_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.TimeZone.timeZoneDataVersion is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.TimeZone ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.TimeZone.timeZoneDataVersion has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_TimeZone_timeZoneDataVersion(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_TimeZone_timeZoneDataVersion(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.TimeZone.timeZoneDataVersion is not available on this platform")
}

