// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Optional<Foundation.Data>

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Optional<Foundation.Data> (seed: Swift.Int)",
            "  - Swift.Optional<Swift.Bool> (seed: Swift.Int)",
            "  - Swift.Optional<Swift.Double> (seed: Swift.Int)",
            "  - Swift.Optional<Swift.Int> (seed: Swift.Int)",
            "  - Swift.Optional<Swift.String> (seed: Swift.Int)",
            "  - Swift.Optional<Swift.UInt8> (seed: Swift.Int)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Optional._rawHashValue(seed:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native optional receiver
    else if case .nilValue = args[0] {
        // Nil value - works for any Optional<T>
        return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Foundation_u002E_Data(vm: &vm, args)
    }
    else {
        // Infer wrapped type from value
        if case let .host(_, tid) = args[0], tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM value to host Optional<Foundation.Data> inline
            guard case let .host(ref, _) = args[0] else { throw VMError.typeError("Expected host value") }
            guard let wrapped = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
            let hostOptionalValue: Foundation.Data? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = args[0] {
            // Convert VM value to host Optional<Swift.Bool> inline
            guard case let .bool(wrapped) = args[0] else { throw VMError.typeError("Expected Bool") }
            let hostOptionalValue: Bool? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = args[0] {
            // Convert VM value to host Optional<Swift.Double> inline
            guard case let .double(wrapped) = args[0] else { throw VMError.typeError("Expected Double") }
            let hostOptionalValue: Double? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = args[0] {
            // Convert VM value to host Optional<Swift.Int> inline
            guard case let .int(wrapped) = args[0] else { throw VMError.typeError("Expected Int") }
            let hostOptionalValue: Int? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = args[0] {
            // Convert VM value to host Optional<Swift.String> inline
            guard case let .string(wrapped) = args[0] else { throw VMError.typeError("Expected String") }
            let hostOptionalValue: String? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = args[0] {
            // Convert VM value to host Optional<Swift.UInt8> inline
            guard case let .int(intVal) = args[0] else { throw VMError.typeError("Expected UInt8 (Int)") }
            let wrapped = UInt8(intVal)
            let hostOptionalValue: UInt8? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E___rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int__Wrapped_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Optional wrapped type not supported for Optional._rawHashValue(seed:)")
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Optional<Foundation.Data> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result_optional: Swift.Optional<Foundation.Data>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Optional<Foundation.Data> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result_optional: Swift.Optional<Foundation.Data>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Optional<Foundation.Data> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result_optional: Swift.Optional<Foundation.Data>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Optional<Foundation.Data> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result_optional: Swift.Optional<Foundation.Data>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Optional<Foundation.Data> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result_optional: Swift.Optional<Foundation.Data>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Optional<Foundation.Data> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result_optional: Swift.Optional<Foundation.Data>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.UInt8>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Optional<Swift.Bool> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result_optional: Swift.Optional<Swift.Bool>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectBool("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Optional<Swift.Bool> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Bool>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectBool("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Optional<Swift.Bool> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Bool>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectBool("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Optional<Swift.Bool> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Bool>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectBool("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Optional<Swift.Bool> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Bool>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectBool("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Optional<Swift.Bool> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result_optional: Swift.Optional<Swift.Bool>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectBool("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Optional<Swift.Double> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result_optional: Swift.Optional<Swift.Double>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectDouble("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Optional<Swift.Double> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Double>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectDouble("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Optional<Swift.Double> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Double>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectDouble("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Optional<Swift.Double> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Double>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectDouble("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Optional<Swift.Double> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Double>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectDouble("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Optional<Swift.Double> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result_optional: Swift.Optional<Swift.Double>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectDouble("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Optional<Swift.Int> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result_optional: Swift.Optional<Swift.Int>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectInt("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Optional<Swift.Int> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Int>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectInt("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Optional<Swift.Int> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Int>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectInt("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Optional<Swift.Int> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Int>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectInt("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Optional<Swift.Int> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result_optional: Swift.Optional<Swift.Int>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectInt("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Optional<Swift.Int> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result_optional: Swift.Optional<Swift.Int>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectInt("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Optional<Swift.String> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result_optional: Swift.Optional<Swift.String>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectString("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Optional<Swift.String> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result_optional: Swift.Optional<Swift.String>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectString("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Optional<Swift.String> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result_optional: Swift.Optional<Swift.String>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectString("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Optional<Swift.String> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result_optional: Swift.Optional<Swift.String>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectString("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Optional<Swift.String> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result_optional: Swift.Optional<Swift.String>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectString("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Optional<Swift.String> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result_optional: Swift.Optional<Swift.String>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped = try adapterResult.expectString("flatMap result")
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Optional<Swift.UInt8> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result_optional: Swift.Optional<Swift.UInt8>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Optional<Swift.UInt8> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result_optional: Swift.Optional<Swift.UInt8>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Optional<Swift.UInt8> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result_optional: Swift.Optional<Swift.UInt8>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Optional<Swift.UInt8> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result_optional: Swift.Optional<Swift.UInt8>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Optional<Swift.UInt8> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result_optional: Swift.Optional<Swift.UInt8>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.flatMap(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Optional<Swift.UInt8> = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result_optional: Swift.Optional<Swift.UInt8>
            if case .nilValue = adapterResult {
                transform_result_optional = nil
            } else {
                let transform_result_wrapped: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                    host
                }
                transform_result_optional = transform_result_wrapped
            }
            return transform_result_optional
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.flatMap(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.UInt8>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> Swift.Optional<U>)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> Swift.Optional<U>)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Optional.flatMap(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native optional receiver
    else if case .nilValue = args[0] {
        // Nil value - works for any Optional<T>
        return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Foundation_u002E_Data(vm: &vm, args)
    }
    else {
        // Infer wrapped type from value
        if case let .host(_, tid) = args[0], tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM value to host Optional<Foundation.Data> inline
            guard case let .host(ref, _) = args[0] else { throw VMError.typeError("Expected host value") }
            guard let wrapped = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
            let hostOptionalValue: Foundation.Data? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = args[0] {
            // Convert VM value to host Optional<Swift.Bool> inline
            guard case let .bool(wrapped) = args[0] else { throw VMError.typeError("Expected Bool") }
            let hostOptionalValue: Bool? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = args[0] {
            // Convert VM value to host Optional<Swift.Double> inline
            guard case let .double(wrapped) = args[0] else { throw VMError.typeError("Expected Double") }
            let hostOptionalValue: Double? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = args[0] {
            // Convert VM value to host Optional<Swift.Int> inline
            guard case let .int(wrapped) = args[0] else { throw VMError.typeError("Expected Int") }
            let hostOptionalValue: Int? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = args[0] {
            // Convert VM value to host Optional<Swift.String> inline
            guard case let .string(wrapped) = args[0] else { throw VMError.typeError("Expected String") }
            let hostOptionalValue: String? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = args[0] {
            // Convert VM value to host Optional<Swift.UInt8> inline
            guard case let .int(intVal) = args[0] else { throw VMError.typeError("Expected UInt8 (Int)") }
            let wrapped = UInt8(intVal)
            let hostOptionalValue: UInt8? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__flatMap_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_Swift_u002E_Optional_u003C_U_u003E___E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Optional wrapped type not supported for Optional.flatMap(_:)")
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Foundation.Data = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result: Foundation.Data = try transform_adapter.withHost(adapterResult, typeName: "Foundation.Data", as: Foundation.Data.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.UInt8>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Bool = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result = try adapterResult.expectBool("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Double = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result = try adapterResult.expectDouble("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .double(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.Int = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result = try adapterResult.expectInt("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .int(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.String = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result = try adapterResult.expectString("map result")
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Foundation.Data) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "Data"))])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Foundation.Data>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Bool) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.bool(arg0)])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Double) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.double(arg0)])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.Int) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.int(arg0)])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.String) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.string(arg0)])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Optional.map(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let transform_handle = try vm.makeHostClosureHandle(from: args[1], expectedArity: 1)
    let transform: (Swift.UInt8) throws -> Swift.UInt8 = try vm.withHostClosureAdapter(transform_handle) { transform_adapter in
        return { arg0 in
            let adapterResult = try transform_adapter.invoke([.host(HostRef(box: makeOpaqueBox(arg0)), transform_adapter.hostTypeID(named: "UInt8"))])
            let transform_result: Swift.UInt8 = try transform_adapter.withHost(adapterResult, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
                host
            }
            return transform_result
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = try receiver.map(transform)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Optional<Swift.UInt8>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Bool__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Double__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_Int__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_String__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Foundation.Data>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Foundation_u002E_Data(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Bool>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Double>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.Int>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.String>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_String(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>") {
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Swift_u002E_UInt8__Wrapped_Swift_u002E_UInt8(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Foundation.Data> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Bool> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Double> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.Int> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.String> ((Wrapped) throws -> U)",
            "  - Swift.Optional<Swift.UInt8> ((Wrapped) throws -> U)",
        ] .joined(separator: "\n")
        throw VMError.typeError("Optional.map(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native optional receiver
    else if case .nilValue = args[0] {
        // Nil value - works for any Optional<T>
        return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Foundation_u002E_Data(vm: &vm, args)
    }
    else {
        // Infer wrapped type from value
        if case let .host(_, tid) = args[0], tid == vm.hostTypeID(named: "Foundation.Data") {
            // Convert VM value to host Optional<Foundation.Data> inline
            guard case let .host(ref, _) = args[0] else { throw VMError.typeError("Expected host value") }
            guard let wrapped = ref.asAny() as? Foundation.Data else { throw VMError.typeError("Host value is not Foundation.Data") }
            let hostOptionalValue: Foundation.Data? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Foundation.Data>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Foundation_u002E_Data(vm: &vm, convertedArgs)
        }
        if case .bool = args[0] {
            // Convert VM value to host Optional<Swift.Bool> inline
            guard case let .bool(wrapped) = args[0] else { throw VMError.typeError("Expected Bool") }
            let hostOptionalValue: Bool? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = args[0] {
            // Convert VM value to host Optional<Swift.Double> inline
            guard case let .double(wrapped) = args[0] else { throw VMError.typeError("Expected Double") }
            let hostOptionalValue: Double? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = args[0] {
            // Convert VM value to host Optional<Swift.Int> inline
            guard case let .int(wrapped) = args[0] else { throw VMError.typeError("Expected Int") }
            let hostOptionalValue: Int? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = args[0] {
            // Convert VM value to host Optional<Swift.String> inline
            guard case let .string(wrapped) = args[0] else { throw VMError.typeError("Expected String") }
            let hostOptionalValue: String? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        if case .int = args[0] {
            // Convert VM value to host Optional<Swift.UInt8> inline
            guard case let .int(intVal) = args[0] else { throw VMError.typeError("Expected UInt8 (Int)") }
            let wrapped = UInt8(intVal)
            let hostOptionalValue: UInt8? = wrapped
            let hostRef = HostRef(box: makeOpaqueBox(hostOptionalValue))
            let hostOptional = Value.host(hostRef, vm.hostTypeID(named: "Swift.Optional<Swift.UInt8>"))
            var convertedArgs = args
            convertedArgs[0] = hostOptional
            return try Host_Swift_u002E_Optional_u003C_Wrapped_u003E__map_u0028___u003A__u0029____u0028_Wrapped_u0029__u0020_throws_u0020__u002D__u003E__u0020_U__E_Swift_u002E_Never__U_Foundation_u002E_Data__Wrapped_Swift_u002E_UInt8(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Optional wrapped type not supported for Optional.map(_:)")
    }
}

public func Host_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Optional<Foundation.Data>"))
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Bool_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Optional<Swift.Bool>"))
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Double_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Optional<Swift.Double>"))
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Optional<Swift.Int>"))
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_String_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Optional<Swift.String>"))
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_UInt8_u003E__customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Optional<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Optional<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__customMirror_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Optional<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Optional<Foundation.Data>.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Bool_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Double_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_String_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_UInt8_u003E__debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func HostDispatcher_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Optional<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__debugDescription_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Optional<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Optional<Foundation.Data>.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Bool_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Double_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_String_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_UInt8_u003E__hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func HostDispatcher_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Optional<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__hashValue_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Optional<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Optional<Foundation.Data>.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__unsafelyUnwrapped_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.unsafelyUnwrapped expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Foundation.Data> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Foundation.Data>", as: Swift.Optional<Foundation.Data>.self) { host in
        host
    }
    let result = receiver.unsafelyUnwrapped
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Optional<Foundation.Data>"))
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Bool_u003E__unsafelyUnwrapped_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.unsafelyUnwrapped expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Bool>", as: Swift.Optional<Swift.Bool>.self) { host in
        host
    }
    let result = receiver.unsafelyUnwrapped
    return .bool(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Double_u003E__unsafelyUnwrapped_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.unsafelyUnwrapped expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Double>", as: Swift.Optional<Swift.Double>.self) { host in
        host
    }
    let result = receiver.unsafelyUnwrapped
    return .double(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_Int_u003E__unsafelyUnwrapped_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.unsafelyUnwrapped expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.Int>", as: Swift.Optional<Swift.Int>.self) { host in
        host
    }
    let result = receiver.unsafelyUnwrapped
    return .int(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_String_u003E__unsafelyUnwrapped_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.unsafelyUnwrapped expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.String>", as: Swift.Optional<Swift.String>.self) { host in
        host
    }
    let result = receiver.unsafelyUnwrapped
    return .string(result)
}

public func Host_Swift_u002E_Optional_u003C_Swift_u002E_UInt8_u003E__unsafelyUnwrapped_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.Optional<Wrapped>.unsafelyUnwrapped expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Optional<Swift.UInt8> host") }
    let receiver = try vm.withHost(args[0], typeName: "Optional<Swift.UInt8>", as: Swift.Optional<Swift.UInt8>.self) { host in
        host
    }
    let result = receiver.unsafelyUnwrapped
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Optional<Swift.UInt8>"))
}

public func HostDispatcher_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__unsafelyUnwrapped(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Optional<Foundation.Data>") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_Optional_u003C_Foundation_u002E_Data_u003E__unsafelyUnwrapped_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.Optional<Foundation.Data> ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.Optional<Foundation.Data>.unsafelyUnwrapped has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

