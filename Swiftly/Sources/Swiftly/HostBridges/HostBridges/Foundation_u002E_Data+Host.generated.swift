// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Foundation.Data

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data__u003D__u003D__u0028_d1_u003A_d2_u003A__u0029___op_eq_eq__Foundation_u002E_Data__Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.==(d1:d2:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let d1: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let d2: Foundation.Data = try vm.withHost(args[2], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let result = d1 == d2
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data__u003D__u003D__u0028_d1_u003A_d2_u003A__u0029___op_eq_eq__Foundation_u002E_Data__Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data__u003D__u003D__u0028_d1_u003A_d2_u003A__u0029___op_eq_eq__Foundation_u002E_Data__Foundation_u002E_Data(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.==(d1:d2:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (d1: Foundation.Data, d2: Foundation.Data)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.==(d1:d2:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data__u003D__u003D__u0028_d1_u003A_d2_u003A__u0029___op_eq_eq__Foundation_u002E_Data__Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data__u003D__u003D__u0028_d1_u003A_d2_u003A__u0029___op_eq_eq__Foundation_u002E_Data__Foundation_u002E_Data(vm: &vm, args) }
    throw VMError.unsupported("Data.==(d1:d2:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data__copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.UInt8>", as: Swift.UnsafeMutableBufferPointer<Swift.UInt8>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data__copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data__copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data._copyContents(initializing:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (initializing: Swift.UnsafeMutableBufferPointer<Swift.UInt8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data._copyContents(initializing:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data__copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data__copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Data._copyContents(initializing:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_advanced_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.advanced(by:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let amount = try args[1].expectInt("amount")
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.advanced(by: amount)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_advanced_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_advanced_u0028_by_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.advanced(by:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (by: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.advanced(by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_advanced_u0028_by_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_advanced_u0028_by_u003A__u0029___Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.advanced(by:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_append_u0028___u003A__u0029___Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.append(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let other: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { receiver in
        receiver.append(other)
        return args[0]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_append_u0028___u003A__u0029___Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_append_u0028___u003A__u0029___Foundation_u002E_Data(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.append(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (Foundation.Data)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.append(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_append_u0028___u003A__u0029___Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_append_u0028___u003A__u0029___Foundation_u002E_Data(vm: &vm, args) }
    throw VMError.unsupported("Data.append(_:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_append_u0028___u003A_count_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.append(_:count:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let bytes: Swift.UnsafePointer<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.UnsafePointer<Swift.UInt8>", as: Swift.UnsafePointer<Swift.UInt8>.self) { host in
        host
    }
    let count = try args[2].expectInt("count")
    return try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { receiver in
        receiver.append(bytes, count: count)
        return args[0]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_append_u0028___u003A_count_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_append_u0028___u003A_count_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.append(_:count:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (Swift.UnsafePointer<Swift.UInt8>, count: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.append(_:count:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_append_u0028___u003A_count_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_append_u0028___u003A_count_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.append(_:count:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_append_u0028_contentsOf_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.append(contentsOf:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    guard case let .array(bytes_arrayBox) = args[1] else { throw VMError.typeError("bytes expects Swift.Array<Swift.UInt8>") }
    var bytes_arrayValue: Swift.Array<Swift.UInt8> = []
    bytes_arrayValue.reserveCapacity(bytes_arrayBox.elements.count)
    for (index, elementValue) in bytes_arrayBox.elements.enumerated() {
        let bytes_element: Swift.UInt8 = try vm.withHost(elementValue, typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
            host
        }
        bytes_arrayValue.append(bytes_element)
    }
    let bytes = bytes_arrayValue
    return try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { receiver in
        receiver.append(contentsOf: bytes)
        return args[0]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_append_u0028_contentsOf_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_append_u0028_contentsOf_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.append(contentsOf:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (contentsOf: Swift.Array<Swift.UInt8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.append(contentsOf:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_append_u0028_contentsOf_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_append_u0028_contentsOf_u003A__u0029___Swift_u002E_Array_u003C_Swift_u002E_UInt8_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Data.append(contentsOf:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_base64EncodedData_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.base64EncodedData(options:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let options: Foundation.Data.Base64EncodingOptions = try vm.withHost(args[1], typeName: "Foundation.Data.Base64EncodingOptions", as: Foundation.Data.Base64EncodingOptions.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.base64EncodedData(options: options)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_base64EncodedData_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_base64EncodedData_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.base64EncodedData(options:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (options: Foundation.Data.Base64EncodingOptions)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.base64EncodedData(options:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_base64EncodedData_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_base64EncodedData_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: &vm, args) }
    throw VMError.unsupported("Data.base64EncodedData(options:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_base64EncodedString_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.base64EncodedString(options:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let options: Foundation.Data.Base64EncodingOptions = try vm.withHost(args[1], typeName: "Foundation.Data.Base64EncodingOptions", as: Foundation.Data.Base64EncodingOptions.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.base64EncodedString(options: options)
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_base64EncodedString_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_base64EncodedString_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.base64EncodedString(options:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (options: Foundation.Data.Base64EncodingOptions)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.base64EncodedString(options:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_base64EncodedString_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_base64EncodedString_u0028_options_u003A__u0029___Foundation_u002E_Data_u002E_Base64EncodingOptions(vm: &vm, args) }
    throw VMError.unsupported("Data.base64EncodedString(options:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_copyBytes_u0028_to_u003A__u0029___Swift_u002E_UnsafeMutableRawBufferPointer(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.copyBytes(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let ptr: Swift.UnsafeMutableRawBufferPointer = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableRawBufferPointer", as: Swift.UnsafeMutableRawBufferPointer.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.copyBytes(to: ptr)
    return .int(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A__u0029___Swift_u002E_UnsafeMutableRawBufferPointer(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_copyBytes_u0028_to_u003A__u0029___Swift_u002E_UnsafeMutableRawBufferPointer(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.copyBytes(to:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (to: Swift.UnsafeMutableRawBufferPointer)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.copyBytes(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A__u0029___Swift_u002E_UnsafeMutableRawBufferPointer(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A__u0029___Swift_u002E_UnsafeMutableRawBufferPointer(vm: &vm, args) }
    throw VMError.unsupported("Data.copyBytes(to:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_copyBytes_u0028_to_u003A_count_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.copyBytes(to:count:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let pointer: Swift.UnsafeMutablePointer<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutablePointer<Swift.UInt8>", as: Swift.UnsafeMutablePointer<Swift.UInt8>.self) { host in
        host
    }
    let count = try args[2].expectInt("count")
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    receiver.copyBytes(to: pointer, count: count)
    return .bool(true)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A_count_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_copyBytes_u0028_to_u003A_count_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.copyBytes(to:count:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (to: Swift.UnsafeMutablePointer<Swift.UInt8>, count: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.copyBytes(to:count:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A_count_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A_count_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.copyBytes(to:count:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_copyBytes_u0028_to_u003A_from_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.copyBytes(to:from:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let pointer: Swift.UnsafeMutablePointer<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutablePointer<Swift.UInt8>", as: Swift.UnsafeMutablePointer<Swift.UInt8>.self) { host in
        host
    }
    let range: Swift.Range<Foundation.Data.Index> = try vm.withHost(args[2], typeName: "Swift.Range<Foundation.Data.Index>", as: Swift.Range<Foundation.Data.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    receiver.copyBytes(to: pointer, from: range)
    return .bool(true)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A_from_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_copyBytes_u0028_to_u003A_from_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.copyBytes(to:from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (to: Swift.UnsafeMutablePointer<Swift.UInt8>, from: Swift.Range<Foundation.Data.Index>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.copyBytes(to:from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A_from_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_copyBytes_u0028_to_u003A_from_u003A__u0029___Swift_u002E_UnsafeMutablePointer_u003C_Swift_u002E_UInt8_u003E___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Data.copyBytes(to:from:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.encode(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let encoder: Swift.Encoder = try vm.withHost(args[1], typeName: "Swift.Encoder", as: Swift.Encoder.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    try receiver.encode(to: encoder)
    return .bool(true)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.encode(to:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (to: Swift.Encoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.encode(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args) }
    throw VMError.unsupported("Data.encode(to:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_index_u0028_after_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let i: Foundation.Data.Index = try vm.withHost(args[1], typeName: "Foundation.Data.Index", as: Foundation.Data.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_index_u0028_after_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_index_u0028_after_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.index(after:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (after: Foundation.Data.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.index(after:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_index_u0028_after_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_index_u0028_after_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: &vm, args) }
    throw VMError.unsupported("Data.index(after:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_index_u0028_before_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.index(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let i: Foundation.Data.Index = try vm.withHost(args[1], typeName: "Foundation.Data.Index", as: Foundation.Data.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.index(before: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_index_u0028_before_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_index_u0028_before_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.index(before:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (before: Foundation.Data.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.index(before:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_index_u0028_before_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_index_u0028_before_u003A__u0029___Foundation_u002E_Data_u002E_Index(vm: &vm, args) }
    throw VMError.unsupported("Data.index(before:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Data.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let result = Foundation.Data()
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028__u0029_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init() is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028__u0029_(vm: &vm, args) }
    throw VMError.unsupported("Data.init() is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_base64Encoded_u003A_options_u003A__u0029___Swift_u002E_String__Foundation_u002E_Data_u002E_Base64DecodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.init(base64Encoded:options:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let base64String = try args[1].expectString("base64String")
    let options: Foundation.Data.Base64DecodingOptions = try vm.withHost(args[2], typeName: "Foundation.Data.Base64DecodingOptions", as: Foundation.Data.Base64DecodingOptions.self) { host in
        host
    }
    let result = Foundation.Data(base64Encoded: base64String, options: options)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), tid)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_base64Encoded_u003A_options_u003A__u0029___Swift_u002E_String__Foundation_u002E_Data_u002E_Base64DecodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_base64Encoded_u003A_options_u003A__u0029___Swift_u002E_String__Foundation_u002E_Data_u002E_Base64DecodingOptions(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(base64Encoded:options:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (base64Encoded: Swift.String, options: Foundation.Data.Base64DecodingOptions)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(base64Encoded:options:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_base64Encoded_u003A_options_u003A__u0029___Swift_u002E_String__Foundation_u002E_Data_u002E_Base64DecodingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_base64Encoded_u003A_options_u003A__u0029___Swift_u002E_String__Foundation_u002E_Data_u002E_Base64DecodingOptions(vm: &vm, args) }
    throw VMError.unsupported("Data.init(base64Encoded:options:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Foundation_u002E_Data_u003E___SourceType_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(buffer:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let buffer: Swift.UnsafeBufferPointer<Foundation.Data> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Foundation.Data>", as: Swift.UnsafeBufferPointer<Foundation.Data>.self) { host in
        host
    }
    let result = Foundation.Data(buffer: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_Bool_u003E___SourceType_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(buffer:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let buffer: Swift.UnsafeBufferPointer<Swift.Bool> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Swift.Bool>", as: Swift.UnsafeBufferPointer<Swift.Bool>.self) { host in
        host
    }
    let result = Foundation.Data(buffer: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_Double_u003E___SourceType_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(buffer:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let buffer: Swift.UnsafeBufferPointer<Swift.Double> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Swift.Double>", as: Swift.UnsafeBufferPointer<Swift.Double>.self) { host in
        host
    }
    let result = Foundation.Data(buffer: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_Int_u003E___SourceType_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(buffer:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let buffer: Swift.UnsafeBufferPointer<Swift.Int> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Swift.Int>", as: Swift.UnsafeBufferPointer<Swift.Int>.self) { host in
        host
    }
    let result = Foundation.Data(buffer: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_String_u003E___SourceType_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(buffer:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let buffer: Swift.UnsafeBufferPointer<Swift.String> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Swift.String>", as: Swift.UnsafeBufferPointer<Swift.String>.self) { host in
        host
    }
    let result = Foundation.Data(buffer: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt8_u003E___SourceType_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(buffer:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let buffer: Swift.UnsafeBufferPointer<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Swift.UInt8>", as: Swift.UnsafeBufferPointer<Swift.UInt8>.self) { host in
        host
    }
    let result = Foundation.Data(buffer: buffer)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_SourceType_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Foundation_u002E_Data_u003E___SourceType_Foundation_u002E_Data(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(buffer:) is not available on this platform")
        }
    }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_Bool_u003E___SourceType_Swift_u002E_Bool(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(buffer:) is not available on this platform")
        }
    }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_Double_u003E___SourceType_Swift_u002E_Double(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(buffer:) is not available on this platform")
        }
    }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_Int_u003E___SourceType_Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(buffer:) is not available on this platform")
        }
    }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_String_u003E___SourceType_Swift_u002E_String(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(buffer:) is not available on this platform")
        }
    }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt8_u003E___SourceType_Swift_u002E_UInt8(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(buffer:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (buffer: Swift.UnsafeBufferPointer<Foundation.Data>)",
        "  - Foundation.Data (buffer: Swift.UnsafeBufferPointer<Swift.Bool>)",
        "  - Foundation.Data (buffer: Swift.UnsafeBufferPointer<Swift.Double>)",
        "  - Foundation.Data (buffer: Swift.UnsafeBufferPointer<Swift.Int>)",
        "  - Foundation.Data (buffer: Swift.UnsafeBufferPointer<Swift.String>)",
        "  - Foundation.Data (buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(buffer:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_SourceType_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_buffer_u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_SourceType_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Data.init(buffer:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_bytes_u003A_count_u003A__u0029___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.init(bytes:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let bytes: Swift.UnsafeRawPointer = try vm.withHost(args[1], typeName: "Swift.UnsafeRawPointer", as: Swift.UnsafeRawPointer.self) { host in
        host
    }
    let count = try args[2].expectInt("count")
    let result = Foundation.Data(bytes: bytes, count: count)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_bytes_u003A_count_u003A__u0029___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_bytes_u003A_count_u003A__u0029___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(bytes:count:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (bytes: Swift.UnsafeRawPointer, count: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(bytes:count:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_bytes_u003A_count_u003A__u0029___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_bytes_u003A_count_u003A__u0029___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.init(bytes:count:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_bytesNoCopy_u003A_count_u003A_deallocator_u003A__u0029___Swift_u002E_UnsafeMutableRawPointer__Swift_u002E_Int__Foundation_u002E_Data_u002E_Deallocator(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Data.init(bytesNoCopy:count:deallocator:) expects 3 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let bytes: Swift.UnsafeMutableRawPointer = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableRawPointer", as: Swift.UnsafeMutableRawPointer.self) { host in
        host
    }
    let count = try args[2].expectInt("count")
    let deallocator: Foundation.Data.Deallocator = try vm.withHost(args[3], typeName: "Foundation.Data.Deallocator", as: Foundation.Data.Deallocator.self) { host in
        host
    }
    let result = Foundation.Data(bytesNoCopy: bytes, count: count, deallocator: deallocator)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_bytesNoCopy_u003A_count_u003A_deallocator_u003A__u0029___Swift_u002E_UnsafeMutableRawPointer__Swift_u002E_Int__Foundation_u002E_Data_u002E_Deallocator(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_bytesNoCopy_u003A_count_u003A_deallocator_u003A__u0029___Swift_u002E_UnsafeMutableRawPointer__Swift_u002E_Int__Foundation_u002E_Data_u002E_Deallocator(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(bytesNoCopy:count:deallocator:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (bytesNoCopy: Swift.UnsafeMutableRawPointer, count: Swift.Int, deallocator: Foundation.Data.Deallocator)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(bytesNoCopy:count:deallocator:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_bytesNoCopy_u003A_count_u003A_deallocator_u003A__u0029___Swift_u002E_UnsafeMutableRawPointer__Swift_u002E_Int__Foundation_u002E_Data_u002E_Deallocator(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_bytesNoCopy_u003A_count_u003A_deallocator_u003A__u0029___Swift_u002E_UnsafeMutableRawPointer__Swift_u002E_Int__Foundation_u002E_Data_u002E_Deallocator(vm: &vm, args) }
    throw VMError.unsupported("Data.init(bytesNoCopy:count:deallocator:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_capacity_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(capacity:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let capacity = try args[1].expectInt("capacity")
    let result = Foundation.Data(capacity: capacity)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_capacity_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_capacity_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(capacity:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (capacity: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(capacity:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_capacity_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_capacity_u003A__u0029___Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.init(capacity:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_contentsOf_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_ReadingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.init(contentsOf:options:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let url: Foundation.URL = try vm.withHost(args[1], typeName: "Foundation.URL", as: Foundation.URL.self) { host in
        host
    }
    let options: Foundation.Data.ReadingOptions = try vm.withHost(args[2], typeName: "Foundation.Data.ReadingOptions", as: Foundation.Data.ReadingOptions.self) { host in
        host
    }
    let result = try Foundation.Data(contentsOf: url, options: options)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_contentsOf_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_ReadingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_contentsOf_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_ReadingOptions(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(contentsOf:options:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (contentsOf: Foundation.URL, options: Foundation.Data.ReadingOptions)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(contentsOf:options:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_contentsOf_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_ReadingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_contentsOf_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_ReadingOptions(vm: &vm, args) }
    throw VMError.unsupported("Data.init(contentsOf:options:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_count_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(count:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let count = try args[1].expectInt("count")
    let result = Foundation.Data(count: count)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_count_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_count_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(count:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (count: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(count:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_count_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_count_u003A__u0029___Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.init(count:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.init(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let decoder: Swift.Decoder = try vm.withHost(args[1], typeName: "Swift.Decoder", as: Swift.Decoder.self) { host in
        host
    }
    let result = try Foundation.Data(from: decoder)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (from: Swift.Decoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args) }
    throw VMError.unsupported("Data.init(from:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.init(repeating:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Data metatype") }
    let repeatedValue: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    let count = try args[2].expectInt("count")
    let result = Foundation.Data(repeating: repeatedValue, count: count)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.init(repeating:count:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (repeating: Swift.UInt8, count: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.init(repeating:count:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_UInt8__Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.init(repeating:count:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_makeIterator_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Data.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_makeIterator_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_makeIterator_u0028__u0029_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.makeIterator() is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.makeIterator() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_makeIterator_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_makeIterator_u0028__u0029_(vm: &vm, args) }
    throw VMError.unsupported("Data.makeIterator() is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_range_u0028_of_u003A_options_u003A_in_u003A__u0029___Foundation_u002E_Data__Foundation_u002E_Data_u002E_SearchOptions__Swift_u002E_Optional_u003C_Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E__u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Data.range(of:options:in:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let dataToFind: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let options: Foundation.Data.SearchOptions = try vm.withHost(args[2], typeName: "Foundation.Data.SearchOptions", as: Foundation.Data.SearchOptions.self) { host in
        host
    }
    var range: Swift.Range<Foundation.Data.Index>? = nil
    if case .nilValue = args[3] {
        range = nil
    } else {
        range = try vm.withHost(args[3], typeName: "Swift.Range<Foundation.Data.Index>", as: Swift.Range<Foundation.Data.Index>.self) { host in
            host
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.range(of: dataToFind, options: options, in: range)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Data"))
    case .none:
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_range_u0028_of_u003A_options_u003A_in_u003A__u0029___Foundation_u002E_Data__Foundation_u002E_Data_u002E_SearchOptions__Swift_u002E_Optional_u003C_Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E__u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_range_u0028_of_u003A_options_u003A_in_u003A__u0029___Foundation_u002E_Data__Foundation_u002E_Data_u002E_SearchOptions__Swift_u002E_Optional_u003C_Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E__u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.range(of:options:in:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (of: Foundation.Data, options: Foundation.Data.SearchOptions, in: Swift.Optional<Swift.Range<Foundation.Data.Index>>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.range(of:options:in:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_range_u0028_of_u003A_options_u003A_in_u003A__u0029___Foundation_u002E_Data__Foundation_u002E_Data_u002E_SearchOptions__Swift_u002E_Optional_u003C_Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E__u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_range_u0028_of_u003A_options_u003A_in_u003A__u0029___Foundation_u002E_Data__Foundation_u002E_Data_u002E_SearchOptions__Swift_u002E_Optional_u003C_Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E__u003E_(vm: &vm, args) }
    throw VMError.unsupported("Data.range(of:options:in:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.replaceSubrange(_:with:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let subrange: Swift.Range<Foundation.Data.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Foundation.Data.Index>", as: Swift.Range<Foundation.Data.Index>.self) { host in
        host
    }
    let data: Foundation.Data = try vm.withHost(args[2], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { receiver in
        receiver.replaceSubrange(subrange, with: data)
        return args[0]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Foundation_u002E_Data(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.replaceSubrange(_:with:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (Swift.Range<Foundation.Data.Index>, with: Foundation.Data)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.replaceSubrange(_:with:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Foundation_u002E_Data(vm: &vm, args) }
    throw VMError.unsupported("Data.replaceSubrange(_:with:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A_count_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("Data.replaceSubrange(_:with:count:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let subrange: Swift.Range<Foundation.Data.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Foundation.Data.Index>", as: Swift.Range<Foundation.Data.Index>.self) { host in
        host
    }
    let bytes: Swift.UnsafeRawPointer = try vm.withHost(args[2], typeName: "Swift.UnsafeRawPointer", as: Swift.UnsafeRawPointer.self) { host in
        host
    }
    let cnt = try args[3].expectInt("cnt")
    return try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { receiver in
        receiver.replaceSubrange(subrange, with: bytes, count: cnt)
        return args[0]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A_count_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A_count_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.replaceSubrange(_:with:count:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (Swift.Range<Foundation.Data.Index>, with: Swift.UnsafeRawPointer, count: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.replaceSubrange(_:with:count:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A_count_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_replaceSubrange_u0028___u003A_with_u003A_count_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E___Swift_u002E_UnsafeRawPointer__Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.replaceSubrange(_:with:count:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let minimumCapacity = try args[1].expectInt("minimumCapacity")
    return try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { receiver in
        receiver.reserveCapacity(minimumCapacity)
        return args[0]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.reserveCapacity(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.reserveCapacity(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args) }
    throw VMError.unsupported("Data.reserveCapacity(_:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_resetBytes_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.resetBytes(in:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let range: Swift.Range<Foundation.Data.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Foundation.Data.Index>", as: Swift.Range<Foundation.Data.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { receiver in
        receiver.resetBytes(in: range)
        return args[0]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_resetBytes_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_resetBytes_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.resetBytes(in:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (in: Swift.Range<Foundation.Data.Index>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.resetBytes(in:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_resetBytes_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_resetBytes_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Data.resetBytes(in:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_subdata_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Data.subdata(in:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let range: Swift.Range<Foundation.Data.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Foundation.Data.Index>", as: Swift.Range<Foundation.Data.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.subdata(in: range)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_subdata_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_subdata_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.subdata(in:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (in: Swift.Range<Foundation.Data.Index>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.subdata(in:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_subdata_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_subdata_u0028_in_u003A__u0029___Swift_u002E_Range_u003C_Foundation_u002E_Data_u002E_Index_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Data.subdata(in:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_write_u0028_to_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_WritingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Data.write(to:options:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let url: Foundation.URL = try vm.withHost(args[1], typeName: "Foundation.URL", as: Foundation.URL.self) { host in
        host
    }
    let options: Foundation.Data.WritingOptions = try vm.withHost(args[2], typeName: "Foundation.Data.WritingOptions", as: Foundation.Data.WritingOptions.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    try receiver.write(to: url, options: options)
    return .bool(true)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_write_u0028_to_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_WritingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Data_write_u0028_to_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_WritingOptions(vm: &vm, args)
        } else {
            throw VMError.unsupported("Data.write(to:options:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (to: Foundation.URL, options: Foundation.Data.WritingOptions)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Data.write(to:options:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_write_u0028_to_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_WritingOptions(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_write_u0028_to_u003A_options_u003A__u0029___Foundation_u002E_URL__Foundation_u002E_Data_u002E_WritingOptions(vm: &vm, args) }
    throw VMError.unsupported("Data.write(to:options:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.count expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.count
    return .int(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_count(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_count_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.count is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.count has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSet_Foundation_u002E_Data_count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Foundation.Data.count setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let newValue = try args[1].expectInt("count")
    return try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { receiver in
        receiver.count = newValue
        return .nilValue
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostSetter_Foundation_u002E_Data_count(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "Data") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try HostSet_Foundation_u002E_Data_count_instance(vm: &vm, args)
        } else {
            throw VMError.unsupported("Setter for Foundation.Data.count is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Data (value: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Foundation.Data.count has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_count(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_count(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.count is not available on this platform")
}

public func HostAvailWrap_HostSetter_Foundation_u002E_Data_count(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostSetter_Foundation_u002E_Data_count(vm: &vm, args) }
    throw VMError.unsupported("Setter for Foundation.Data.count is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_customMirror_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.customMirror is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_customMirror(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.customMirror is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_debugDescription_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.debugDescription is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_debugDescription(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.debugDescription is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_description_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.description is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_description(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_description(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.description is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_endIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.endIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.endIndex
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_endIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_endIndex_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.endIndex is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.endIndex has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_endIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_endIndex(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.endIndex is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_hashValue_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.hashValue is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_hashValue(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.hashValue is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_indices_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.indices expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.indices
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_indices(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_indices_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.indices is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.indices has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_indices(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_indices(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.indices is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_regions_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.regions expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.regions
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_regions(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_regions_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.regions is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.regions has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_regions(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_regions(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.regions is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Data_startIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Data.startIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Data host") }
    let receiver = try vm.withHost(args[0], typeName: "Data", as: Foundation.Data.self) { host in
        host
    }
    let result = receiver.startIndex
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Data"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Data_startIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Data") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Data_startIndex_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Data.startIndex is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Data ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Data.startIndex has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Data_startIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Data_startIndex(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Data.startIndex is not available on this platform")
}

