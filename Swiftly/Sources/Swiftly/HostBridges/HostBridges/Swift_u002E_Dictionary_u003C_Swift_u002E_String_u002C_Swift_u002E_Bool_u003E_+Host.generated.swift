// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.Dictionary<Swift.String,Swift.Bool>

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Swift.Bool>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Swift.Bool> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value = try rawValue.expectBool("lhs[\(rawKey)]")
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Swift.Bool>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Swift.Bool> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value = try rawValue.expectBool("rhs[\(rawKey)]")
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Swift.Double>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Swift.Double> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value = try rawValue.expectDouble("lhs[\(rawKey)]")
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Swift.Double>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Swift.Double> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value = try rawValue.expectDouble("rhs[\(rawKey)]")
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Swift.Int>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Swift.Int> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value = try rawValue.expectInt("lhs[\(rawKey)]")
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Swift.Int>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Swift.Int> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value = try rawValue.expectInt("rhs[\(rawKey)]")
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs == rhs
    return .bool(result)
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Dictionary.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> metatype") }
    guard case let .dict(lhs_dictBox) = args[1] else { throw VMError.typeError("lhs expects Swift.Dictionary<Swift.String,Swift.String>") }
    var lhs_dictValue: Swift.Dictionary<Swift.String,Swift.String> = [:]
    for (rawKey, rawValue) in lhs_dictBox.storage {
        let lhs_value = try rawValue.expectString("lhs[\(rawKey)]")
        lhs_dictValue[rawKey] = lhs_value
    }
    let lhs = lhs_dictValue
    guard case let .dict(rhs_dictBox) = args[2] else { throw VMError.typeError("rhs expects Swift.Dictionary<Swift.String,Swift.String>") }
    var rhs_dictValue: Swift.Dictionary<Swift.String,Swift.String> = [:]
    for (rawKey, rawValue) in rhs_dictBox.storage {
        let rhs_value = try rawValue.expectString("rhs[\(rawKey)]")
        rhs_dictValue[rawKey] = rhs_value
    }
    let rhs = rhs_dictValue
    let result = lhs == rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Bool_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Double_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_Int_u003E___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
        return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E___Swift_u002E_Dictionary_u003C_Swift_u002E_String_u002C_Swift_u002E_String_u003E___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.Dictionary<Swift.String,Swift.Bool> (lhs: Swift.Dictionary<Swift.String,Swift.Bool>, rhs: Swift.Dictionary<Swift.String,Swift.Bool>)",
        "  - Swift.Dictionary<Swift.String,Swift.Double> (lhs: Swift.Dictionary<Swift.String,Swift.Double>, rhs: Swift.Dictionary<Swift.String,Swift.Double>)",
        "  - Swift.Dictionary<Swift.String,Swift.Int> (lhs: Swift.Dictionary<Swift.String,Swift.Int>, rhs: Swift.Dictionary<Swift.String,Swift.Int>)",
        "  - Swift.Dictionary<Swift.String,Swift.String> (lhs: Swift.Dictionary<Swift.String,Swift.String>, rhs: Swift.Dictionary<Swift.String,Swift.String>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Dictionary.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Bool> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Bool>", as: Swift.Dictionary<Swift.String,Swift.Bool>.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Bool>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Double> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Double>", as: Swift.Dictionary<Swift.String,Swift.Double>.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Double>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.Int> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.Int>", as: Swift.Dictionary<Swift.String,Swift.Int>.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.Int>"))
    case .none:
        return .nilValue
    }
}

public func Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Dictionary._toCustomAnyHashable() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Dictionary<Swift.String,Swift.String> host") }
    let receiver = try vm.withHost(args[0], typeName: "Dictionary<Swift.String,Swift.String>", as: Swift.Dictionary<Swift.String,Swift.String>.self) { host in
        host
    }
    let result = receiver._toCustomAnyHashable()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "Dictionary<Swift.String,Swift.String>"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    // Path 1: Host receiver
    if case let .host(_, tid) = args[0] {
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, args)
        }
        if tid == vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>") {
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, args)
        }
        let receiverName = vm.debugTypeName(tid)
        let supported = [
            "  - Swift.Dictionary<Swift.String,Swift.Bool> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Double> ()",
            "  - Swift.Dictionary<Swift.String,Swift.Int> ()",
            "  - Swift.Dictionary<Swift.String,Swift.String> ()",
        ] .joined(separator: "\n")
        throw VMError.typeError("Dictionary._toCustomAnyHashable() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
    }
    // Path 2: VM-native dictionary receiver
    else if case let .dict(box) = args[0] {
        // VM dictionaries always have String keys
        guard !box.storage.isEmpty else {
            throw VMError.typeError("Cannot infer value type from empty dictionary")
        }
        // Infer value type from first value
        let sampleValue = box.storage.values.first!
        
        if case .bool = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Bool> inline
            var hostDict: [String: Bool] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .bool(value) = valueVal else { throw VMError.typeError("Expected Bool") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Bool>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Bool(vm: &vm, convertedArgs)
        }
        if case .double = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Double> inline
            var hostDict: [String: Double] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .double(value) = valueVal else { throw VMError.typeError("Expected Double") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Double>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Double(vm: &vm, convertedArgs)
        }
        if case .int = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.Int> inline
            var hostDict: [String: Int] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .int(value) = valueVal else { throw VMError.typeError("Expected Int") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.Int>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_Int(vm: &vm, convertedArgs)
        }
        if case .string = sampleValue {
            // Convert VM dictionary to host dictionary of <Swift.String, Swift.String> inline
            var hostDict: [String: String] = [:]
            for (keyString, valueVal) in box.storage {
                guard case let .string(value) = valueVal else { throw VMError.typeError("Expected String") }
                hostDict[keyString] = value
            }
            let hostDictRef = HostRef(box: makeOpaqueBox(hostDict))
            let hostDictValue = Value.host(hostDictRef, vm.hostTypeID(named: "Swift.Dictionary<Swift.String,Swift.String>"))
            var convertedArgs = args
            convertedArgs[0] = hostDictValue
            return try Host_Swift_u002E_Dictionary_u003C_Key_u002C_Value_u003E___toCustomAnyHashable_u0028__u0029___Key_Swift_u002E_String__Value_Swift_u002E_String(vm: &vm, convertedArgs)
        }
        throw VMError.typeError("Dictionary value type not supported for Dictionary._toCustomAnyHashable()")
    }
    throw VMError.typeError("receiver must be host or VM-native Swift.Dictionary<Key,Value>")
}

