// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Foundation.Date

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Date.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let lhs: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs + rhs
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Date"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.+(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (lhs: Foundation.Date, rhs: Foundation.TimeInterval)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.+(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: &vm, args) }
    throw VMError.unsupported("Date.+(lhs:rhs:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Date.-(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let lhs: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let rhs = try args[2].expectDouble("rhs")
    let result = lhs - rhs
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Date"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.-(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (lhs: Foundation.Date, rhs: Foundation.TimeInterval)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.-(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date__u002D__u0028_lhs_u003A_rhs_u003A__u0029___op_minus__Foundation_u002E_Date__Foundation_u002E_TimeInterval(vm: &vm, args) }
    throw VMError.unsupported("Date.-(lhs:rhs:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Date.<(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let lhs: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let rhs: Foundation.Date = try vm.withHost(args[2], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let result = lhs < rhs
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Foundation_u002E_Date__Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.<(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (lhs: Foundation.Date, rhs: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.<(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Foundation_u002E_Date__Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("Date.<(lhs:rhs:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Date.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let lhs: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let rhs: Foundation.Date = try vm.withHost(args[2], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let result = lhs == rhs
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Date__Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.==(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (lhs: Foundation.Date, rhs: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Foundation_u002E_Date__Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("Date.==(lhs:rhs:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Date.>(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let lhs: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let rhs: Foundation.Date = try vm.withHost(args[2], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let result = lhs > rhs
    return .bool(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Foundation_u002E_Date__Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.>(lhs:rhs:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (lhs: Foundation.Date, rhs: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.>(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Foundation_u002E_Date__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Foundation_u002E_Date__Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("Date.>(lhs:rhs:) is not available on this platform")
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public func Host_Foundation_u002E_Date_ISO8601Format_u0028___u003A__u0029___Foundation_u002E_Date_u002E_ISO8601FormatStyle(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.ISO8601Format(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let style: Foundation.Date.ISO8601FormatStyle = try vm.withHost(args[1], typeName: "Foundation.Date.ISO8601FormatStyle", as: Foundation.Date.ISO8601FormatStyle.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.ISO8601Format(style)
    return .string(result)
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public func HostDispatcher_Foundation_u002E_Date_ISO8601Format_u0028___u003A__u0029___Foundation_u002E_Date_u002E_ISO8601FormatStyle(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *) {
            return try Host_Foundation_u002E_Date_ISO8601Format_u0028___u003A__u0029___Foundation_u002E_Date_u002E_ISO8601FormatStyle(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.ISO8601Format(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (Foundation.Date.ISO8601FormatStyle)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.ISO8601Format(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_ISO8601Format_u0028___u003A__u0029___Foundation_u002E_Date_u002E_ISO8601FormatStyle(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *) { return try HostDispatcher_Foundation_u002E_Date_ISO8601Format_u0028___u003A__u0029___Foundation_u002E_Date_u002E_ISO8601FormatStyle(vm: &vm, args) }
    throw VMError.unsupported("Date.ISO8601Format(_:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_addTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.addTimeInterval(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let timeInterval = try args[1].expectDouble("timeInterval")
    return try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { receiver in
        receiver.addTimeInterval(timeInterval)
        return args[0]
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_addTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_addTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.addTimeInterval(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (Foundation.TimeInterval)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.addTimeInterval(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_addTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_addTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args) }
    throw VMError.unsupported("Date.addTimeInterval(_:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_addingTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.addingTimeInterval(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let timeInterval = try args[1].expectDouble("timeInterval")
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.addingTimeInterval(timeInterval)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Date"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_addingTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_addingTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.addingTimeInterval(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (Foundation.TimeInterval)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.addingTimeInterval(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_addingTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_addingTimeInterval_u0028___u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args) }
    throw VMError.unsupported("Date.addingTimeInterval(_:) is not available on this platform")
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func Host_Foundation_u002E_Date_advanced_u0028_by_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.advanced(by:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let n = try args[1].expectDouble("n")
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.advanced(by: n)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Date"))
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func HostDispatcher_Foundation_u002E_Date_advanced_u0028_by_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
            return try Host_Foundation_u002E_Date_advanced_u0028_by_u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.advanced(by:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (by: Foundation.TimeInterval)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.advanced(by:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_advanced_u0028_by_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) { return try HostDispatcher_Foundation_u002E_Date_advanced_u0028_by_u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args) }
    throw VMError.unsupported("Date.advanced(by:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_compare_u0028___u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.compare(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let other: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.compare(other)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Date"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_compare_u0028___u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_compare_u0028___u003A__u0029___Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.compare(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.compare(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_compare_u0028___u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_compare_u0028___u003A__u0029___Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("Date.compare(_:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_description_u0028_with_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.description(with:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    var locale: Foundation.Locale? = nil
    if case .nilValue = args[1] {
        locale = nil
    } else {
        locale = try vm.withHost(args[1], typeName: "Foundation.Locale", as: Foundation.Locale.self) { host in
            host
        }
    }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.description(with: locale)
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_description_u0028_with_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_description_u0028_with_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.description(with:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (with: Swift.Optional<Foundation.Locale>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.description(with:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_description_u0028_with_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_description_u0028_with_u003A__u0029___Swift_u002E_Optional_u003C_Foundation_u002E_Locale_u003E_(vm: &vm, args) }
    throw VMError.unsupported("Date.description(with:) is not available on this platform")
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func Host_Foundation_u002E_Date_distance_u0028_to_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.distance(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let other: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.distance(to: other)
    return .double(result)
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func HostDispatcher_Foundation_u002E_Date_distance_u0028_to_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
            return try Host_Foundation_u002E_Date_distance_u0028_to_u003A__u0029___Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.distance(to:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (to: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.distance(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_distance_u0028_to_u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) { return try HostDispatcher_Foundation_u002E_Date_distance_u0028_to_u003A__u0029___Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("Date.distance(to:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.encode(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let encoder: Swift.Encoder = try vm.withHost(args[1], typeName: "Swift.Encoder", as: Swift.Encoder.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    try receiver.encode(to: encoder)
    return .bool(true)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.encode(to:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (to: Swift.Encoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.encode(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args) }
    throw VMError.unsupported("Date.encode(to:) is not available on this platform")
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public func Host_Foundation_u002E_Date_formatted_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Date.formatted() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.formatted()
    return .string(result)
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public func HostDispatcher_Foundation_u002E_Date_formatted_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *) {
            return try Host_Foundation_u002E_Date_formatted_u0028__u0029_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.formatted() is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.formatted() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_formatted_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *) { return try HostDispatcher_Foundation_u002E_Date_formatted_u0028__u0029_(vm: &vm, args) }
    throw VMError.unsupported("Date.formatted() is not available on this platform")
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public func Host_Foundation_u002E_Date_formatted_u0028_date_u003A_time_u003A__u0029___Foundation_u002E_Date_u002E_FormatStyle_u002E_DateStyle__Foundation_u002E_Date_u002E_FormatStyle_u002E_TimeStyle(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Date.formatted(date:time:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let date: Foundation.Date.FormatStyle.DateStyle = try vm.withHost(args[1], typeName: "Foundation.Date.FormatStyle.DateStyle", as: Foundation.Date.FormatStyle.DateStyle.self) { host in
        host
    }
    let time: Foundation.Date.FormatStyle.TimeStyle = try vm.withHost(args[2], typeName: "Foundation.Date.FormatStyle.TimeStyle", as: Foundation.Date.FormatStyle.TimeStyle.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.formatted(date: date, time: time)
    return .string(result)
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public func HostDispatcher_Foundation_u002E_Date_formatted_u0028_date_u003A_time_u003A__u0029___Foundation_u002E_Date_u002E_FormatStyle_u002E_DateStyle__Foundation_u002E_Date_u002E_FormatStyle_u002E_TimeStyle(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *) {
            return try Host_Foundation_u002E_Date_formatted_u0028_date_u003A_time_u003A__u0029___Foundation_u002E_Date_u002E_FormatStyle_u002E_DateStyle__Foundation_u002E_Date_u002E_FormatStyle_u002E_TimeStyle(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.formatted(date:time:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (date: Foundation.Date.FormatStyle.DateStyle, time: Foundation.Date.FormatStyle.TimeStyle)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.formatted(date:time:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_formatted_u0028_date_u003A_time_u003A__u0029___Foundation_u002E_Date_u002E_FormatStyle_u002E_DateStyle__Foundation_u002E_Date_u002E_FormatStyle_u002E_TimeStyle(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *) { return try HostDispatcher_Foundation_u002E_Date_formatted_u0028_date_u003A_time_u003A__u0029___Foundation_u002E_Date_u002E_FormatStyle_u002E_DateStyle__Foundation_u002E_Date_u002E_FormatStyle_u002E_TimeStyle(vm: &vm, args) }
    throw VMError.unsupported("Date.formatted(date:time:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Date.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let result = Foundation.Date()
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_init_u0028__u0029_(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.init() is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.init() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_init_u0028__u0029_(vm: &vm, args) }
    throw VMError.unsupported("Date.init() is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.init(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let decoder: Swift.Decoder = try vm.withHost(args[1], typeName: "Swift.Decoder", as: Swift.Decoder.self) { host in
        host
    }
    let result = try Foundation.Date(from: decoder)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.init(from:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (from: Swift.Decoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.init(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args) }
    throw VMError.unsupported("Date.init(from:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_init_u0028_timeInterval_u003A_since_u003A__u0029___Foundation_u002E_TimeInterval__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("Date.init(timeInterval:since:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let timeInterval = try args[1].expectDouble("timeInterval")
    let date: Foundation.Date = try vm.withHost(args[2], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let result = Foundation.Date(timeInterval: timeInterval, since: date)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_init_u0028_timeInterval_u003A_since_u003A__u0029___Foundation_u002E_TimeInterval__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_init_u0028_timeInterval_u003A_since_u003A__u0029___Foundation_u002E_TimeInterval__Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.init(timeInterval:since:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (timeInterval: Foundation.TimeInterval, since: Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.init(timeInterval:since:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_init_u0028_timeInterval_u003A_since_u003A__u0029___Foundation_u002E_TimeInterval__Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_init_u0028_timeInterval_u003A_since_u003A__u0029___Foundation_u002E_TimeInterval__Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("Date.init(timeInterval:since:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_init_u0028_timeIntervalSince1970_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.init(timeIntervalSince1970:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let timeIntervalSince1970 = try args[1].expectDouble("timeIntervalSince1970")
    let result = Foundation.Date(timeIntervalSince1970: timeIntervalSince1970)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSince1970_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_init_u0028_timeIntervalSince1970_u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.init(timeIntervalSince1970:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (timeIntervalSince1970: Foundation.TimeInterval)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.init(timeIntervalSince1970:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSince1970_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSince1970_u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args) }
    throw VMError.unsupported("Date.init(timeIntervalSince1970:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_init_u0028_timeIntervalSinceNow_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.init(timeIntervalSinceNow:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let timeIntervalSinceNow = try args[1].expectDouble("timeIntervalSinceNow")
    let result = Foundation.Date(timeIntervalSinceNow: timeIntervalSinceNow)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSinceNow_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_init_u0028_timeIntervalSinceNow_u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.init(timeIntervalSinceNow:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (timeIntervalSinceNow: Foundation.TimeInterval)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.init(timeIntervalSinceNow:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSinceNow_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSinceNow_u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args) }
    throw VMError.unsupported("Date.init(timeIntervalSinceNow:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_init_u0028_timeIntervalSinceReferenceDate_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.init(timeIntervalSinceReferenceDate:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let ti = try args[1].expectDouble("ti")
    let result = Foundation.Date(timeIntervalSinceReferenceDate: ti)
    return .host(HostRef(box: makeOpaqueBox(result)), tid)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSinceReferenceDate_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_init_u0028_timeIntervalSinceReferenceDate_u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.init(timeIntervalSinceReferenceDate:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (timeIntervalSinceReferenceDate: Foundation.TimeInterval)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.init(timeIntervalSinceReferenceDate:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSinceReferenceDate_u003A__u0029___Foundation_u002E_TimeInterval(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_init_u0028_timeIntervalSinceReferenceDate_u003A__u0029___Foundation_u002E_TimeInterval(vm: &vm, args) }
    throw VMError.unsupported("Date.init(timeIntervalSinceReferenceDate:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_timeIntervalSince_u0028___u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Date.timeIntervalSince(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let date: Foundation.Date = try vm.withHost(args[1], typeName: "Foundation.Date", as: Foundation.Date.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.timeIntervalSince(date)
    return .double(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_timeIntervalSince_u0028___u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Foundation.Date") {
        if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) {
            return try Host_Foundation_u002E_Date_timeIntervalSince_u0028___u003A__u0029___Foundation_u002E_Date(vm: &vm, args)
        } else {
            throw VMError.unsupported("Date.timeIntervalSince(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Foundation.Date (Foundation.Date)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Date.timeIntervalSince(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_timeIntervalSince_u0028___u003A__u0029___Foundation_u002E_Date(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_timeIntervalSince_u0028___u003A__u0029___Foundation_u002E_Date(vm: &vm, args) }
    throw VMError.unsupported("Date.timeIntervalSince(_:) is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Date"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Date_customMirror_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.customMirror is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_customMirror(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.customMirror is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
public func Host_Foundation_u002E_Date_customPlaygroundQuickLook_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.customPlaygroundQuickLook expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.customPlaygroundQuickLook
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Date"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
public func HostDispatcher_Foundation_u002E_Date_customPlaygroundQuickLook(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Date_customPlaygroundQuickLook_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.customPlaygroundQuickLook is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.customPlaygroundQuickLook has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_customPlaygroundQuickLook(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_customPlaygroundQuickLook(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.customPlaygroundQuickLook is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Date_debugDescription_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.debugDescription is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_debugDescription(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.debugDescription is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Date_description_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.description is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_description(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_description(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.description is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Date_hashValue_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.hashValue is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_hashValue(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.hashValue is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public func Host_Foundation_u002E_Date_now_static(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.now expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be Date metatype") }
    let result = Foundation.Date.now
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "Date"))
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public func HostDispatcher_Foundation_u002E_Date_now(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .metatype:
            if #available(macOS 12, iOS 15, tvOS 15, watchOS 8, *) { return try Host_Foundation_u002E_Date_now_static(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.now is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.now has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_now(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 12, iOS 15, tvOS 15, watchOS 8, *) { return try HostDispatcher_Foundation_u002E_Date_now(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.now is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_timeIntervalSince1970_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.timeIntervalSince1970 expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.timeIntervalSince1970
    return .double(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_timeIntervalSince1970(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Date_timeIntervalSince1970_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.timeIntervalSince1970 is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.timeIntervalSince1970 has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_timeIntervalSince1970(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_timeIntervalSince1970(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.timeIntervalSince1970 is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_timeIntervalSinceNow_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.timeIntervalSinceNow expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.timeIntervalSinceNow
    return .double(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_timeIntervalSinceNow(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Date_timeIntervalSinceNow_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.timeIntervalSinceNow is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.timeIntervalSinceNow has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_timeIntervalSinceNow(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_timeIntervalSinceNow(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.timeIntervalSinceNow is not available on this platform")
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func Host_Foundation_u002E_Date_timeIntervalSinceReferenceDate_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Foundation.Date.timeIntervalSinceReferenceDate expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be Date host") }
    let receiver = try vm.withHost(args[0], typeName: "Date", as: Foundation.Date.self) { host in
        host
    }
    let result = receiver.timeIntervalSinceReferenceDate
    return .double(result)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func HostDispatcher_Foundation_u002E_Date_timeIntervalSinceReferenceDate(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "Date") {
        switch args[0] {
        case .host:
            if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try Host_Foundation_u002E_Date_timeIntervalSinceReferenceDate_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Foundation.Date.timeIntervalSinceReferenceDate is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Foundation.Date ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Foundation.Date.timeIntervalSinceReferenceDate has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Foundation_u002E_Date_timeIntervalSinceReferenceDate(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *) { return try HostDispatcher_Foundation_u002E_Date_timeIntervalSinceReferenceDate(vm: &vm, args) }
    throw VMError.unsupported("Getter for Foundation.Date.timeIntervalSinceReferenceDate is not available on this platform")
}

