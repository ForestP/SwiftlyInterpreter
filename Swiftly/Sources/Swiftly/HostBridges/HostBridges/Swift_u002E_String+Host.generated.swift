// Generated by HostBridgeEmitter. Do not edit.
import Foundation
import InterpreterModels
import InterpreterVM

// MARK: - Swift.String

public func Host_Swift_u002E_String__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.!=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let lhs = try args[1].expectString("lhs")
    let rhs = try args[2].expectString("rhs")
    let result = lhs != rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u0021__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_bang_eq__Swift_u002E_String__Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.!=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.+(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let lhs = try args[1].expectString("lhs")
    let rhs = try args[2].expectString("rhs")
    let result = lhs + rhs
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u002B__u0028_lhs_u003A_rhs_u003A__u0029___op_plus__Swift_u002E_String__Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.+(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.+=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    var lhs = try args[1].expectString("lhs")
    let rhs = try args[2].expectString("rhs")
    lhs += rhs
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_String__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u002B__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_plus_eq__Swift_u002E_String__Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.+=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.<(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let lhs = try args[1].expectString("lhs")
    let rhs = try args[2].expectString("rhs")
    let result = lhs < rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u003C__u0028_lhs_u003A_rhs_u003A__u0029___op_lt__Swift_u002E_String__Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.<(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.<=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let lhs = try args[1].expectString("lhs")
    let rhs = try args[2].expectString("rhs")
    let result = lhs <= rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u003C__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_lt_eq__Swift_u002E_String__Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.<=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.==(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let lhs = try args[1].expectString("lhs")
    let rhs = try args[2].expectString("rhs")
    let result = lhs == rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u003D__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_eq_eq__Swift_u002E_String__Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.==(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.>(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let lhs = try args[1].expectString("lhs")
    let rhs = try args[2].expectString("rhs")
    let result = lhs > rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u003E__u0028_lhs_u003A_rhs_u003A__u0029___op_gt__Swift_u002E_String__Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.>(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.>=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let lhs = try args[1].expectString("lhs")
    let rhs = try args[2].expectString("rhs")
    let result = lhs >= rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_String__Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u003E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_gt_eq__Swift_u002E_String__Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.>=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__classify_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String._classify() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._classify()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String__classify_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__classify_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._classify() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_String_u002E_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._copyContents(initializing:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let ptr: Swift.UnsafeMutableBufferPointer<Swift.String.Element> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.String.Element>", as: Swift.UnsafeMutableBufferPointer<Swift.String.Element>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._copyContents(initializing: ptr)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String__copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_String_u002E_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__copyContents_u0028_initializing_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_String_u002E_Element_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (initializing: Swift.UnsafeMutableBufferPointer<Swift.String.Element>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._copyContents(initializing:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__copyToContiguousArray_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String._copyToContiguousArray() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._copyToContiguousArray()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String__copyToContiguousArray_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__copyToContiguousArray_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._copyToContiguousArray() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__copyUTF16CodeUnits_u0028_into_u003A_range_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt16_u003E___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String._copyUTF16CodeUnits(into:range:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt16> = try vm.withHost(args[1], typeName: "Swift.UnsafeMutableBufferPointer<Swift.UInt16>", as: Swift.UnsafeMutableBufferPointer<Swift.UInt16>.self) { host in
        host
    }
    let range: Swift.Range<Swift.Int> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    receiver._copyUTF16CodeUnits(into: buffer, range: range)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_String__copyUTF16CodeUnits_u0028_into_u003A_range_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt16_u003E___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__copyUTF16CodeUnits_u0028_into_u003A_range_u003A__u0029___Swift_u002E_UnsafeMutableBufferPointer_u003C_Swift_u002E_UInt16_u003E___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (into: Swift.UnsafeMutableBufferPointer<Swift.UInt16>, range: Swift.Range<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._copyUTF16CodeUnits(into:range:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._customContainsEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let element: Swift.String.Element = try vm.withHost(args[1], typeName: "Swift.String.Element", as: Swift.String.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._customContainsEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        return .bool(unwrapped)
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String__customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__customContainsEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String.Element)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._customContainsEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._customIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let element: Swift.String.Element = try vm.withHost(args[1], typeName: "Swift.String.Element", as: Swift.String.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._customIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "String"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String__customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__customIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String.Element)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._customIndexOfEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._customLastIndexOfEquatableElement(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let element: Swift.String.Element = try vm.withHost(args[1], typeName: "Swift.String.Element", as: Swift.String.Element.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._customLastIndexOfEquatableElement(element)
    switch result {
    case .some(let unwrapped):
        switch unwrapped {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "String"))
        case .none:
            return .nilValue
        }
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String__customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__customLastIndexOfEquatableElement_u0028___u003A__u0029___Swift_u002E_String_u002E_Element(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String.Element)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._customLastIndexOfEquatableElement(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__customRemoveLast_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String._customRemoveLast() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let returnHostTypeID_Element = vm.hostTypeID(named: "Element")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        let result = receiver._customRemoveLast()
        switch result {
        case .some(let unwrapped):
            return .host(HostRef(box: makeOpaqueBox(unwrapped)), returnHostTypeID_Element)
        case .none:
            return .nilValue
        }
    }
}

public func HostDispatcher_Swift_u002E_String__customRemoveLast_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__customRemoveLast_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._customRemoveLast() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._customRemoveLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let n = try args[1].expectInt("n")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        let result = receiver._customRemoveLast(n)
        return .bool(result)
    }
}

public func HostDispatcher_Swift_u002E_String__customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__customRemoveLast_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._customRemoveLast(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__dump_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String._dump() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    receiver._dump()
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_String__dump_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__dump_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._dump() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String._failEarlyRangeCheck(_:bounds:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let index: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let bounds: Swift.Range<Swift.String.Index> = try vm.withHost(args[2], typeName: "Swift.Range<Swift.String.Index>", as: Swift.Range<Swift.String.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    receiver._failEarlyRangeCheck(index, bounds: bounds)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_String__failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__failEarlyRangeCheck_u0028___u003A_bounds_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String.Index, bounds: Swift.Range<Swift.String.Index>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._failEarlyRangeCheck(_:bounds:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__fromInvalidUTF16_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt16_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._fromInvalidUTF16(_:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let utf16: Swift.UnsafeBufferPointer<Swift.UInt16> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Swift.UInt16>", as: Swift.UnsafeBufferPointer<Swift.UInt16>.self) { host in
        host
    }
    let result = Swift.String._fromInvalidUTF16(utf16)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String__fromInvalidUTF16_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt16_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__fromInvalidUTF16_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt16_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.UnsafeBufferPointer<Swift.UInt16>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._fromInvalidUTF16(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
public func Host_Swift_u002E_String__index_u0028_roundingDown_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._index(roundingDown:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let i: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._index(roundingDown: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
public func HostDispatcher_Swift_u002E_String__index_u0028_roundingDown_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        if #available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *) {
            return try Host_Swift_u002E_String__index_u0028_roundingDown_u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args)
        } else {
            throw VMError.unsupported("String._index(roundingDown:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (roundingDown: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._index(roundingDown:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_String__index_u0028_roundingDown_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *) { return try HostDispatcher_Swift_u002E_String__index_u0028_roundingDown_u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args) }
    throw VMError.unsupported("String._index(roundingDown:) is not available on this platform")
}

public func Host_Swift_u002E_String__isIdentical_u0028_to_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._isIdentical(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let other = try args[1].expectString("other")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._isIdentical(to: other)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String__isIdentical_u0028_to_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__isIdentical_u0028_to_u003A__u0029___Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (to: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._isIdentical(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__lock_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String._lock() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver._lock()
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String__lock_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__lock_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._lock() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._rawHashValue(seed:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let seed = try args[1].expectInt("seed")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._rawHashValue(seed: seed)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_String__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__rawHashValue_u0028_seed_u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (seed: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._rawHashValue(seed:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__toUTF16Index_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._toUTF16Index(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let offset = try args[1].expectInt("offset")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._toUTF16Index(offset)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String__toUTF16Index_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__toUTF16Index_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._toUTF16Index(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__toUTF16Indices_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._toUTF16Indices(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let range: Swift.Range<Swift.Int> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.Int>", as: Swift.Range<Swift.Int>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._toUTF16Indices(range)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String__toUTF16Indices_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__toUTF16Indices_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_Int_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Range<Swift.Int>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._toUTF16Indices(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__toUTF16Offset_u0028___u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._toUTF16Offset(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let idx: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._toUTF16Offset(idx)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_String__toUTF16Offset_u0028___u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__toUTF16Offset_u0028___u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._toUTF16Offset(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__toUTF16Offsets_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._toUTF16Offsets(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let indices: Swift.Range<Swift.String.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.String.Index>", as: Swift.Range<Swift.String.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._toUTF16Offsets(indices)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String__toUTF16Offsets_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__toUTF16Offsets_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Range<Swift.String.Index>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._toUTF16Offsets(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__tryFromUTF8_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._tryFromUTF8(_:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let input: Swift.UnsafeBufferPointer<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Swift.UInt8>", as: Swift.UnsafeBufferPointer<Swift.UInt8>.self) { host in
        host
    }
    let result = Swift.String._tryFromUTF8(input)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String__tryFromUTF8_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__tryFromUTF8_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.UnsafeBufferPointer<Swift.UInt8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._tryFromUTF8(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__unlock_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String._unlock() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver._unlock()
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String__unlock_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__unlock_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._unlock() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__writeASCII_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String._writeASCII(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let buffer: Swift.UnsafeBufferPointer<Swift.UInt8> = try vm.withHost(args[1], typeName: "Swift.UnsafeBufferPointer<Swift.UInt8>", as: Swift.UnsafeBufferPointer<Swift.UInt8>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver._writeASCII(buffer)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String__writeASCII_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__writeASCII_u0028___u003A__u0029___Swift_u002E_UnsafeBufferPointer_u003C_Swift_u002E_UInt8_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.UnsafeBufferPointer<Swift.UInt8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String._writeASCII(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_append_u0028___u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.append(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let other = try args[1].expectString("other")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.append(other)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_append_u0028___u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_append_u0028___u003A__u0029___Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.append(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_append_u0028_contentsOf_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.append(contentsOf:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let newElements = try args[1].expectString("newElements")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.append(contentsOf: newElements)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_append_u0028_contentsOf_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_append_u0028_contentsOf_u003A__u0029___Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (contentsOf: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.append(contentsOf:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func Host_Swift_u002E_String_applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_String_u002E_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.applying(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let difference: Swift.CollectionDifference<Swift.String.Element> = try vm.withHost(args[1], typeName: "Swift.CollectionDifference<Swift.String.Element>", as: Swift.CollectionDifference<Swift.String.Element>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.applying(difference)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public func HostDispatcher_Swift_u002E_String_applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_String_u002E_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {
            return try Host_Swift_u002E_String_applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_String_u002E_Element_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("String.applying(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.CollectionDifference<Swift.String.Element>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.applying(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_String_applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_String_u002E_Element_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) { return try HostDispatcher_Swift_u002E_String_applying_u0028___u003A__u0029___Swift_u002E_CollectionDifference_u003C_Swift_u002E_String_u002E_Element_u003E_(vm: &vm, args) }
    throw VMError.unsupported("String.applying(_:) is not available on this platform")
}

public func Host_Swift_u002E_String_distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.distance(from:to:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let start: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let end: Swift.String.Index = try vm.withHost(args[2], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.distance(from: start, to: end)
    return .int(result)
}

public func HostDispatcher_Swift_u002E_String_distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_distance_u0028_from_u003A_to_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (from: Swift.String.Index, to: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.distance(from:to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_dropFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.dropFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.dropFirst(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_dropFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_dropFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.dropFirst(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_dropLast_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.dropLast(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let k = try args[1].expectInt("k")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.dropLast(k)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_dropLast_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_dropLast_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.dropLast(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.encode(to:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let encoder: Swift.Encoder = try vm.withHost(args[1], typeName: "Swift.Encoder", as: Swift.Encoder.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    try receiver.encode(to: encoder)
    return .bool(true)
}

public func HostDispatcher_Swift_u002E_String_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_encode_u0028_to_u003A__u0029___Swift_u002E_Encoder(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (to: Swift.Encoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.encode(to:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_enumerated_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.enumerated() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.enumerated()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_enumerated_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_enumerated_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.enumerated() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_hasPrefix_u0028___u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.hasPrefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let prefix = try args[1].expectString("prefix")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.hasPrefix(prefix)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String_hasPrefix_u0028___u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_hasPrefix_u0028___u003A__u0029___Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.hasPrefix(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_hasSuffix_u0028___u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.hasSuffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let suffix = try args[1].expectString("suffix")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.hasSuffix(suffix)
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String_hasSuffix_u0028___u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_hasSuffix_u0028___u003A__u0029___Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.hasSuffix(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.index(_:offsetBy:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let i: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_index_u0028___u003A_offsetBy_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String.Index, offsetBy: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.index(_:offsetBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Int__Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 4 else { throw VMError.typeError("String.index(_:offsetBy:limitedBy:) expects 3 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let i: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let distance = try args[2].expectInt("distance")
    let limit: Swift.String.Index = try vm.withHost(args[3], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.index(i, offsetBy: distance, limitedBy: limit)
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "String"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String_index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Int__Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_index_u0028___u003A_offsetBy_u003A_limitedBy_u003A__u0029___Swift_u002E_String_u002E_Index__Swift_u002E_Int__Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String.Index, offsetBy: Swift.Int, limitedBy: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.index(_:offsetBy:limitedBy:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_index_u0028_after_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.index(after:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let i: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.index(after: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_index_u0028_after_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_index_u0028_after_u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (after: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.index(after:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_index_u0028_before_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.index(before:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let i: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.index(before: i)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_index_u0028_before_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_index_u0028_before_u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (before: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.index(before:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.init() expects 0 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let result = Swift.String()
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028___u003A__u0029___Swift_u002E_Character(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(_:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let c: Swift.Character = try vm.withHost(args[1], typeName: "Swift.Character", as: Swift.Character.self) { host in
        host
    }
    let result = Swift.String(c)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028___u003A__u0029___Swift_u002E_Character(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028___u003A__u0029___Swift_u002E_Character(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Character)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028_cString_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(cString:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let nullTerminatedUTF8: Swift.UnsafePointer<Swift.Int8> = try vm.withHost(args[1], typeName: "Swift.UnsafePointer<Swift.Int8>", as: Swift.UnsafePointer<Swift.Int8>.self) { host in
        host
    }
    let result = Swift.String(cString: nullTerminatedUTF8)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028_cString_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_cString_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (cString: Swift.UnsafePointer<Swift.Int8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(cString:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Foundation_u002E_Data__Subject_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(describing:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let instance: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let result = Swift.String(describing: instance)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_Bool__Subject_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(describing:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let instance = try args[1].expectBool("instance")
    let result = Swift.String(describing: instance)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_Double__Subject_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(describing:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let instance = try args[1].expectDouble("instance")
    let result = Swift.String(describing: instance)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_Int__Subject_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(describing:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let instance = try args[1].expectInt("instance")
    let result = Swift.String(describing: instance)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_String__Subject_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(describing:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let instance = try args[1].expectString("instance")
    let result = Swift.String(describing: instance)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_UInt8__Subject_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(describing:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let instance: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    let result = Swift.String(describing: instance)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028_describing_u003A__u0029___Subject(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Foundation_u002E_Data__Subject_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_Bool__Subject_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_Double__Subject_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_Int__Subject_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_String__Subject_Swift_u002E_String(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_describing_u003A__u0029___Swift_u002E_UInt8__Subject_Swift_u002E_UInt8(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (describing: Foundation.Data)",
        "  - Swift.String (describing: Swift.Bool)",
        "  - Swift.String (describing: Swift.Double)",
        "  - Swift.String (describing: Swift.Int)",
        "  - Swift.String (describing: Swift.String)",
        "  - Swift.String (describing: Swift.UInt8)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(describing:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(from:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let decoder: Swift.Decoder = try vm.withHost(args[1], typeName: "Swift.Decoder", as: Swift.Decoder.self) { host in
        host
    }
    let result = try Swift.String(from: decoder)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_from_u003A__u0029___Swift_u002E_Decoder(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (from: Swift.Decoder)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Foundation_u002E_Data__Subject_Foundation_u002E_Data(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(reflecting:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let subject: Foundation.Data = try vm.withHost(args[1], typeName: "Foundation.Data", as: Foundation.Data.self) { host in
        host
    }
    let result = Swift.String(reflecting: subject)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_Bool__Subject_Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(reflecting:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let subject = try args[1].expectBool("subject")
    let result = Swift.String(reflecting: subject)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_Double__Subject_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(reflecting:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let subject = try args[1].expectDouble("subject")
    let result = Swift.String(reflecting: subject)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_Int__Subject_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(reflecting:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let subject = try args[1].expectInt("subject")
    let result = Swift.String(reflecting: subject)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_String__Subject_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(reflecting:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let subject = try args[1].expectString("subject")
    let result = Swift.String(reflecting: subject)
    return .string(result)
}

public func Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_UInt8__Subject_Swift_u002E_UInt8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(reflecting:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let subject: Swift.UInt8 = try vm.withHost(args[1], typeName: "Swift.UInt8", as: Swift.UInt8.self) { host in
        host
    }
    let result = Swift.String(reflecting: subject)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Subject(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Foundation_u002E_Data__Subject_Foundation_u002E_Data(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_Bool__Subject_Swift_u002E_Bool(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_Double__Subject_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_Int__Subject_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_String__Subject_Swift_u002E_String(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_reflecting_u003A__u0029___Swift_u002E_UInt8__Subject_Swift_u002E_UInt8(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (reflecting: Foundation.Data)",
        "  - Swift.String (reflecting: Swift.Bool)",
        "  - Swift.String (reflecting: Swift.Double)",
        "  - Swift.String (reflecting: Swift.Int)",
        "  - Swift.String (reflecting: Swift.String)",
        "  - Swift.String (reflecting: Swift.UInt8)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(reflecting:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_String__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.init(repeating:count:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let repeatedValue = try args[1].expectString("repeatedValue")
    let count = try args[2].expectInt("count")
    let result = Swift.String(repeating: repeatedValue, count: count)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_String__Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_repeating_u003A_count_u003A__u0029___Swift_u002E_String__Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (repeating: Swift.String, count: Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(repeating:count:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028_stringInterpolation_u003A__u0029___Swift_u002E_DefaultStringInterpolation(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(stringInterpolation:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let stringInterpolation: Swift.DefaultStringInterpolation = try vm.withHost(args[1], typeName: "Swift.DefaultStringInterpolation", as: Swift.DefaultStringInterpolation.self) { host in
        host
    }
    let result = Swift.String(stringInterpolation: stringInterpolation)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028_stringInterpolation_u003A__u0029___Swift_u002E_DefaultStringInterpolation(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_stringInterpolation_u003A__u0029___Swift_u002E_DefaultStringInterpolation(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (stringInterpolation: Swift.DefaultStringInterpolation)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(stringInterpolation:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028_stringLiteral_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(stringLiteral:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let value = try args[1].expectString("value")
    let result = Swift.String(stringLiteral: value)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_init_u0028_stringLiteral_u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_stringLiteral_u003A__u0029___Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (stringLiteral: Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(stringLiteral:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_init_u0028_validatingCString_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(validatingCString:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let nullTerminatedUTF8: Swift.UnsafePointer<Swift.Int8> = try vm.withHost(args[1], typeName: "Swift.UnsafePointer<Swift.Int8>", as: Swift.UnsafePointer<Swift.Int8>.self) { host in
        host
    }
    let result = Swift.String(validatingCString: nullTerminatedUTF8)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String_init_u0028_validatingCString_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_validatingCString_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (validatingCString: Swift.UnsafePointer<Swift.Int8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(validatingCString:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(swift, deprecated: 6, renamed: "String.init(validatingCString:)")
public func Host_Swift_u002E_String_init_u0028_validatingUTF8_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.init(validatingUTF8:) expects 1 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let cString: Swift.UnsafePointer<Swift.Int8> = try vm.withHost(args[1], typeName: "Swift.UnsafePointer<Swift.Int8>", as: Swift.UnsafePointer<Swift.Int8>.self) { host in
        host
    }
    let result = Swift.String(validatingUTF8: cString)
    switch result {
    case .some(let unwrapped):
        return .string(unwrapped)
    case .none:
        return .nilValue
    }
}

@available(swift, deprecated: 6, renamed: "String.init(validatingCString:)")
public func HostDispatcher_Swift_u002E_String_init_u0028_validatingUTF8_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_init_u0028_validatingUTF8_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (validatingUTF8: Swift.UnsafePointer<Swift.Int8>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.init(validatingUTF8:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_String_init_u0028_validatingUTF8_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if true { return try HostDispatcher_Swift_u002E_String_init_u0028_validatingUTF8_u003A__u0029___Swift_u002E_UnsafePointer_u003C_Swift_u002E_Int8_u003E_(vm: &vm, args) }
    throw VMError.unsupported("String.init(validatingUTF8:) is not available on this platform")
}

public func Host_Swift_u002E_String_insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Character__Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.insert(_:at:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let newElement: Swift.Character = try vm.withHost(args[1], typeName: "Swift.Character", as: Swift.Character.self) { host in
        host
    }
    let i: Swift.String.Index = try vm.withHost(args[2], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.insert(newElement, at: i)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Character__Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_insert_u0028___u003A_at_u003A__u0029___Swift_u002E_Character__Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Character, at: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.insert(_:at:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_lowercased_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.lowercased() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.lowercased()
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_lowercased_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_lowercased_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.lowercased() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_makeContiguousUTF8_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.makeContiguousUTF8() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.makeContiguousUTF8()
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_makeContiguousUTF8_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_makeContiguousUTF8_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.makeContiguousUTF8() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_makeIterator_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.makeIterator() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.makeIterator()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_makeIterator_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_makeIterator_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.makeIterator() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_max_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double__T_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.max(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let x = try args[1].expectDouble("x")
    let y = try args[2].expectDouble("y")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.max(x, y)
    return .double(result)
}

public func Host_Swift_u002E_String_max_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__T_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.max(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let x = try args[1].expectInt("x")
    let y = try args[2].expectInt("y")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.max(x, y)
    return .int(result)
}

public func Host_Swift_u002E_String_max_u0028___u003A___u003A__u0029___Swift_u002E_String__Swift_u002E_String__T_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.max(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let x = try args[1].expectString("x")
    let y = try args[2].expectString("y")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.max(x, y)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_max_u0028___u003A___u003A__u0029___T__T(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_max_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double__T_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_max_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__T_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_max_u0028___u003A___u003A__u0029___Swift_u002E_String__Swift_u002E_String__T_Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Double, Swift.Double)",
        "  - Swift.String (Swift.Int, Swift.Int)",
        "  - Swift.String (Swift.String, Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.max(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_min_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double__T_Swift_u002E_Double(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.min(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let x = try args[1].expectDouble("x")
    let y = try args[2].expectDouble("y")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.min(x, y)
    return .double(result)
}

public func Host_Swift_u002E_String_min_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__T_Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.min(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let x = try args[1].expectInt("x")
    let y = try args[2].expectInt("y")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.min(x, y)
    return .int(result)
}

public func Host_Swift_u002E_String_min_u0028___u003A___u003A__u0029___Swift_u002E_String__Swift_u002E_String__T_Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.min(_:_:) expects 2 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let x = try args[1].expectString("x")
    let y = try args[2].expectString("y")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.min(x, y)
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_min_u0028___u003A___u003A__u0029___T__T(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_min_u0028___u003A___u003A__u0029___Swift_u002E_Double__Swift_u002E_Double__T_Swift_u002E_Double(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_min_u0028___u003A___u003A__u0029___Swift_u002E_Int__Swift_u002E_Int__T_Swift_u002E_Int(vm: &vm, args)
    }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_min_u0028___u003A___u003A__u0029___Swift_u002E_String__Swift_u002E_String__T_Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Double, Swift.Double)",
        "  - Swift.String (Swift.Int, Swift.Int)",
        "  - Swift.String (Swift.String, Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.min(_:_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_prefix_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.prefix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.prefix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_prefix_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_prefix_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.prefix(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_prefix_u0028_through_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.prefix(through:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let position: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.prefix(through: position)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_prefix_u0028_through_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_prefix_u0028_through_u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (through: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.prefix(through:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_prefix_u0028_upTo_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.prefix(upTo:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let end: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.prefix(upTo: end)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_prefix_u0028_upTo_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_prefix_u0028_upTo_u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (upTo: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.prefix(upTo:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_randomElement_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.randomElement() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.randomElement()
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "String"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String_randomElement_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_randomElement_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.randomElement() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_remove_u0028_at_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.remove(at:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let i: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let returnHostTypeID_Character = vm.hostTypeID(named: "Character")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        let result = receiver.remove(at: i)
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Character)
    }
}

public func HostDispatcher_Swift_u002E_String_remove_u0028_at_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_remove_u0028_at_u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (at: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.remove(at:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.removeAll(keepingCapacity:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let keepCapacity = try args[1].expectBool("keepCapacity")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.removeAll(keepingCapacity: keepCapacity)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_removeAll_u0028_keepingCapacity_u003A__u0029___Swift_u002E_Bool(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (keepingCapacity: Swift.Bool)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.removeAll(keepingCapacity:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_removeFirst_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.removeFirst() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let returnHostTypeID_Element = vm.hostTypeID(named: "Element")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        let result = receiver.removeFirst()
        return .host(HostRef(box: makeOpaqueBox(result)), returnHostTypeID_Element)
    }
}

public func HostDispatcher_Swift_u002E_String_removeFirst_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_removeFirst_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.removeFirst() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_removeFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.removeFirst(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let k = try args[1].expectInt("k")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.removeFirst(k)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_removeFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_removeFirst_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.removeFirst(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.removeSubrange(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let bounds: Swift.Range<Swift.String.Index> = try vm.withHost(args[1], typeName: "Swift.Range<Swift.String.Index>", as: Swift.Range<Swift.String.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.removeSubrange(bounds)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_removeSubrange_u0028___u003A__u0029___Swift_u002E_Range_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Range<Swift.String.Index>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.removeSubrange(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_String_removeSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.removeSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let subranges: Swift.RangeSet<Swift.String.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.String.Index>", as: Swift.RangeSet<Swift.String.Index>.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.removeSubranges(subranges)
        return args[0]
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func HostDispatcher_Swift_u002E_String_removeSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
            return try Host_Swift_u002E_String_removeSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("String.removeSubranges(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.RangeSet<Swift.String.Index>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.removeSubranges(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_String_removeSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) { return try HostDispatcher_Swift_u002E_String_removeSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: &vm, args) }
    throw VMError.unsupported("String.removeSubranges(_:) is not available on this platform")
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func Host_Swift_u002E_String_removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.removingSubranges(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let subranges: Swift.RangeSet<Swift.String.Index> = try vm.withHost(args[1], typeName: "Swift.RangeSet<Swift.String.Index>", as: Swift.RangeSet<Swift.String.Index>.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.removingSubranges(subranges)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public func HostDispatcher_Swift_u002E_String_removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) {
            return try Host_Swift_u002E_String_removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: &vm, args)
        } else {
            throw VMError.unsupported("String.removingSubranges(_:) is not available on this platform")
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.RangeSet<Swift.String.Index>)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.removingSubranges(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_String_removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *) { return try HostDispatcher_Swift_u002E_String_removingSubranges_u0028___u003A__u0029___Swift_u002E_RangeSet_u003C_Swift_u002E_String_u002E_Index_u003E_(vm: &vm, args) }
    throw VMError.unsupported("String.removingSubranges(_:) is not available on this platform")
}

public func Host_Swift_u002E_String_reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.reserveCapacity(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let n = try args[1].expectInt("n")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.reserveCapacity(n)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_reserveCapacity_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.reserveCapacity(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_reversed_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.reversed() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.reversed()
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_reversed_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_reversed_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.reversed() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_shuffled_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.shuffled() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.shuffled()
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "Element")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_String_shuffled_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_shuffled_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.shuffled() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_suffix_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.suffix(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let maxLength = try args[1].expectInt("maxLength")
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.suffix(maxLength)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_suffix_u0028___u003A__u0029___Swift_u002E_Int(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_suffix_u0028___u003A__u0029___Swift_u002E_Int(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.Int)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.suffix(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_suffix_u0028_from_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.suffix(from:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let start: Swift.String.Index = try vm.withHost(args[1], typeName: "Swift.String.Index", as: Swift.String.Index.self) { host in
        host
    }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.suffix(from: start)
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_suffix_u0028_from_u003A__u0029___Swift_u002E_String_u002E_Index(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_suffix_u0028_from_u003A__u0029___Swift_u002E_String_u002E_Index(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (from: Swift.String.Index)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.suffix(from:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_uppercased_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("String.uppercased() expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.uppercased()
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_uppercased_u0028__u0029_(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_uppercased_u0028__u0029_(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String ()",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.uppercased() has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_write_u0028___u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("String.write(_:) expects 1 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let other = try args[1].expectString("other")
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.write(other)
        return args[0]
    }
}

public func HostDispatcher_Swift_u002E_String_write_u0028___u003A__u0029___Swift_u002E_String(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be host") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String_write_u0028___u003A__u0029___Swift_u002E_String(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (Swift.String)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.write(_:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__u007E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_tilde_eq__Swift_u002E_String__Swift_u002E_Substring(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 3 else { throw VMError.typeError("String.~=(lhs:rhs:) expects 2 args") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be String metatype") }
    let lhs = try args[1].expectString("lhs")
    let rhs: Swift.Substring = try vm.withHost(args[2], typeName: "Swift.Substring", as: Swift.Substring.self) { host in
        host
    }
    let result = lhs ~= rhs
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String__u007E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_tilde_eq__Swift_u002E_String__Swift_u002E_Substring(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    guard case let .metatype(tid) = args[0] else { throw VMError.typeError("receiver must be metatype") }
    if tid == vm.hostTypeID(named: "Swift.String") {
        return try Host_Swift_u002E_String__u007E__u003D__u0028_lhs_u003A_rhs_u003A__u0029___op_tilde_eq__Swift_u002E_String__Swift_u002E_Substring(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (lhs: Swift.String, rhs: Swift.Substring)",
    ] .joined(separator: "\n")
    throw VMError.typeError("String.~=(lhs:rhs:) has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__ephemeralString_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String._ephemeralString expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._ephemeralString
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String__ephemeralString(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String__ephemeralString_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String._ephemeralString has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__guts_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String._guts expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._guts
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String__guts(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String__guts_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String._guts has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostSet_Swift_u002E_String__guts_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Swift.String._guts setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be String host") }
    let newValue: Swift._StringGuts = try vm.withHost(args[1], typeName: "Swift._StringGuts", as: Swift._StringGuts.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver._guts = newValue
        return .nilValue
    }
}

public func HostSetter_Swift_u002E_String__guts(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "String") {
        return try HostSet_Swift_u002E_String__guts_instance(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (value: Swift._StringGuts)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Swift.String._guts has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String__nfcCodeUnits_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String._nfcCodeUnits expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver._nfcCodeUnits
    var result_value_elements: [Value] = []
    result_value_elements.reserveCapacity(result.count)
    for result_value_element in result {
        result_value_elements.append(.host(HostRef(box: makeOpaqueBox(result_value_element)), vm.hostTypeID(named: "UInt8")))
    }
    let result_value_arrayBox = ArrBox(result_value_elements)
    return .array(result_value_arrayBox)
}

public func HostDispatcher_Swift_u002E_String__nfcCodeUnits(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String__nfcCodeUnits_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String._nfcCodeUnits has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
public func Host_Swift_u002E_String_codingKey_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.codingKey expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.codingKey
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
public func HostDispatcher_Swift_u002E_String_codingKey(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host:
            if #available(macOS 12.3, iOS 15.4, tvOS 15.4, watchOS 8.5, *) { return try Host_Swift_u002E_String_codingKey_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Swift.String.codingKey is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.codingKey has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_String_codingKey(vm: inout VM, _ args: [Value]) throws -> Value {
    if #available(macOS 12.3, iOS 15.4, tvOS 15.4, watchOS 8.5, *) { return try HostDispatcher_Swift_u002E_String_codingKey(vm: &vm, args) }
    throw VMError.unsupported("Getter for Swift.String.codingKey is not available on this platform")
}

public func Host_Swift_u002E_String_count_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.count expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.count
    return .int(result)
}

public func HostDispatcher_Swift_u002E_String_count(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_count_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.count has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_customMirror_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.customMirror expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.customMirror
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_customMirror(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_customMirror_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.customMirror has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

@available(*, deprecated, message: "String.customPlaygroundQuickLook will be removed in a future Swift version")
public func Host_Swift_u002E_String_customPlaygroundQuickLook_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.customPlaygroundQuickLook expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.customPlaygroundQuickLook
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

@available(*, deprecated, message: "String.customPlaygroundQuickLook will be removed in a future Swift version")
public func HostDispatcher_Swift_u002E_String_customPlaygroundQuickLook(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host:
            if true { return try Host_Swift_u002E_String_customPlaygroundQuickLook_instance(vm: &vm, args) }
            else { throw VMError.unsupported("Getter for Swift.String.customPlaygroundQuickLook is not available on this platform") }
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.customPlaygroundQuickLook has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostAvailWrap_HostDispatcher_Swift_u002E_String_customPlaygroundQuickLook(vm: inout VM, _ args: [Value]) throws -> Value {
    if true { return try HostDispatcher_Swift_u002E_String_customPlaygroundQuickLook(vm: &vm, args) }
    throw VMError.unsupported("Getter for Swift.String.customPlaygroundQuickLook is not available on this platform")
}

public func Host_Swift_u002E_String_debugDescription_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.debugDescription expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.debugDescription
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_debugDescription(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_debugDescription_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.debugDescription has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_description_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.description expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.description
    return .string(result)
}

public func HostDispatcher_Swift_u002E_String_description(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_description_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.description has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_endIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.endIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.endIndex
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_endIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_endIndex_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.endIndex has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_first_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.first expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.first
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "String"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String_first(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_first_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.first has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_hashValue_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.hashValue expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.hashValue
    return .int(result)
}

public func HostDispatcher_Swift_u002E_String_hashValue(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_hashValue_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.hashValue has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_indices_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.indices expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.indices
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_indices(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_indices_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.indices has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_isContiguousUTF8_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.isContiguousUTF8 expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.isContiguousUTF8
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String_isContiguousUTF8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_isContiguousUTF8_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.isContiguousUTF8 has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_isEmpty_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.isEmpty expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.isEmpty
    return .bool(result)
}

public func HostDispatcher_Swift_u002E_String_isEmpty(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_isEmpty_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.isEmpty has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_last_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.last expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.last
    switch result {
    case .some(let unwrapped):
        return .host(HostRef(box: makeOpaqueBox(unwrapped)), vm.hostTypeID(named: "String"))
    case .none:
        return .nilValue
    }
}

public func HostDispatcher_Swift_u002E_String_last(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_last_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.last has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_lazy_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.lazy expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.lazy
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_lazy(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_lazy_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.lazy has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_startIndex_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.startIndex expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.startIndex
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_startIndex(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_startIndex_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.startIndex has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_underestimatedCount_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.underestimatedCount expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.underestimatedCount
    return .int(result)
}

public func HostDispatcher_Swift_u002E_String_underestimatedCount(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_underestimatedCount_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.underestimatedCount has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_unicodeScalars_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.unicodeScalars expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.unicodeScalars
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_unicodeScalars(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_unicodeScalars_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.unicodeScalars has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostSet_Swift_u002E_String_unicodeScalars_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Swift.String.unicodeScalars setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be String host") }
    let newValue: Swift.String.UnicodeScalarView = try vm.withHost(args[1], typeName: "Swift.String.UnicodeScalarView", as: Swift.String.UnicodeScalarView.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.unicodeScalars = newValue
        return .nilValue
    }
}

public func HostSetter_Swift_u002E_String_unicodeScalars(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "String") {
        return try HostSet_Swift_u002E_String_unicodeScalars_instance(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (value: Swift.String.UnicodeScalarView)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Swift.String.unicodeScalars has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_utf16_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.utf16 expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.utf16
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_utf16(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_utf16_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.utf16 has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostSet_Swift_u002E_String_utf16_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Swift.String.utf16 setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be String host") }
    let newValue: Swift.String.UTF16View = try vm.withHost(args[1], typeName: "Swift.String.UTF16View", as: Swift.String.UTF16View.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.utf16 = newValue
        return .nilValue
    }
}

public func HostSetter_Swift_u002E_String_utf16(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "String") {
        return try HostSet_Swift_u002E_String_utf16_instance(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (value: Swift.String.UTF16View)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Swift.String.utf16 has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_utf8_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.utf8 expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.utf8
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_utf8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_utf8_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.utf8 has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func HostSet_Swift_u002E_String_utf8_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 2 else { throw VMError.typeError("Swift.String.utf8 setter expects value") }
    guard case .host = args[0] else { throw VMError.typeError("receiver must be String host") }
    let newValue: Swift.String.UTF8View = try vm.withHost(args[1], typeName: "Swift.String.UTF8View", as: Swift.String.UTF8View.self) { host in
        host
    }
    return try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { receiver in
        receiver.utf8 = newValue
        return .nilValue
    }
}

public func HostSetter_Swift_u002E_String_utf8(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    guard case let .host(_, receiverTid) = args[0] else { throw VMError.typeError("receiver must be host") }
    tid = receiverTid
    if tid == vm.hostTypeID(named: "String") {
        return try HostSet_Swift_u002E_String_utf8_instance(vm: &vm, args)
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
        "  - Swift.String (value: Swift.String.UTF8View)",
    ] .joined(separator: "\n")
    throw VMError.typeError("Setter for Swift.String.utf8 has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

public func Host_Swift_u002E_String_utf8CString_instance(vm: inout VM, _ args: [Value]) throws -> Value {
    guard args.count == 1 else { throw VMError.typeError("Swift.String.utf8CString expects 0 args") }
    guard case let .host(_, tid) = args[0] else { throw VMError.typeError("receiver must be String host") }
    let receiver = try vm.withHost(args[0], typeName: "String", as: Swift.String.self) { host in
        host
    }
    let result = receiver.utf8CString
    return .host(HostRef(box: makeOpaqueBox(result)), vm.hostTypeID(named: "String"))
}

public func HostDispatcher_Swift_u002E_String_utf8CString(vm: inout VM, _ args: [Value]) throws -> Value {
    guard !args.isEmpty else { throw VMError.typeError("missing receiver") }
    let tid: TypeID
    switch args[0] {
    case .host(_, let receiverTid): tid = receiverTid
    case .metatype(let receiverTid): tid = receiverTid
    default: throw VMError.typeError("receiver must be host or metatype")
    }
    if tid == vm.hostTypeID(named: "String") {
        switch args[0] {
        case .host: return try Host_Swift_u002E_String_utf8CString_instance(vm: &vm, args)
        default: break
        }
    }
    let receiverName = vm.debugTypeName(tid)
    let supported = [
    "  - Swift.String ()",
] .joined(separator: "\n")
    throw VMError.typeError("Getter for Swift.String.utf8CString has no specialization for receiver \(receiverName). Supported specializations:\(supported)")
}

